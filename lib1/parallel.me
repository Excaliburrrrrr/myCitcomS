Advection_diffusion.c:78:    int m=E->parallel.me;
Advection_diffusion.c:80:    input_boolean("ADV",&(E->advection.ADVECTION),"on",m);
Advection_diffusion.c:81:    input_boolean("filter_temp",&(E->advection.filter_temperature),"off",m);
Advection_diffusion.c:82:    input_boolean("monitor_max_T",&(E->advection.monitor_max_T),"on",m);
Advection_diffusion.c:84:    input_int("minstep",&(E->advection.min_timesteps),"1",m);
Advection_diffusion.c:85:    input_int("maxstep",&(E->advection.max_timesteps),"1000",m);
Advection_diffusion.c:86:    input_int("maxtotstep",&(E->advection.max_total_timesteps),"1000000",m);
Advection_diffusion.c:87:    input_float("finetunedt",&(E->advection.fine_tune_dt),"0.9",m);
Advection_diffusion.c:88:    input_float("fixed_timestep",&(E->advection.fixed_timestep),"0.0",m);
Advection_diffusion.c:89:    input_float("adv_gamma",&(E->advection.gamma),"0.5",m);
Advection_diffusion.c:90:    input_int("adv_sub_iterations",&(E->advection.temp_iterations),"2,1,nomax",m);
Advection_diffusion.c:92:    input_float("inputdiffusivity",&(E->control.inputdiff),"1.0",m);
Advection_diffusion.c:103:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Advection_diffusion.c:104:    E->Tdot[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:106:    for(i=1;i<=E->lmesh.nno;i++)
Advection_diffusion.c:107:      E->Tdot[m][i]=0.0;
Advection_diffusion.c:152:    const int dims=E->mesh.nsd;
Advection_diffusion.c:153:    const int dofs=E->mesh.dof;
Advection_diffusion.c:154:    const int nno=E->lmesh.nno;
Advection_diffusion.c:155:    const int lev=E->mesh.levmax;
Advection_diffusion.c:159:    nel=E->lmesh.nel;
Advection_diffusion.c:161:    if(E->advection.fixed_timestep != 0.0) {
Advection_diffusion.c:162:      E->advection.timestep = E->advection.fixed_timestep;
Advection_diffusion.c:167:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:174:	  uc1 += E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:175:	  uc2 += E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:176:	  uc3 += E->N.ppt[GNPINDEX(i,1)]*VV[3][i];
Advection_diffusion.c:178:	uc = fabs(uc1)/E->eco[m][el].size[1] + fabs(uc2)/E->eco[m][el].size[2] + fabs(uc3)/E->eco[m][el].size[3];
Advection_diffusion.c:184:    adv_timestep = E->advection.dt_reduced * adv_timestep;
Advection_diffusion.c:186:    adv_timestep = 1.0e-32 + min(E->advection.fine_tune_dt*adv_timestep,
Advection_diffusion.c:187:				 E->advection.diff_timestep);
Advection_diffusion.c:189:    E->advection.timestep = global_fmin(E,adv_timestep);
Advection_diffusion.c:191:/*     if (E->parallel.me==0) */
Advection_diffusion.c:192:/*       fprintf(stderr, "adv_timestep=%g diff_timestep=%g\n",adv_timestep,E->advection.diff_timestep); */
Advection_diffusion.c:209:  E->advection.timesteps++;
Advection_diffusion.c:211:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:212:    DTdot[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:215:  if(E->advection.monitor_max_T) {
Advection_diffusion.c:216:     for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Advection_diffusion.c:217:         T1[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:218:         Tdot1[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:221:     for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:222:         for (i=1;i<=E->lmesh.nno;i++)   {
Advection_diffusion.c:223:             T1[m][i] = E->T[m][i];
Advection_diffusion.c:224:             Tdot1[m][i] = E->Tdot[m][i];
Advection_diffusion.c:228:     T_interior1 = Tmaxd(E,E->T);
Advection_diffusion.c:231:  E->advection.dt_reduced = 1.0;
Advection_diffusion.c:232:  E->advection.last_sub_iterations = 1;
Advection_diffusion.c:236:    E->advection.timestep *= E->advection.dt_reduced;
Advection_diffusion.c:239:    if (E->advection.ADVECTION) {
Advection_diffusion.c:241:      predictor(E,E->T,E->Tdot);
Advection_diffusion.c:243:      for(psc_pass=0;psc_pass<E->advection.temp_iterations;psc_pass++)   {
Advection_diffusion.c:245:        if(E->control.disptn_number != 0)
Advection_diffusion.c:249:	pg_solver(E,E->T,E->Tdot,DTdot,&(E->convection.heat_sources),E->control.inputdiff,1,E->node);
Advection_diffusion.c:250:	corrector(E,E->T,E->Tdot,DTdot);
Advection_diffusion.c:254:      if(E->advection.monitor_max_T) {
Advection_diffusion.c:256:          E->monitor.T_interior = Tmaxd(E,E->T);
Advection_diffusion.c:261:          if (E->monitor.T_interior/T_interior1 > E->monitor.T_maxvaried) {
Advection_diffusion.c:262:              if(E->parallel.me==0) {
Advection_diffusion.c:264:                          T_interior1, E->monitor.T_interior);
Advection_diffusion.c:265:                  fprintf(E->fp, "max T varied from %e to %e\n",
Advection_diffusion.c:266:                          T_interior1, E->monitor.T_interior);
Advection_diffusion.c:268:              for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:269:                  for (i=1;i<=E->lmesh.nno;i++)   {
Advection_diffusion.c:270:                      E->T[m][i] = T1[m][i];
Advection_diffusion.c:271:                      E->Tdot[m][i] = Tdot1[m][i];
Advection_diffusion.c:274:              E->advection.dt_reduced *= 0.5;
Advection_diffusion.c:275:              E->advection.last_sub_iterations ++;
Advection_diffusion.c:280:  }  while ( iredo==1 && E->advection.last_sub_iterations <= 5);
Advection_diffusion.c:284:  if(E->advection.filter_temperature)
Advection_diffusion.c:288:  E->advection.total_timesteps++;
Advection_diffusion.c:289:  E->monitor.elapsed_time += E->advection.timestep;
Advection_diffusion.c:291:  if (E->advection.last_sub_iterations==5)
Advection_diffusion.c:292:    E->control.keep_going = 0;
Advection_diffusion.c:294:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Advection_diffusion.c:298:  if(E->advection.monitor_max_T) {
Advection_diffusion.c:299:      for(m=1;m<=E->sphere.caps_per_proc;m++) {
Advection_diffusion.c:305:  if(E->control.lith_age) {
Advection_diffusion.c:306:      if(E->parallel.me==0) fprintf(stderr,"PG_timestep_solve\n");
Advection_diffusion.c:326:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:327:    for(el=1;el<=E->lmesh.nel;el++)  {
Advection_diffusion.c:328:      for(d=1;d<=E->mesh.nsd;d++)    {
Advection_diffusion.c:329:	ts = E->eco[m][el].size[d] * E->eco[m][el].size[d];
Advection_diffusion.c:335:  E->advection.diff_timestep = 0.5 * diff_timestep;
Advection_diffusion.c:351:  multiplier = (1.0-E->advection.gamma) * E->advection.timestep;
Advection_diffusion.c:353:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:354:    for(node=1;node<=E->lmesh.nno;node++)  {
Advection_diffusion.c:369:  multiplier = E->advection.gamma * E->advection.timestep;
Advection_diffusion.c:371:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:372:    for(node=1;node<=E->lmesh.nno;node++) {
Advection_diffusion.c:404:    const int dims=E->mesh.nsd;
Advection_diffusion.c:405:    const int dofs=E->mesh.dof;
Advection_diffusion.c:408:    const int lev=E->mesh.levmax;
Advection_diffusion.c:410:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:411:      for(i=1;i<=E->lmesh.nno;i++)
Advection_diffusion.c:414:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:415:       for(el=1;el<=E->lmesh.nel;el++)    {
Advection_diffusion.c:422:          pg_shape_fn(E, el, &PG, &(E->gNX[m][el]), VV,
Advection_diffusion.c:424:          element_residual(E, el, &PG, &(E->gNX[m][el]), &(E->gDA[m][el]),
Advection_diffusion.c:426:                           Q0, Eres, rtf, diff, E->sphere.cap[m].TB,
Advection_diffusion.c:430:	    a1 = E->ien[m][el].node[a];
Advection_diffusion.c:436:    (E->exchange_node_d)(E,DTdot,lev);
Advection_diffusion.c:438:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:439:      for(i=1;i<=E->lmesh.nno;i++) {
Advection_diffusion.c:440:        if(!(E->node[m][i] & (TBX | TBY | TBZ))){
Advection_diffusion.c:441:	  DTdot[m][i] *= E->TMass[m][i];         /* lumped mass matrix */
Advection_diffusion.c:470:    ienm=E->ien[m][el].node;
Advection_diffusion.c:477:      uc1 +=  E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:478:      uc2 +=  E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:479:      uc3 +=  E->N.ppt[GNPINDEX(i,1)]*VV[3][i];
Advection_diffusion.c:482:    uxse = fabs(uc1*E->eco[m][el].size[1]);
Advection_diffusion.c:483:    ueta = fabs(uc2*E->eco[m][el].size[2]);
Advection_diffusion.c:484:    ufai = fabs(uc3*E->eco[m][el].size[3]);
Advection_diffusion.c:501:		u1 += VV[1][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:502:		u2 += VV[2][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:503:	   	u3 += VV[3][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:511:	    PG->vpt[GNVINDEX(j,i)] = E->N.vpt[GNVINDEX(j,i)] + adiff * prod1;
Advection_diffusion.c:552:    const int dims=E->mesh.nsd;
Advection_diffusion.c:553:    const int dofs=E->mesh.dof;
Advection_diffusion.c:554:    const int nno=E->lmesh.nno;
Advection_diffusion.c:555:    const int lev=E->mesh.levmax;
Advection_diffusion.c:572:      node = E->ien[m][el].node[j];
Advection_diffusion.c:574:      if(E->node[m][node] & (TBX | TBY | TBZ))
Advection_diffusion.c:580:          dT[i] += DT * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:584:          sfn = E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:593:	  Q += Q0->Q[i] * exp(-Q0->lambda[i] * (E->monitor.elapsed_time+Q0->t_offset));
Advection_diffusion.c:597:    Q = E->control.Q0;
Advection_diffusion.c:600:    if(E->control.tracer_enriched){
Advection_diffusion.c:605:      Q *= (1.0 - E->composition.comp_el[m][0][el]);
Advection_diffusion.c:606:      Q += E->composition.comp_el[m][0][el] * E->control.Q0ER;
Advection_diffusion.c:609:    nz = ((el-1) % E->lmesh.elz) + 1;
Advection_diffusion.c:610:    rho = 0.5 * (E->refstate.rho[nz] + E->refstate.rho[nz+1]);
Advection_diffusion.c:611:    cp = 0.5 * (E->refstate.heat_capacity[nz] + E->refstate.heat_capacity[nz+1]);
Advection_diffusion.c:613:    if(E->control.disptn_number == 0)
Advection_diffusion.c:616:        /* E->heating_latent is actually the inverse of latent heating */
Advection_diffusion.c:617:        heating = (rho * Q - E->heating_adi[m][el] + E->heating_visc[m][el])
Advection_diffusion.c:618:            * E->heating_latent[m][el];
Advection_diffusion.c:631:              + diff * dOmega->vpt[i] * E->heating_latent[m][el]
Advection_diffusion.c:654:      if (FLAGS[m][E->ien[m][el].node[1]] & FBZ) {   // only check for the 1st node
Advection_diffusion.c:658:      else if (FLAGS[m][E->ien[m][el].node[5]] & FBZ) {   // only check for the 5th node
Advection_diffusion.c:668:              dT[j] += E->M.vpt[GMVINDEX(k,j)]*BC[3][E->ien[m][el].node[k+aid*onedvpts]];
Advection_diffusion.c:672:		E->M.vpt[GMVINDEX(a,j)] * g_1d[j].weight[dims-1] *
Advection_diffusion.c:705:    lev=E->mesh.levmax;
Advection_diffusion.c:707:    rhocp = (double *)malloc((E->lmesh.noz+1)*sizeof(double));
Advection_diffusion.c:708:    for(i=1;i<=E->lmesh.noz;i++)
Advection_diffusion.c:709:        rhocp[i] = E->refstate.rho[i] * E->refstate.heat_capacity[i];
Advection_diffusion.c:711:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:712:        for(i=1;i<=E->lmesh.nno;i++)  {
Advection_diffusion.c:713:            nz = ((i-1) % E->lmesh.noz) + 1;
Advection_diffusion.c:717:            if(!(E->NODE[lev][m][i] & SKIP))
Advection_diffusion.c:718:                Tsum0 += E->T[m][i]*rhocp[nz];
Advection_diffusion.c:721:            if(E->T[m][i]<Tmin)  Tmin=E->T[m][i];
Advection_diffusion.c:722:            if(E->T[m][i]<Tmin0) E->T[m][i]=Tmin0;
Advection_diffusion.c:723:            if(E->T[m][i]>Tmax) Tmax=E->T[m][i];
Advection_diffusion.c:724:            if(E->T[m][i]>Tmax0) E->T[m][i]=Tmax0;
Advection_diffusion.c:729:    MPI_Allreduce(&Tmin,&Tmin1,1,MPI_DOUBLE,MPI_MIN,E->parallel.world);
Advection_diffusion.c:730:    MPI_Allreduce(&Tmax,&Tmax1,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Advection_diffusion.c:732:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:733:        for(i=1;i<=E->lmesh.nno;i++)  {
Advection_diffusion.c:734:            nz = ((i-1) % E->lmesh.noz) + 1;
Advection_diffusion.c:737:            if(E->T[m][i]<=fabs(2*Tmin0-Tmin1))   E->T[m][i]=Tmin0;
Advection_diffusion.c:738:            if(E->T[m][i]>=(2*Tmax0-Tmax1))   E->T[m][i]=Tmax0;
Advection_diffusion.c:741:            if (!(E->NODE[lev][m][i] & SKIP))  {
Advection_diffusion.c:742:                Tsum1 += E->T[m][i]*rhocp[nz];
Advection_diffusion.c:743:                if(E->T[m][i]!=Tmin0 && E->T[m][i]!=Tmax0) {
Advection_diffusion.c:753:    MPI_Allreduce(&TDIST,&TDIST1,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Advection_diffusion.c:754:    MPI_Allreduce(&sum_rhocp,&total_sum_rhocp,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Advection_diffusion.c:759:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:760:        for(i=1;i<=E->lmesh.nno;i++)   {
Advection_diffusion.c:761:            if(E->T[m][i]!=Tmin0 && E->T[m][i]!=Tmax0)
Advection_diffusion.c:762:                E->T[m][i] +=TDIST;
Advection_diffusion.c:779:    strain_sqr = (float*) malloc((E->lmesh.nel+1)*sizeof(float));
Advection_diffusion.c:782:    temp = E->control.disptn_number / E->control.Atemp / vpts;
Advection_diffusion.c:786:    for(e=1; e<=E->lmesh.nel; e++) {
Advection_diffusion.c:789:            visc += E->EVi[m][(e-1)*vpts + i];
Advection_diffusion.c:807:    temp2 = E->control.disptn_number / ends;
Advection_diffusion.c:808:    for(e=1; e<=E->lmesh.nel; e++) {
Advection_diffusion.c:809:        ez = (e - 1) % E->lmesh.elz + 1;
Advection_diffusion.c:811:            * (E->refstate.thermal_expansivity[ez] +
Advection_diffusion.c:812:               E->refstate.thermal_expansivity[ez + 1])
Advection_diffusion.c:813:            * (E->refstate.rho[ez] + E->refstate.rho[ez + 1])
Advection_diffusion.c:814:            * (E->refstate.gravity[ez] + E->refstate.gravity[ez + 1]);
Advection_diffusion.c:818:            j = E->ien[m][e].node[i];
Advection_diffusion.c:819:            temp1 += E->sphere.cap[m].V[3][j]
Advection_diffusion.c:820:                * (E->T[m][j] + E->control.surface_temp);
Advection_diffusion.c:841:    temp0 = 2.0 * inv_width * clapeyron * E->control.disptn_number * Ra / E->control.Atemp / ends;
Advection_diffusion.c:844:    for(e=1; e<=E->lmesh.nel; e++) {
Advection_diffusion.c:845:        ez = (e - 1) % E->lmesh.elz + 1;
Advection_diffusion.c:847:            * (E->refstate.thermal_expansivity[ez] +
Advection_diffusion.c:848:               E->refstate.thermal_expansivity[ez + 1])
Advection_diffusion.c:849:            * (E->refstate.rho[ez] + E->refstate.rho[ez + 1])
Advection_diffusion.c:850:            * (E->refstate.gravity[ez] + E->refstate.gravity[ez + 1]);
Advection_diffusion.c:855:            j = E->ien[m][e].node[i];
Advection_diffusion.c:857:                * (E->T[m][j] + E->control.surface_temp);
Advection_diffusion.c:858:            temp2 += temp * E->sphere.cap[m].V[3][j];
Advection_diffusion.c:878:    for(e=1; e<=E->lmesh.nel; e++)
Advection_diffusion.c:881:    if(E->control.Ra_410 != 0.0) {
Advection_diffusion.c:883:                       E->Fas410, E->control.Ra_410,
Advection_diffusion.c:884:                       E->control.clapeyron410, E->viscosity.z410,
Advection_diffusion.c:885:                       E->control.transT410, E->control.inv_width410);
Advection_diffusion.c:889:    if(E->control.Ra_670 != 0.0) {
Advection_diffusion.c:891:                       E->Fas670, E->control.Ra_670,
Advection_diffusion.c:892:                       E->control.clapeyron670, E->viscosity.zlm,
Advection_diffusion.c:893:                       E->control.transT670, E->control.inv_width670);
Advection_diffusion.c:896:    if(E->control.Ra_cmb != 0.0) {
Advection_diffusion.c:898:                       E->Fascmb, E->control.Ra_cmb,
Advection_diffusion.c:899:                       E->control.clapeyroncmb, E->viscosity.zcmb,
Advection_diffusion.c:900:                       E->control.transTcmb, E->control.inv_widthcmb);
Advection_diffusion.c:904:    if(E->control.Ra_410 != 0 || E->control.Ra_670 != 0.0 ||
Advection_diffusion.c:905:       E->control.Ra_cmb != 0) {
Advection_diffusion.c:906:        for(e=1; e<=E->lmesh.nel; e++)
Advection_diffusion.c:921:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Advection_diffusion.c:922:        for(e=1; e<=E->lmesh.nel; e++)
Advection_diffusion.c:923:            sum += heating[m][e] * E->eco[m][e].area;
Advection_diffusion.c:928:                  MPI_DOUBLE, MPI_SUM, E->parallel.world);
Advection_diffusion.c:939:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Advection_diffusion.c:943:            process_visc_heating(E, m, E->heating_visc[m]);
Advection_diffusion.c:945:        process_adi_heating(E, m, E->heating_adi[m]);
Advection_diffusion.c:946:        process_latent_heating(E, m, E->heating_latent[m], E->heating_adi[m]);
Advection_diffusion.c:951:    if(psc_pass == (E->advection.temp_iterations-1)) {
Advection_diffusion.c:952:        total_visc_heating = total_heating(E, E->heating_visc);
Advection_diffusion.c:953:        total_adi_heating = total_heating(E, E->heating_adi);
Advection_diffusion.c:955:        if(E->parallel.me == 0) {
Advection_diffusion.c:956:            fprintf(E->fp, "Step: %d, Total_heating(visc, adi): %g %g\n",
Advection_diffusion.c:957:                    E->monitor.solution_cycles,
Advection_diffusion.c:960:                    E->monitor.solution_cycles,
Anisotropic_viscosity.c:63:  if(E->viscosity.allow_anisotropic_viscosity){
Anisotropic_viscosity.c:64:    if((E->monitor.solution_cycles == 0)&&
Anisotropic_viscosity.c:65:       (E->viscosity.anivisc_start_from_iso)&&(E->monitor.visc_iter_count == 0)){
Anisotropic_viscosity.c:279:  const int vpts = vpoints[E->mesh.nsd];
Anisotropic_viscosity.c:280:  const int ends = enodes[E->mesh.nsd];
Anisotropic_viscosity.c:283:  mgmin = E->mesh.gridmin;
Anisotropic_viscosity.c:284:  mgmax = E->mesh.gridmax;
Anisotropic_viscosity.c:286:  mgmin = E->mesh.levmin;
Anisotropic_viscosity.c:287:  mgmax = E->mesh.levmax;
Anisotropic_viscosity.c:290:    if(E->parallel.me == 0)
Anisotropic_viscosity.c:292:	      (E->viscosity.allow_anisotropic_viscosity == 1)?("orthotropic"):("transversely isotropic"));
Anisotropic_viscosity.c:293:    if(E->viscosity.anisotropic_viscosity_init)
Anisotropic_viscosity.c:298:    switch(E->viscosity.anisotropic_init){
Anisotropic_viscosity.c:303:      if(E->parallel.me == 0)fprintf(stderr,"set_anisotropic_viscosity_at_element_level: initializing isotropic viscosity\n");
Anisotropic_viscosity.c:306:	nel  = E->lmesh.NEL[i];
Anisotropic_viscosity.c:307:	for (m=1;m <= E->sphere.caps_per_proc;m++) {
Anisotropic_viscosity.c:311:	      E->EVI2[i][m][off] = 0.0;
Anisotropic_viscosity.c:312:	      E->EVIn1[i][m][off] = 1.0; E->EVIn2[i][m][off] = E->EVIn3[i][m][off] = 0.0;
Anisotropic_viscosity.c:313:	      E->avmode[i][m][off] = (unsigned char)
Anisotropic_viscosity.c:314:		E->viscosity.allow_anisotropic_viscosity;
Anisotropic_viscosity.c:321:	nel  = E->lmesh.NEL[i];
Anisotropic_viscosity.c:325:	    E->EVI2[i][off] = 0.0;
Anisotropic_viscosity.c:326:	    E->EVIn1[i][off] = 1.0; E->EVIn2[i][off] = E->EVIn3[i][off] = 0.0;
Anisotropic_viscosity.c:327:	    E->avmode[i][off] = (unsigned char)
Anisotropic_viscosity.c:328:	      E->viscosity.allow_anisotropic_viscosity;
Anisotropic_viscosity.c:341:      if(E->parallel.me == 0)fprintf(stderr,"set_anisotropic_viscosity_at_element_level: initializing random viscosity\n");
Anisotropic_viscosity.c:343:	nel  = E->lmesh.NEL[i];
Anisotropic_viscosity.c:345:	for (m=1;m <= E->sphere.caps_per_proc;m++) {
Anisotropic_viscosity.c:361:	      E->EVI2[i][m][off] = vis2;E->EVIn1[i][m][off] = n[0]; E->EVIn2[i][m][off] = n[1];E->EVIn3[i][m][off] = n[2];
Anisotropic_viscosity.c:362:	      E->avmode[i][m][off] = (unsigned char)E->viscosity.allow_anisotropic_viscosity;
Anisotropic_viscosity.c:364:	      E->EVI2[i][off] = vis2;   E->EVIn1[i][off] = n[0];    E->EVIn2[i][off] = n[1];   E->EVIn3[i][off] = n[2];
Anisotropic_viscosity.c:365:	      E->avmode[i][off] = (unsigned char)E->viscosity.allow_anisotropic_viscosity;
Anisotropic_viscosity.c:381:      if(E->sphere.caps == 12)	/* global */
Anisotropic_viscosity.c:396:      if(E->viscosity.ani_vis2_factor >= 0){
Anisotropic_viscosity.c:397:	if(E->parallel.me == 0)
Anisotropic_viscosity.c:399:		  E->viscosity.ani_vis2_factor);
Anisotropic_viscosity.c:406:	sprintf(tfilename,"%s/vis2.grd",E->viscosity.anisotropic_init_dir);
Anisotropic_viscosity.c:407:	if(E->parallel.me == 0)
Anisotropic_viscosity.c:412:	if(E->sphere.caps == 12)	
Anisotropic_viscosity.c:420:				      vis2_grd,(E->parallel.me == 0),FALSE,
Anisotropic_viscosity.c:427:      if(E->viscosity.anivisc_layer >= 0)
Anisotropic_viscosity.c:429:      ani_layer = -E->viscosity.anivisc_layer;
Anisotropic_viscosity.c:433:      z_bottom = E->sphere.ro-E->viscosity.zbase_layer[ani_layer-1];
Anisotropic_viscosity.c:435:	z_top = E->sphere.ro;
Anisotropic_viscosity.c:437:	z_top = E->sphere.ro - E->viscosity.zbase_layer[ani_layer-2];
Anisotropic_viscosity.c:443:      z_bottom = E->viscosity.zbase_layer[ani_layer-1];
Anisotropic_viscosity.c:445:	z_top = E->segment.zzlayer[E->segment.zlayers-1];
Anisotropic_viscosity.c:447:	z_top = E->viscosity.zbase_layer[ani_layer-2];
Anisotropic_viscosity.c:451:	for(m=1;m <= E->sphere.caps_per_proc;m++){
Anisotropic_viscosity.c:453:	  elx = E->lmesh.ELX[i];elz = E->lmesh.ELZ[i];ely = E->lmesh.ELY[i];
Anisotropic_viscosity.c:457:	    if(E->mat[m][j] ==  ani_layer){
Anisotropic_viscosity.c:459:	    if(E->mat[j] ==  ani_layer){
Anisotropic_viscosity.c:463:		off = E->ien[m][j].node[inode];
Anisotropic_viscosity.c:464:		u += E->sx[m][3][off];
Anisotropic_viscosity.c:466:		off = E->ien[j].node[inode];
Anisotropic_viscosity.c:467:		if(E->control.Rsphere)
Anisotropic_viscosity.c:468:		  u += E->SX[3][off];
Anisotropic_viscosity.c:470:		  u += E->X[3][off];
Anisotropic_viscosity.c:478:		vis2 = exp(log(E->viscosity.ani_vis2_factor) * (u-z_bottom)/(z_top-z_bottom));
Anisotropic_viscosity.c:479:		//fprintf(stderr,"z %g (%g/%g) vis2 %g vis2_o %g frac %g\n",u,z_top,z_bottom,vis2, E->viscosity.ani_vis2_factor,(u-z_bottom)/(z_top-z_bottom));
Anisotropic_viscosity.c:493:		    off = E->ien[m][el].node[inode];
Anisotropic_viscosity.c:494:		    rtp2xyz((float)E->sx[m][3][off],(float)E->sx[m][1][off],(float)E->sx[m][2][off],rout);
Anisotropic_viscosity.c:519:		    E->EVI2[i][m][off] = vis2;
Anisotropic_viscosity.c:520:		    E->EVIn1[i][m][off] = n[0]; E->EVIn2[i][m][off] = n[1];E->EVIn3[i][m][off] = n[2];
Anisotropic_viscosity.c:521:		    E->avmode[i][m][off] = CITCOM_ANIVISC_ORTHO_MODE;
Anisotropic_viscosity.c:527:		  if(E->control.Rsphere){ /* director in r direction */
Anisotropic_viscosity.c:530:		      off = E->ien[el].node[inode];
Anisotropic_viscosity.c:531:		      rtp2xyz((float)E->SX[3][off],(float)E->SX[1][off],(float)E->SX[2][off],rout);
Anisotropic_viscosity.c:553:			off = E->ien[el].node[inode];
Anisotropic_viscosity.c:554:			rout[0] += E->X[1][off];rout[1] += E->X[2][off];
Anisotropic_viscosity.c:555:			rout[2] += E->X[3][off];
Anisotropic_viscosity.c:568:		    E->EVI2[i][off] = vis2;
Anisotropic_viscosity.c:569:		    E->EVIn1[i][off] = n[0]; E->EVIn2[i][off] = n[1];E->EVIn3[i][off] = n[2];
Anisotropic_viscosity.c:570:		    E->avmode[i][off] = CITCOM_ANIVISC_ORTHO_MODE;
Anisotropic_viscosity.c:582:		    E->EVI2[i][m][off] = 0;E->EVIn1[i][m][off] = 1; E->EVIn2[i][m][off] = 0;E->EVIn3[i][m][off] = 0;E->avmode[i][m][off] = CITCOM_ANIVISC_ORTHO_MODE;
Anisotropic_viscosity.c:584:		    E->EVI2[i][off] = 0;E->EVIn1[i][off] = 1; E->EVIn2[i][off] = 0;E->EVIn3[i][off] = 0;E->avmode[i][off] = CITCOM_ANIVISC_ORTHO_MODE;
Anisotropic_viscosity.c:601:	      E->viscosity.anisotropic_init);
Anisotropic_viscosity.c:605:    E->viscosity.anisotropic_viscosity_init = TRUE;
Anisotropic_viscosity.c:608:    //if(E->parallel.me == 0)fprintf(stderr,"reassigning anisotropic viscosity, mode %i\n",E->viscosity.anisotropic_init);
Anisotropic_viscosity.c:609:    if((E->monitor.solution_cycles > 0) || (E->monitor.visc_iter_count > 0)){
Anisotropic_viscosity.c:611:      switch(E->viscosity.anisotropic_init){
Anisotropic_viscosity.c:619:	if((E->monitor.solution_cycles > 0) || (E->monitor.visc_iter_count > 0))
Anisotropic_viscosity.c:623:	if((E->monitor.solution_cycles > 0) || (E->monitor.visc_iter_count > 0))
Anisotropic_viscosity.c:638:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Anisotropic_viscosity.c:639:    for(n=1;n<=E->lmesh.NNO[lev];n++){
Anisotropic_viscosity.c:646:  const int nsd=E->mesh.nsd;
Anisotropic_viscosity.c:648:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Anisotropic_viscosity.c:649:    for(e=1;e<=E->lmesh.NEL[lev];e++)
Anisotropic_viscosity.c:659:  for(n=1;n<=E->lmesh.NNO[lev];n++){
Anisotropic_viscosity.c:666:  const int nsd=E->mesh.nsd;
Anisotropic_viscosity.c:668:  for(e=1;e<=E->lmesh.NEL[lev];e++)
Anisotropic_viscosity.c:802:  const int dims = E->mesh.nsd;
Anisotropic_viscosity.c:806:  const int lev = E->mesh.levmax;
Anisotropic_viscosity.c:807:  const int nel = E->lmesh.nel;
Anisotropic_viscosity.c:811:  vis2 = 1. - E->viscosity.ani_vis2_factor; /* 1-eta_w/eta_s */
Anisotropic_viscosity.c:813:  if(E->parallel.me == 0){
Anisotropic_viscosity.c:834:    for(m=1;m <= E->sphere.caps_per_proc;m++) {
Anisotropic_viscosity.c:835:      if(((E->viscosity.anivisc_layer > 0)&&
Anisotropic_viscosity.c:836:	  (E->mat[m][e] <=   E->viscosity.anivisc_layer))||
Anisotropic_viscosity.c:837:	 ((E->viscosity.anivisc_layer < 0)&&
Anisotropic_viscosity.c:838:	  (E->mat[m][e] ==  -E->viscosity.anivisc_layer))){
Anisotropic_viscosity.c:840:	//if((e-1)%E->lmesh.elz==0)
Anisotropic_viscosity.c:841:	construct_c3x3matrix_el(E,e,&E->element_Cc,&E->element_Ccx,lev,m,1);
Anisotropic_viscosity.c:843:	  off = E->ien[m][e].node[i];
Anisotropic_viscosity.c:844:	  VV[1][i] = E->sphere.cap[m].V[1][off];
Anisotropic_viscosity.c:845:	  VV[2][i] = E->sphere.cap[m].V[2][off];
Anisotropic_viscosity.c:846:	  VV[3][i] = E->sphere.cap[m].V[3][off];
Anisotropic_viscosity.c:849:	get_vgm_p(VV,&(E->N),&(E->GNX[lev][m][e]),&E->element_Cc, 
Anisotropic_viscosity.c:850:		  &E->element_Ccx,rtf,E->mesh.nsd,ppts,ends,TRUE,lgrad,
Anisotropic_viscosity.c:863:	  E->avmode[lev][m][off] = avmode;
Anisotropic_viscosity.c:864:	  E->EVI2[lev][m][off] = vis2;
Anisotropic_viscosity.c:865:	  E->EVIn1[lev][m][off] = n[0]; 
Anisotropic_viscosity.c:866:	  E->EVIn2[lev][m][off] = n[1];
Anisotropic_viscosity.c:867:	  E->EVIn3[lev][m][off] = n[2];
Anisotropic_viscosity.c:872:    if(((E->viscosity.anivisc_layer > 0)&&
Anisotropic_viscosity.c:873:	(E->mat[e] <=   E->viscosity.anivisc_layer))||
Anisotropic_viscosity.c:874:       ((E->viscosity.anivisc_layer < 0)&&
Anisotropic_viscosity.c:875:	(E->mat[e] ==  -E->viscosity.anivisc_layer))){
Anisotropic_viscosity.c:876:      if(E->control.Rsphere){	/* need rtf for spherical */
Anisotropic_viscosity.c:878:	//if((e-1)%E->lmesh.elz==0)
Anisotropic_viscosity.c:882:	off = E->ien[e].node[i];
Anisotropic_viscosity.c:883:	VV[1][i] = E->V[1][off];
Anisotropic_viscosity.c:884:	VV[2][i] = E->V[2][off];
Anisotropic_viscosity.c:885:	VV[3][i] = E->V[3][off];
Anisotropic_viscosity.c:888:      get_vgm_p(VV,&(E->N),&(E->GNX[lev][e]),&Cc, &Ccx,rtf,
Anisotropic_viscosity.c:889:		E->mesh.nsd,ppts,ends,(E->control.Rsphere),lgrad,
Anisotropic_viscosity.c:897:      if(E->control.Rsphere){
Anisotropic_viscosity.c:906:	E->avmode[lev][off] = avmode;
Anisotropic_viscosity.c:907:	E->EVI2[lev][off] = vis2;
Anisotropic_viscosity.c:908:	E->EVIn1[lev][off] = n[0]; 
Anisotropic_viscosity.c:909:	E->EVIn2[lev][off] = n[1];
Anisotropic_viscosity.c:910:	E->EVIn3[lev][off] = n[2];
BC_util.c:54:  if(dirn > E->mesh.nsd)
BC_util.c:57:  noxnoz = E->lmesh.NOX[level]*E->lmesh.NOZ[level];
BC_util.c:63:  if((row >  E->lmesh.NOZ[level])||(row < 1))
BC_util.c:68:    for(j=1;j<=E->lmesh.NOY[level];j++)
BC_util.c:69:      for(i=1;i<=E->lmesh.NOX[level];i++)     {
BC_util.c:70:	node = row+(i-1)*E->lmesh.NOZ[level]+(j-1)*noxnoz;
BC_util.c:71:	E->NODE[level][m][node] = E->NODE[level][m][node] & (~ mask);
BC_util.c:75:    for(j=1;j<=E->lmesh.NOY[level];j++)
BC_util.c:76:      for(i=1;i<=E->lmesh.NOX[level];i++)       {
BC_util.c:77:	node = row+(i-1)*E->lmesh.NOZ[level]+(j-1)*noxnoz;
BC_util.c:78:	E->NODE[level][m][node] = E->NODE[level][m][node] | (mask);
BC_util.c:79:	if(level == E->mesh.levmax)   /* NB */
BC_util.c:96:  for (m=1;m<=E->sphere.caps_per_proc;m++)
BC_util.c:97:    if (E->num_zero_resid[level][m])
BC_util.c:98:      for(i=1;i<=E->num_zero_resid[level][m];i++)
BC_util.c:99:         Res[m][E->zero_resid[level][m][i]] = 0.0;
BC_util.c:111:  if(E->control.lith_age) {
BC_util.c:130:  for(j=1;j<=E->sphere.caps_per_proc;j++)
BC_util.c:131:    for(node=1;node<=E->lmesh.nno;node++)  {
BC_util.c:133:        type = (E->node[j][node] & (TBX | TBZ | TBY));
BC_util.c:139:            E->T[j][node] = E->sphere.cap[j].TB[1][node];
BC_util.c:142:            E->T[j][node] = E->sphere.cap[j].TB[3][node];
BC_util.c:145:            E->T[j][node] = E->sphere.cap[j].TB[2][node];
BC_util.c:148:            E->T[j][node] = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[3][node]);
BC_util.c:151:            E->T[j][node] = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node]);
BC_util.c:154:            E->T[j][node] = 0.5 * (E->sphere.cap[j].TB[3][node] + E->sphere.cap[j].TB[2][node]);
BC_util.c:157:            E->T[j][node] = 0.3333333 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node] + E->sphere.cap[j].TB[3][node]);
BC_util.c:179:    const int nno = E->lmesh.nno;
BC_util.c:181:    for(m=1;m<=E->sphere.caps_per_proc;m++)   {
BC_util.c:184:        if (E->node[m][node] & typex)
BC_util.c:185:	      U[m][E->id[m][node].doff[1]] = E->sphere.cap[m].VB[1][node];
BC_util.c:186: 	if (E->node[m][node] & typey)
BC_util.c:187:	      U[m][E->id[m][node].doff[2]] = E->sphere.cap[m].VB[2][node];
BC_util.c:188:	if (E->node[m][node] & typez)
BC_util.c:189:	      U[m][E->id[m][node].doff[3]] = E->sphere.cap[m].VB[3][node];
BC_util.c:216:  if(E->mesh.toplayerbc > 0){
BC_util.c:217:    for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--)
BC_util.c:218:      for (j=1;j<=E->sphere.caps_per_proc;j++)     {
BC_util.c:219:	noz = E->lmesh.NOZ[lv];
BC_util.c:223:	  ontop    = ((k==noz) && (E->parallel.me_loc[3]==E->parallel.nprocz-1))?(1):(0);
BC_util.c:224:	  onbottom = ((k==1) && (E->parallel.me_loc[3]==0))?(1):(0);
BC_util.c:226:	  if(E->SX[lv][j][3][k] >= E->mesh.toplayerbc_r){
BC_util.c:228:	    if((!ontop)&&(!onbottom)&&(lv==E->mesh.gridmax))
BC_util.c:230:	    if(E->mesh.topvbc != 1) {	/* free slip */
BC_util.c:231:	      internal_horizontal_bc(E,E->sphere.cap[j].VB,k,1,0.0,VBX,0,lv,j);
BC_util.c:233:		internal_horizontal_bc(E,E->sphere.cap[j].VB,k,3,0.0,VBZ,1,lv,j);
BC_util.c:234:	      internal_horizontal_bc(E,E->sphere.cap[j].VB,k,2,0.0,VBY,0,lv,j);
BC_util.c:235:	      internal_horizontal_bc(E,E->sphere.cap[j].VB,k,1,E->control.VBXtopval,SBX,1,lv,j);
BC_util.c:237:		internal_horizontal_bc(E,E->sphere.cap[j].VB,k,3,0.0,SBZ,0,lv,j);
BC_util.c:238:	      internal_horizontal_bc(E,E->sphere.cap[j].VB,k,2,E->control.VBYtopval,SBY,1,lv,j);
BC_util.c:240:	      internal_horizontal_bc(E,E->sphere.cap[j].VB,k,1,E->control.VBXtopval,VBX,1,lv,j);
BC_util.c:242:		internal_horizontal_bc(E,E->sphere.cap[j].VB,k,3,0.0,VBZ,1,lv,j);
BC_util.c:243:	      internal_horizontal_bc(E,E->sphere.cap[j].VB,k,2,E->control.VBYtopval,VBY,1,lv,j);
BC_util.c:244:	      internal_horizontal_bc(E,E->sphere.cap[j].VB,k,1,0.0,                 SBX,0,lv,j);
BC_util.c:246:		internal_horizontal_bc(E,E->sphere.cap[j].VB,k,3,0.0,SBZ,0,lv,j);
BC_util.c:247:	      internal_horizontal_bc(E,E->sphere.cap[j].VB,k,2,0.0,                 SBY,0,lv,j);
BC_util.c:254:    if(E->control.ggrd.vtop_control)
BC_util.c:258:  }else if(E->mesh.toplayerbc < 0){ 
BC_util.c:260:    for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--)
BC_util.c:261:      for (j=1;j<=E->sphere.caps_per_proc;j++)     {
BC_util.c:262:	noz = E->lmesh.NOZ[lv];
BC_util.c:265:	if(lv == E->mesh.gridmax)
BC_util.c:266:	  k = noz + E->mesh.toplayerbc;
BC_util.c:268:	  k = noz + (int)((float)E->mesh.toplayerbc / pow(2.,(float)(E->mesh.gridmax-lv)));
BC_util.c:270:	//fprintf(stderr,"BC_util: inner node: CPU: %i lv %i noz %i k %i\n",E->parallel.me,lv,noz,k);
BC_util.c:273:	ontop    = ((k==noz) && (E->parallel.me_loc[3]==E->parallel.nprocz-1))?(1):(0);
BC_util.c:274:	onbottom = ((k==1) && (E->parallel.me_loc[3]==0))?(1):(0);
BC_util.c:275:	if((!ontop)&&(!onbottom)&&(lv==E->mesh.gridmax))
BC_util.c:277:	if(E->mesh.topvbc != 1) {	/* free slip */
BC_util.c:278:	  internal_horizontal_bc(E,E->sphere.cap[j].VB,k,1,0.0,VBX,0,lv,j);
BC_util.c:280:	    internal_horizontal_bc(E,E->sphere.cap[j].VB,k,3,0.0,VBZ,1,lv,j);
BC_util.c:281:	  internal_horizontal_bc(E,E->sphere.cap[j].VB,k,2,0.0,VBY,0,lv,j);
BC_util.c:282:	  internal_horizontal_bc(E,E->sphere.cap[j].VB,k,1,E->control.VBXtopval,SBX,1,lv,j);
BC_util.c:284:	    internal_horizontal_bc(E,E->sphere.cap[j].VB,k,3,0.0,SBZ,0,lv,j);
BC_util.c:285:	  internal_horizontal_bc(E,E->sphere.cap[j].VB,k,2,E->control.VBYtopval,SBY,1,lv,j);
BC_util.c:287:	  internal_horizontal_bc(E,E->sphere.cap[j].VB,k,1,E->control.VBXtopval,VBX,1,lv,j);
BC_util.c:289:	    internal_horizontal_bc(E,E->sphere.cap[j].VB,k,3,0.0,VBZ,1,lv,j);
BC_util.c:290:	  internal_horizontal_bc(E,E->sphere.cap[j].VB,k,2,E->control.VBYtopval,VBY,1,lv,j);
BC_util.c:291:	  internal_horizontal_bc(E,E->sphere.cap[j].VB,k,1,0.0,                 SBX,0,lv,j);
BC_util.c:293:	    internal_horizontal_bc(E,E->sphere.cap[j].VB,k,3,0.0,SBZ,0,lv,j);
BC_util.c:294:	  internal_horizontal_bc(E,E->sphere.cap[j].VB,k,2,0.0,                 SBY,0,lv,j);
BC_util.c:299:    if(E->control.ggrd.vtop_control)
BC_util.c:306:	    E->parallel.me,((E->parallel.me_loc[3]==0)&&(E->parallel.nprocz!=1))?("bottom"):
BC_util.c:307:	    ((E->parallel.me_loc[3]==E->parallel.nprocz-1)?("top"):("interior")),
BC_util.c:308:	    (E->mesh.topvbc!=1)?("stress"):("velocity"),ncount);
Checkpoints.c:58:    sprintf(output_file, "%s.chkpt.%d.%d", E->control.data_file,
Checkpoints.c:59:            E->parallel.me, E->monitor.solution_cycles);
Checkpoints.c:77:    if(E->control.tracer) {
Checkpoints.c:80:        if(E->composition.on)
Checkpoints.c:98:    snprintf(output_file, 254, "%s.chkpt.%d.%d", E->control.old_P_file,
Checkpoints.c:99:             E->parallel.me, E->monitor.solution_cycles_init);
Checkpoints.c:105:    if(E->parallel.me == 0)
Checkpoints.c:111:    /* init E->mat */
Checkpoints.c:121:    if(E->control.tracer) {
Checkpoints.c:122:      if(E->trace.ic_method_for_flavors == 99){
Checkpoints.c:123:	if(E->parallel.me == 0)
Checkpoints.c:127:        if(E->composition.on)
Checkpoints.c:192:    fwrite(&(E->lmesh.nox), sizeof(int), 1, fp);
Checkpoints.c:193:    fwrite(&(E->lmesh.noy), sizeof(int), 1, fp);
Checkpoints.c:194:    fwrite(&(E->lmesh.noz), sizeof(int), 1, fp);
Checkpoints.c:195:    fwrite(&(E->parallel.nprocx), sizeof(int), 1, fp);
Checkpoints.c:196:    fwrite(&(E->parallel.nprocy), sizeof(int), 1, fp);
Checkpoints.c:197:    fwrite(&(E->parallel.nprocz), sizeof(int), 1, fp);
Checkpoints.c:198:    fwrite(&(E->sphere.caps_per_proc), sizeof(int), 1, fp);
Checkpoints.c:201:    fwrite(&(E->monitor.solution_cycles), sizeof(int), 1, fp);
Checkpoints.c:202:    fwrite(&(E->monitor.elapsed_time), sizeof(float), 1, fp);
Checkpoints.c:203:    fwrite(&(E->advection.timestep), sizeof(float), 1, fp);
Checkpoints.c:204:    fwrite(&(E->control.start_age), sizeof(float), 1, fp);
Checkpoints.c:218:    if((tmp[0] != E->lmesh.nox) ||
Checkpoints.c:219:       (tmp[1] != E->lmesh.noy) ||
Checkpoints.c:220:       (tmp[2] != E->lmesh.noz) ||
Checkpoints.c:221:       (tmp[3] != E->parallel.nprocx) ||
Checkpoints.c:222:       (tmp[4] != E->parallel.nprocy) ||
Checkpoints.c:223:       (tmp[5] != E->parallel.nprocz) ||
Checkpoints.c:224:       (tmp[6] != E->sphere.caps_per_proc)) {
Checkpoints.c:227:                E->parallel.me);
Checkpoints.c:235:    tmp[0] = fread(&(E->monitor.solution_cycles), sizeof(int), 1, fp);
Checkpoints.c:236:    tmp[0]+= fread(&(E->monitor.elapsed_time), sizeof(float), 1, fp);
Checkpoints.c:237:    tmp[0]+= fread(&(E->advection.timestep), sizeof(float), 1, fp);
Checkpoints.c:238:    tmp[0]+= fread(&(E->control.start_age), sizeof(float), 1, fp);
Checkpoints.c:242:    E->advection.timesteps = E->monitor.solution_cycles;
Checkpoints.c:254:    fwrite(&(E->trace.number_of_basic_quantities), sizeof(int), 1, fp);
Checkpoints.c:255:    fwrite(&(E->trace.number_of_extra_quantities), sizeof(int), 1, fp);
Checkpoints.c:256:    fwrite(&(E->trace.nflavors), sizeof(int), 1, fp);
Checkpoints.c:257:    fwrite(&(E->trace.ilast_tracer_count), sizeof(int), 1, fp);
Checkpoints.c:259:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Checkpoints.c:260:        fwrite(&(E->trace.ntracers[m]), sizeof(int), 1, fp);
Checkpoints.c:264:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:266:            fwrite(E->trace.basicq[m][i], sizeof(double),
Checkpoints.c:267:                   E->trace.ntracers[m]+1, fp);
Checkpoints.c:269:        for(i=0; i<E->trace.number_of_extra_quantities; i++) {
Checkpoints.c:270:            fwrite(E->trace.extraq[m][i], sizeof(double),
Checkpoints.c:271:                   E->trace.ntracers[m]+1, fp);
Checkpoints.c:273:        fwrite(E->trace.ielement[m], sizeof(int),
Checkpoints.c:274:               E->trace.ntracers[m]+1, fp);
Checkpoints.c:288:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:291:    if (itmp != E->trace.number_of_basic_quantities) {
Checkpoints.c:293:                E->parallel.me);
Checkpoints.c:300:    if (itmp != E->trace.number_of_extra_quantities) {
Checkpoints.c:302:                E->parallel.me);
Checkpoints.c:309:    if (itmp != E->trace.nflavors) {
Checkpoints.c:311:                E->parallel.me);
Checkpoints.c:318:    E->trace.ilast_tracer_count = itmp;
Checkpoints.c:321:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:324:        E->trace.ntracers[m] = itmp;
Checkpoints.c:328:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:330:            fread(E->trace.basicq[m][i], sizeof(double),
Checkpoints.c:331:                  E->trace.ntracers[m]+1, fp);
Checkpoints.c:333:        for(i=0; i<E->trace.number_of_extra_quantities; i++) {
Checkpoints.c:334:            fread(E->trace.extraq[m][i], sizeof(double),
Checkpoints.c:335:                  E->trace.ntracers[m]+1, fp);
Checkpoints.c:337:        fread(E->trace.ielement[m], sizeof(int),
Checkpoints.c:338:              E->trace.ntracers[m]+1, fp);
Checkpoints.c:341:    /* init E->trace.ntracer_flavor */
Checkpoints.c:354:    fwrite(&(E->composition.ncomp), sizeof(int), 1, fp);
Checkpoints.c:355:    fwrite(E->composition.bulk_composition, sizeof(double),
Checkpoints.c:356:           E->composition.ncomp, fp);
Checkpoints.c:357:    fwrite(E->composition.initial_bulk_composition, sizeof(double),
Checkpoints.c:358:           E->composition.ncomp, fp);
Checkpoints.c:362:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:363:        for(i=0; i<E->composition.ncomp; i++)
Checkpoints.c:364:            fwrite(E->composition.comp_el[m][i], sizeof(double),
Checkpoints.c:365:                   E->lmesh.nel+1, fp);
Checkpoints.c:377:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:380:    if (itmp != E->composition.ncomp) {
Checkpoints.c:382:                E->parallel.me);
Checkpoints.c:387:    fread(E->composition.bulk_composition, sizeof(double),
Checkpoints.c:388:          E->composition.ncomp, fp);
Checkpoints.c:390:    fread(E->composition.initial_bulk_composition, sizeof(double),
Checkpoints.c:391:          E->composition.ncomp, fp);
Checkpoints.c:393:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:394:        for(i=0; i<E->composition.ncomp; i++)
Checkpoints.c:395:            fread(E->composition.comp_el[m][i], sizeof(double),
Checkpoints.c:396:                  E->lmesh.nel+1, fp);
Checkpoints.c:399:    /* init E->composition.comp_node */
Checkpoints.c:403:    E->trace.istat_iempty = 0;
Checkpoints.c:405:    for (i=0; i<E->composition.ncomp; i++) {
Checkpoints.c:406:        E->composition.error_fraction[i] = E->composition.bulk_composition[i]
Checkpoints.c:407:        / E->composition.initial_bulk_composition[i] - 1.0;
Checkpoints.c:420:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:421:        fwrite(E->T[m], sizeof(double), E->lmesh.nno+1, fp);
Checkpoints.c:422:        fwrite(E->Tdot[m], sizeof(double), E->lmesh.nno+1, fp);
Checkpoints.c:433:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:437:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:438:      if(fread(E->T[m], sizeof(double), E->lmesh.nno+1, fp)!= E->lmesh.nno+1)
Checkpoints.c:440:      if(fread(E->Tdot[m], sizeof(double), E->lmesh.nno+1, fp)!=E->lmesh.nno+1)
Checkpoints.c:461:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:463:        fwrite(E->P[m], sizeof(double), E->lmesh.npno+1, fp);
Checkpoints.c:466:        fwrite(E->U[m], sizeof(double), E->lmesh.neq, fp);
Checkpoints.c:480:    int lev = E->mesh.levmax;
Checkpoints.c:483:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:489:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:491:      if(fread(E->P[m], sizeof(double), E->lmesh.npno+1, fp) !=  E->lmesh.npno+1)
Checkpoints.c:494:      if(fread(E->U[m], sizeof(double), E->lmesh.neq, fp) != E->lmesh.neq)
Checkpoints.c:498:    E->monitor.vdotv = global_v_norm2(E, E->U);
Checkpoints.c:499:    E->monitor.pdotp = global_p_norm2(E, E->P);
Checkpoints.c:504:    /* init E->NP */
Checkpoints.c:505:    p_to_nodes(E, E->P, E->NP, lev);
Citcom_init.c:45:  E->control.PID = get_process_identifier();
Citcom_init.c:46:  E->parallel.world = *world;
Citcom_init.c:47:  E->parallel.nproc = nproc;
Citcom_init.c:48:  E->parallel.me = rank;
Citcom_init.c:51:          rank, nproc, E, E->control.PID); */
Citcom_init.c:53:  E->monitor.solution_cycles=0;
Citcom_init.c:54:  E->control.keep_going=1;
Citcom_init.c:56:  E->control.total_iteration_cycles=0;
Citcom_init.c:57:  E->control.total_v_solver_calls=0;
Composition_related.c:47:    int m = E->parallel.me;
Composition_related.c:48:    input_boolean("CDEPV",&(E->viscosity.CDEPV),"off",m);
Composition_related.c:49:    E->composition.icompositional_rheology = E->viscosity.CDEPV;
Composition_related.c:52:		  &(E->composition.ichemical_buoyancy),
Composition_related.c:55:    if (E->control.tracer && 
Composition_related.c:56:	(E->composition.ichemical_buoyancy || 
Composition_related.c:57:	 E->composition.icompositional_rheology)) {
Composition_related.c:62:        input_int("buoy_type",&(E->composition.ibuoy_type),"1,0,nomax",m);
Composition_related.c:63:        /* if (E->composition.ibuoy_type!=1) {
Composition_related.c:69:        if (E->composition.ibuoy_type==0)
Composition_related.c:70:            E->composition.ncomp = E->trace.nflavors;
Composition_related.c:71:        else if (E->composition.ibuoy_type==1)
Composition_related.c:72:            E->composition.ncomp = E->trace.nflavors - 1;
Composition_related.c:74:        E->composition.buoyancy_ratio = (double*) malloc(E->composition.ncomp
Composition_related.c:78:        for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:79:            E->composition.buoyancy_ratio[i] = 1.0;
Composition_related.c:81:        input_double_vector("buoyancy_ratio", E->composition.ncomp,
Composition_related.c:82:                            E->composition.buoyancy_ratio,m);
Composition_related.c:96:    //E->composition.icompositional_rheology = 0;
Composition_related.c:101:              &(E->composition.icompositional_rheology),"1,0,nomax",m);
Composition_related.c:103:    if (E->composition.icompositional_rheology==1) {
Composition_related.c:105:                     &(E->composition.compositional_rheology_prefactor),
Composition_related.c:127:    if (E->composition.ichemical_buoyancy ||
Composition_related.c:128:        E->composition.icompositional_rheology)
Composition_related.c:129:        E->composition.on = 1;
Composition_related.c:131:    if (E->composition.on) {
Composition_related.c:133:        if (E->trace.nflavors < 1) {
Composition_related.c:134:            fprintf(E->trace.fpt, "Tracer flavors must be greater than 1 to track composition\n");
Composition_related.c:138:        if (!E->composition.ichemical_buoyancy)
Composition_related.c:139:	  fprintf(E->trace.fpt,"Passive Tracers\n");
Composition_related.c:141:	  fprintf(E->trace.fpt,"Active Tracers\n");
Composition_related.c:144:        if (E->composition.ibuoy_type==1)
Composition_related.c:145:	  fprintf(E->trace.fpt,"Ratio Method\n");
Composition_related.c:146:        if (E->composition.ibuoy_type==0)
Composition_related.c:147:	  fprintf(E->trace.fpt,"Absolute Method\n");
Composition_related.c:149:        for(k=0; k<E->composition.ncomp; k++) {
Composition_related.c:150:            fprintf(E->trace.fpt,"Buoyancy Ratio: %f\n", E->composition.buoyancy_ratio[k]);
Composition_related.c:154:        if (E->composition.icompositional_rheology==0) {
Composition_related.c:155:            fprintf(E->trace.fpt,"Compositional Rheology - OFF\n");
Composition_related.c:157:        else if (E->composition.icompositional_rheology>0) {
Composition_related.c:158:            fprintf(E->trace.fpt,"Compositional Rheology - ON\n");
Composition_related.c:159:            fprintf(E->trace.fpt,"Compositional Prefactor: %f\n",
Composition_related.c:160:            E->composition.compositional_rheology_prefactor);
Composition_related.c:164:        fflush(E->trace.fpt);
Composition_related.c:177:    if (E->composition.ibuoy_type==1) {
Composition_related.c:182:    if (E->composition.ibuoy_type==0) {
Composition_related.c:186:    /* if (E->composition.ibuoy_type!=1) {
Composition_related.c:187:        fprintf(E->trace.fpt,"Error(compute...)-only ratio method now\n");
Composition_related.c:188:        fflush(E->trace.fpt);
Composition_related.c:205:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:206:        E->composition.bulk_composition = (double*) malloc(E->composition.ncomp*sizeof(double));
Composition_related.c:207:        E->composition.initial_bulk_composition = (double*) malloc(E->composition.ncomp*sizeof(double));
Composition_related.c:208:        E->composition.error_fraction = (double*) malloc(E->composition.ncomp*sizeof(double));
Composition_related.c:213:    E->Have.C = (float **)malloc((E->composition.ncomp+1)*sizeof(float*));
Composition_related.c:214:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:215:        E->Have.C[i] = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Composition_related.c:221:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Composition_related.c:222:        if ((E->composition.comp_el[j]=(double **)malloc((E->composition.ncomp)*sizeof(double*)))==NULL) {
Composition_related.c:223:            fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8987y\n");
Composition_related.c:224:            fflush(E->trace.fpt);
Composition_related.c:227:        if ((E->composition.comp_node[j]=(double **)malloc((E->composition.ncomp)*sizeof(double*)))==NULL) {
Composition_related.c:228:            fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8988y\n");
Composition_related.c:229:            fflush(E->trace.fpt);
Composition_related.c:233:        for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:234:            if ((E->composition.comp_el[j][i]=(double *)malloc((E->lmesh.nel+1)*sizeof(double)))==NULL) {
Composition_related.c:235:                fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8989y\n");
Composition_related.c:236:                fflush(E->trace.fpt);
Composition_related.c:240:            if ((E->composition.comp_node[j][i]=(double *)malloc((E->lmesh.nno+1)*sizeof(double)))==NULL) {
Composition_related.c:241:                fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 983rk\n");
Composition_related.c:242:                fflush(E->trace.fpt);
Composition_related.c:256:    if (E->composition.ibuoy_type==1) {
Composition_related.c:261:    if (E->composition.ibuoy_type==0) {
Composition_related.c:265:    /* if (E->composition.ibuoy_type!=1) {
Composition_related.c:266:        fprintf(E->trace.fpt,"Error(compute...)-only ratio method now\n");
Composition_related.c:267:        fflush(E->trace.fpt);
Composition_related.c:286:    if (E->composition.ibuoy_type == 1) {
Composition_related.c:287:        if (E->trace.istat_iempty) {
Composition_related.c:312:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Composition_related.c:313:        for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:315:            for (flavor=0; flavor<E->trace.nflavors; flavor++)
Composition_related.c:316:                numtracers += E->trace.ntracer_flavor[j][flavor][e];
Composition_related.c:323:                /* fprintf(E->trace.fpt, "No tracer in element %d!\n", e); */
Composition_related.c:327:            for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:329:                E->composition.comp_el[j][i][e] =
Composition_related.c:330:                    E->trace.ntracer_flavor[j][flavor][e] / (double)numtracers;
Composition_related.c:337:            if ((1.0*iempty/E->lmesh.nel)>0.80) {
Composition_related.c:338:                fprintf(E->trace.fpt,"WARNING(compute_elemental...)-number of tracers is REALLY LOW\n");
Composition_related.c:339:                fflush(E->trace.fpt);
Composition_related.c:340:                if (E->trace.itracer_warnings) exit(10);
Composition_related.c:346:    E->trace.istat_iempty += iempty;
Composition_related.c:379:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Composition_related.c:380:        for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:382:            for (flavor=0; flavor<E->trace.nflavors; flavor++)
Composition_related.c:383:                numtracers += E->trace.ntracer_flavor[j][flavor][e];
Composition_related.c:388:                for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:389:                    E->composition.comp_el[j][i][e] = 0.0;
Composition_related.c:395:            for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:398:                    E->trace.ntracer_flavor[j][flavor][e] / E->eco[j][e].area
Composition_related.c:399:                    * domain_volume / E->trace.number_of_tracers;
Composition_related.c:404:                E->composition.comp_el[j][i][e] = min(comp,one);
Composition_related.c:427:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Composition_related.c:430:        for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:431:            for (kk=1;kk<=E->lmesh.nno;kk++)
Composition_related.c:432:                E->composition.comp_node[j][i][kk]=0.0;
Composition_related.c:436:        for (nelem=1;nelem<=E->lmesh.nel;nelem++) {
Composition_related.c:443:                n = E->ien[j][nelem].node[nodenum];
Composition_related.c:444:                for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:446:                    E->composition.comp_node[j][i][n] +=
Composition_related.c:447:                        E->composition.comp_el[j][i][nelem]*
Composition_related.c:448:                        E->TWW[E->mesh.levmax][j][nelem].node[nodenum];
Composition_related.c:455:    for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:456:        for (j=1;j<=E->sphere.caps_per_proc;j++)
Composition_related.c:457:            tmp[j] = E->composition.comp_node[j][i];
Composition_related.c:459:        (E->exchange_node_d)(E,tmp,E->mesh.levmax);
Composition_related.c:463:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Composition_related.c:464:        for(i=0;i<E->composition.ncomp;i++)
Composition_related.c:465:            for (kk=1;kk<=E->lmesh.nno;kk++)
Composition_related.c:466:                E->composition.comp_node[j][i][kk] *= E->MASS[E->mesh.levmax][j][kk];
Composition_related.c:470:        for(i=0;i<E->composition.ncomp;i++)
Composition_related.c:471:            for (kk=1;kk<=E->lmesh.nel;kk++) {
Composition_related.c:472:                fprintf(E->trace.fpt,"%d %f\n",kk,E->composition.comp_el[j][i][kk]);
Composition_related.c:475:        for(i=0;i<E->composition.ncomp;i++)
Composition_related.c:476:            for (kk=1;kk<=E->lmesh.nno;kk++) {
Composition_related.c:477:                fprintf(E->trace.fpt,"%d %f %f\n",kk,E->sx[j][3][kk],E->composition.comp_node[j][i][kk]);
Composition_related.c:479:        fflush(E->trace.fpt);
Composition_related.c:498:    fprintf(E->trace.fpt,"WARNING(check_initial_composition)-number of tracers is low, %d elements contain no tracer initially\n", E->trace.istat_iempty);
Composition_related.c:500:    fprintf(E->trace.fpt,"Using neighboring elements for initial composition...\n");
Composition_related.c:503:    nghbrs[0] = E->lmesh.elz;
Composition_related.c:504:    nghbrs[1] = -E->lmesh.elz;
Composition_related.c:505:    nghbrs[2] = E->lmesh.elz * E->lmesh.elx;
Composition_related.c:506:    nghbrs[3] = -E->lmesh.elz * E->lmesh.elx;
Composition_related.c:508:    is_empty = (int *)calloc(E->lmesh.nel+1, sizeof(int));
Composition_related.c:509:    sum = (double *)malloc(E->composition.ncomp * sizeof(double));
Composition_related.c:511:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Composition_related.c:513:        for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:515:            for (flavor=0; flavor<E->trace.nflavors; flavor++)
Composition_related.c:516:                numtracers += E->trace.ntracer_flavor[j][flavor][e];
Composition_related.c:523:        for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:526:                for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:532:                    if((ee>0) && (ee<=E->lmesh.nel) && (!is_empty[ee])) {
Composition_related.c:534:                        for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:535:                            sum[i] += E->composition.comp_el[j][i][ee];
Composition_related.c:540:                    fprintf(E->trace.fpt,"Error(fill_composition_from_neighbors)-all neighboring elements are empty\n");
Composition_related.c:541:                    fflush(E->trace.fpt);
Composition_related.c:545:                for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:546:                    E->composition.comp_el[j][i][e] = sum[i] / count;
Composition_related.c:554:    fprintf(E->trace.fpt,"Done.\n");
Composition_related.c:555:    fflush(E->trace.fpt);
Composition_related.c:572:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:574:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Composition_related.c:575:            tmp[m] = E->composition.comp_node[m][i];
Composition_related.c:580:        E->composition.bulk_composition[i] = volume;
Composition_related.c:581:        E->composition.initial_bulk_composition[i] = volume;
Composition_related.c:597:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:599:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Composition_related.c:600:            tmp[m] = E->composition.comp_node[m][i];
Composition_related.c:605:        E->composition.bulk_composition[i] = volume;
Composition_related.c:607:        E->composition.error_fraction[i] = (volume - E->composition.initial_bulk_composition[i]) / E->composition.initial_bulk_composition[i];
Construct_arrays.c:53:  const int dims=E->mesh.nsd;
Construct_arrays.c:56:  for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:57:    for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Construct_arrays.c:59:      elx = E->lmesh.ELX[lev];
Construct_arrays.c:60:      elz = E->lmesh.ELZ[lev];
Construct_arrays.c:61:      ely = E->lmesh.ELY[lev];
Construct_arrays.c:62:      nox = E->lmesh.NOX[lev];
Construct_arrays.c:63:      noz = E->lmesh.NOZ[lev];
Construct_arrays.c:64:      noy = E->lmesh.NOY[lev];
Construct_arrays.c:65:      nel=E->lmesh.NEL[lev];
Construct_arrays.c:66:      nno=E->lmesh.NNO[lev];
Construct_arrays.c:74:               E->IEN[lev][j][element].node[rr]= start
Construct_arrays.c:84:/* if(E->control.verbose)  { */
Construct_arrays.c:85:/*   for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  { */
Construct_arrays.c:86:/*     fprintf(E->fp_out,"output_IEN_arrays me=%d lev=%d \n",E->parallel.me,lev); */
Construct_arrays.c:87:/*   for (j=1;j<=E->sphere.caps_per_proc;j++) { */
Construct_arrays.c:88:/*     fprintf(E->fp_out,"output_IEN_arrays me=%d %d %d\n",E->parallel.me,j,E->sphere.capid[j]); */
Construct_arrays.c:89:/*     for (i=1;i<=E->lmesh.NEL[lev];i++) */
Construct_arrays.c:90:/*        fprintf(E->fp_out,"%d %d %d %d %d %d %d %d %d\n",i,E->IEN[lev][j][i].node[1],E->IEN[lev][j][i].node[2],E->IEN[lev][j][i].node[3],E->IEN[lev][j][i].node[4],E->IEN[lev][j][i].node[5],E->IEN[lev][j][i].node[6],E->IEN[lev][j][i].node[7],E->IEN[lev][j][i].node[8]); */
Construct_arrays.c:93:/*   fflush (E->fp_out); */
Construct_arrays.c:106:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Construct_arrays.c:108:    for(element=1;element<=E->lmesh.nel;element++)
Construct_arrays.c:109:      if ( element%E->lmesh.elz==0) { /* top */
Construct_arrays.c:111:        E->sien[j][e].node[1] = E->ien[j][element].node[5]/E->lmesh.noz;
Construct_arrays.c:112:        E->sien[j][e].node[2] = E->ien[j][element].node[6]/E->lmesh.noz;
Construct_arrays.c:113:        E->sien[j][e].node[3] = E->ien[j][element].node[7]/E->lmesh.noz;
Construct_arrays.c:114:        E->sien[j][e].node[4] = E->ien[j][element].node[8]/E->lmesh.noz;
Construct_arrays.c:115:        E->surf_element[j][e] = element;
Construct_arrays.c:118:    E->lmesh.snel = e;
Construct_arrays.c:119:    for (i=1;i<=E->lmesh.nsf;i++)
Construct_arrays.c:120:      E->surf_node[j][i] = i*E->lmesh.noz;
Construct_arrays.c:124:  if(E->control.verbose) {
Construct_arrays.c:125:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Construct_arrays.c:126:      for(e=1;e<=E->lmesh.snel;e++) {
Construct_arrays.c:127:        fprintf(E->fp_out, "sien sel=%d node=%d %d %d %d\n",
Construct_arrays.c:128:		e, E->sien[j][e].node[1], E->sien[j][e].node[2], E->sien[j][e].node[3], E->sien[j][e].node[4]);
Construct_arrays.c:149:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:152:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)  {
Construct_arrays.c:153:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Construct_arrays.c:156:      for(node=1;node<=E->lmesh.NNO[lev];node++)
Construct_arrays.c:158:          E->ID[lev][j][node].doff[doff] = eqn_count;
Construct_arrays.c:162:      E->lmesh.NEQ[lev] = eqn_count;
Construct_arrays.c:165:      for(node=1;node<=E->lmesh.NNO[lev];node++) {
Construct_arrays.c:166:        if (E->NODE[lev][j][node] & SKIP)
Construct_arrays.c:169:          E->parallel.Skip_id[lev][j][i] = E->ID[lev][j][node].doff[doff];
Construct_arrays.c:173:      E->parallel.Skip_neq[lev][j] = i;
Construct_arrays.c:176:      neq = E->lmesh.NEQ[lev] - E->parallel.Skip_neq[lev][j];
Construct_arrays.c:177:      MPI_Allreduce(&neq, &gneq, 1, MPI_INT, MPI_SUM, E->parallel.world);
Construct_arrays.c:178:      E->mesh.NEQ[lev] = gneq;
Construct_arrays.c:185:    E->lmesh.neq = E->lmesh.NEQ[E->mesh.levmax];
Construct_arrays.c:186:    E->mesh.neq = E->mesh.NEQ[E->mesh.levmax];
Construct_arrays.c:188:/*     if (E->control.verbose) { */
Construct_arrays.c:189:/*       fprintf(E->fp_out,"output_ID_arrays \n"); */
Construct_arrays.c:190:/*       for(j=1;j<=E->sphere.caps_per_proc;j++)    */
Construct_arrays.c:191:/*         for (i=1;i<=E->lmesh.nno;i++) */
Construct_arrays.c:192:/*           fprintf(E->fp_out,"%d %d %d %d %d\n",eqn_count,i,E->ID[lev][j][i].doff[1],E->ID[lev][j][i].doff[2],E->ID[lev][j][i].doff[3]); */
Construct_arrays.c:193:/*       fflush(E->fp_out); */
Construct_arrays.c:209:    const int nno=E->lmesh.NNO[level];
Construct_arrays.c:213:      if ( (E->NODE[level][m][i] & VBX) != 0 )  {
Construct_arrays.c:215:        E->zero_resid[level][m][j] = E->ID[level][m][i].doff[1];
Construct_arrays.c:217:      if ( (E->NODE[level][m][i] & VBY) != 0 )  {
Construct_arrays.c:219:        E->zero_resid[level][m][j] = E->ID[level][m][i].doff[2];
Construct_arrays.c:221:      if ( (E->NODE[level][m][i] & VBZ) != 0 )  {
Construct_arrays.c:223:        E->zero_resid[level][m][j] = E->ID[level][m][i].doff[3];
Construct_arrays.c:227:    E->num_zero_resid[level][m] = j;
Construct_arrays.c:243:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:262:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:267:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Construct_arrays.c:268:    for (m=1;m<=E->sphere.caps_per_proc;m++)             {
Construct_arrays.c:269:       neq=E->lmesh.NEQ[lev];
Construct_arrays.c:270:       nno=E->lmesh.NNO[lev];
Construct_arrays.c:271:       noxz = E->lmesh.NOX[lev]*E->lmesh.NOZ[lev];
Construct_arrays.c:272:       noz = E->lmesh.NOZ[lev];
Construct_arrays.c:273:       noy = E->lmesh.NOY[lev];
Construct_arrays.c:274:       nox = E->lmesh.NOX[lev];
Construct_arrays.c:278:       E->Node_map[lev][m]=(int *) malloc (matrix*sizeof(int));
Construct_arrays.c:281:	   E->Node_map[lev][m][i] = neq;  /* neq indicates an invalid eqn # */
Construct_arrays.c:288:	   E->Node_map[lev][m][(nn-1)*max_eqn+doff-1] = E->ID[lev][m][nn].doff[doff];
Construct_arrays.c:307:                   E->Node_map[lev][m][(nn-1)*max_eqn+ia*dims+doff-1]=E->ID[lev][m][ja].doff[doff];
Construct_arrays.c:312:       E->Eqn_k1[lev][m] = (higher_precision *)malloc(matrix*sizeof(higher_precision));
Construct_arrays.c:313:       E->Eqn_k2[lev][m] = (higher_precision *)malloc(matrix*sizeof(higher_precision));
Construct_arrays.c:314:       E->Eqn_k3[lev][m] = (higher_precision *)malloc(matrix*sizeof(higher_precision));
Construct_arrays.c:316:       E->mesh.matrix_size[lev] = matrix;
Construct_arrays.c:318:       if(E->control.verbose) {
Construct_arrays.c:319:           fprintf(E->fp_out, "output Node_map lev=%d m=%d\n", lev, m);
Construct_arrays.c:320:           fprintf(E->fp_out, "neq=%d nno=%d max_eqn=%d matrix=%d\n", neq, nno, max_eqn, matrix);
Construct_arrays.c:322:               fprintf(E->fp_out, "%d %d\n", i, E->Node_map[lev][m][i]);
Construct_arrays.c:348:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:350:    const int lms=loc_mat_size[E->mesh.nsd];
Construct_arrays.c:355:   for(level=E->mesh.gridmax;level>=E->mesh.gridmin;level--)   {
Construct_arrays.c:357:      for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Construct_arrays.c:359:        neq=E->lmesh.NEQ[level];
Construct_arrays.c:360:        nel=E->lmesh.NEL[level];
Construct_arrays.c:361:        nno=E->lmesh.NNO[level];
Construct_arrays.c:363:	    E->BI[level][m][i] = zero;
Construct_arrays.c:364:        for(i=0;i<E->mesh.matrix_size[level];i++) {
Construct_arrays.c:365:            E->Eqn_k1[level][m][i] = zero;
Construct_arrays.c:366:            E->Eqn_k2[level][m][i] = zero;
Construct_arrays.c:367:            E->Eqn_k3[level][m][i] = zero;
Construct_arrays.c:374:	    if (E->control.augmented_Lagr)
Construct_arrays.c:380:	       node=E->IEN[level][m][element].node[i];
Construct_arrays.c:387:	       if(E->NODE[level][m][node] & VBX) w1=0.0;
Construct_arrays.c:388:	       if(E->NODE[level][m][node] & VBZ) w3=0.0;
Construct_arrays.c:389:	       if(E->NODE[level][m][node] & VBY) w2=0.0;
Construct_arrays.c:392:	         node1=E->IEN[level][m][element].node[j];
Construct_arrays.c:399:		    eqn1=E->ID[level][m][node1].doff[1];
Construct_arrays.c:400:		    eqn2=E->ID[level][m][node1].doff[2];
Construct_arrays.c:401:		    eqn3=E->ID[level][m][node1].doff[3];
Construct_arrays.c:403:		    if(E->NODE[level][m][node1] & VBX) ww1=0.0;
Construct_arrays.c:404:		    if(E->NODE[level][m][node1] & VBZ) ww3=0.0;
Construct_arrays.c:405:		    if(E->NODE[level][m][node1] & VBY) ww2=0.0;
Construct_arrays.c:411:		      if(E->Node_map[level][m][loc0+k] == eqn1) { /* found, index next equation */
Construct_arrays.c:419:		    E->Eqn_k1[level][m][loc0+index] +=  w1*ww1*elt_K[pp*lms+qq]; /* direction 1 */
Construct_arrays.c:420:		    E->Eqn_k2[level][m][loc0+index] +=  w2*ww1*elt_K[(pp+1)*lms+qq]; /* direction 1 */
Construct_arrays.c:421:		    E->Eqn_k3[level][m][loc0+index] +=  w3*ww1*elt_K[(pp+2)*lms+qq]; /* direction 1 */
Construct_arrays.c:427:			if(E->Node_map[level][m][loc0+k] == eqn2) { /* found, index next equation */
Construct_arrays.c:435:		    E->Eqn_k1[level][m][loc0+index] += w1*ww2*elt_K[pp*lms+qq+1]; /* direction 1 */
Construct_arrays.c:436:		    E->Eqn_k2[level][m][loc0+index] += w2*ww2*elt_K[(pp+1)*lms+qq+1]; /* direction 2 */
Construct_arrays.c:437:		    E->Eqn_k3[level][m][loc0+index] += w3*ww2*elt_K[(pp+2)*lms+qq+1]; /* direction 3 */
Construct_arrays.c:443:		    if(E->Node_map[level][m][loc0+k] == eqn3) { /* found, index next equation */
Construct_arrays.c:451:		    E->Eqn_k1[level][m][loc0+index] += w1*ww3*elt_K[pp*lms+qq+2]; /* direction 1 */
Construct_arrays.c:452:                    E->Eqn_k2[level][m][loc0+index] += w2*ww3*elt_K[(pp+1)*lms+qq+2]; /* direction 2 */
Construct_arrays.c:453:		    E->Eqn_k3[level][m][loc0+index] += w3*ww3*elt_K[(pp+2)*lms+qq+2]; /* direction 3 */
Construct_arrays.c:461:     (E->solver.exchange_id_d)(E, E->BI[level], level);
Construct_arrays.c:463:     for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Construct_arrays.c:464:        neq=E->lmesh.NEQ[level];
Construct_arrays.c:467:            if(E->BI[level][m][j] ==0.0)  fprintf(stderr,"me= %d level %d, equation %d/%d has zero diagonal term\n",E->parallel.me,level,j,neq);
Construct_arrays.c:468:	    assert( E->BI[level][m][j] != 0 /* diagonal of matrix = 0, not acceptable */);
Construct_arrays.c:469:            E->BI[level][m][j]  = (double) 1.0/E->BI[level][m][j];
Construct_arrays.c:488:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:492:   for(level=E->mesh.gridmax;level>=E->mesh.gridmin;level--)   {
Construct_arrays.c:493:     for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Construct_arrays.c:494:        for(j=0;j<=E->lmesh.NEQ[level];j++)
Construct_arrays.c:495:            E->temp[m][j]=0.0;
Construct_arrays.c:497:        for(i=1;i<=E->lmesh.NNO[level];i++)  {
Construct_arrays.c:498:            eqn1=E->ID[level][m][i].doff[1];
Construct_arrays.c:499:            eqn2=E->ID[level][m][i].doff[2];
Construct_arrays.c:500:            eqn3=E->ID[level][m][i].doff[3];
Construct_arrays.c:502:            C=E->Node_map[level][m] + (i-1)*max_eqn;
Construct_arrays.c:503:            B1=E->Eqn_k1[level][m]+(i-1)*max_eqn;
Construct_arrays.c:504:            B2=E->Eqn_k2[level][m]+(i-1)*max_eqn;
Construct_arrays.c:505:            B3=E->Eqn_k3[level][m]+(i-1)*max_eqn;
Construct_arrays.c:508:                E->temp[m][eqn1] += fabs(B1[j]);
Construct_arrays.c:509:                E->temp[m][eqn2] += fabs(B2[j]);
Construct_arrays.c:510:                E->temp[m][eqn3] += fabs(B3[j]);
Construct_arrays.c:514:                E->temp[m][C[j]] += fabs(B1[j]) + fabs(B2[j]) + fabs(B3[j]);
Construct_arrays.c:519:     (E->solver.exchange_id_d)(E, E->temp, level);
Construct_arrays.c:521:     for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Construct_arrays.c:522:        for(i=0;i<E->lmesh.NEQ[level];i++)  {
Construct_arrays.c:523:            E->temp[m][i] = E->temp[m][i] - 1.0/E->BI[level][m][i];
Construct_arrays.c:525:        for(i=1;i<=E->lmesh.NNO[level];i++)
Construct_arrays.c:526:          if (E->NODE[level][m][i] & OFFSIDE)   {
Construct_arrays.c:527:            eqn1=E->ID[level][m][i].doff[1];
Construct_arrays.c:528:            eqn2=E->ID[level][m][i].doff[2];
Construct_arrays.c:529:            eqn3=E->ID[level][m][i].doff[3];
Construct_arrays.c:530:            E->BI[level][m][eqn1] = (double) 1.0/E->temp[m][eqn1];
Construct_arrays.c:531:            E->BI[level][m][eqn2] = (double) 1.0/E->temp[m][eqn2];
Construct_arrays.c:532:            E->BI[level][m][eqn3] = (double) 1.0/E->temp[m][eqn3];
Construct_arrays.c:554:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Construct_arrays.c:555:    for (j=1;j<=E->sphere.caps_per_proc;j++)           {
Construct_arrays.c:556:      elz = E->lmesh.ELZ[lev];
Construct_arrays.c:557:      ely = E->lmesh.ELY[lev];
Construct_arrays.c:558:      noy = E->lmesh.NOY[lev];
Construct_arrays.c:559:      noz = E->lmesh.NOZ[lev];
Construct_arrays.c:560:      nno = E->lmesh.NNO[lev];
Construct_arrays.c:562:        if (E->parallel.me_loc[3]==0 )
Construct_arrays.c:563:          for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[5];i++)   {
Construct_arrays.c:564:            node = E->parallel.NODE[lev][j][i].bound[5];
Construct_arrays.c:565: 	    E->NODE[lev][j][node] = E->NODE[lev][j][node] | TZEDGE;
Construct_arrays.c:567:        if ( E->parallel.me_loc[3]==E->parallel.nprocz-1 )
Construct_arrays.c:568:          for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[6];i++)   {
Construct_arrays.c:569:  	    node = E->parallel.NODE[lev][j][i].bound[6];
Construct_arrays.c:570:	    E->NODE[lev][j][node] = E->NODE[lev][j][node] | TZEDGE;
Construct_arrays.c:575:/*   if (E->control.verbose) { */
Construct_arrays.c:576:/*     for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)  */
Construct_arrays.c:577:/*       for (j=1;j<=E->sphere.caps_per_proc;j++)           { */
Construct_arrays.c:578:/*         for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[5];i++)   {  */
Construct_arrays.c:579:/* 	  node = E->parallel.NODE[lev][j][i].bound[5]; */
Construct_arrays.c:580:/* 	  fprintf(E->fp_out,"bound=5  NODE[lev=%1d][node=%3d]=%d\n",lev,node,E->NODE[lev][j][node]); */
Construct_arrays.c:582:/*         for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[6];i++)   {  */
Construct_arrays.c:583:/* 	  node = E->parallel.NODE[lev][j][i].bound[6]; */
Construct_arrays.c:584:/* 	  fprintf(E->fp_out,"bound=6  NODE[lev=%1d][node=%3d]=%d\n",lev,node,E->NODE[lev][j][node]); */
Construct_arrays.c:587:/*     fflush(E->fp_out); */
Construct_arrays.c:605:  for(lev=E->mesh.levmax-1;lev>=E->mesh.levmin;lev--)
Construct_arrays.c:606:     for (m=1;m<=E->sphere.caps_per_proc;m++)       {
Construct_arrays.c:607:          elx = E->lmesh.ELX[lev];
Construct_arrays.c:608:	  elz = E->lmesh.ELZ[lev];
Construct_arrays.c:609:	  ely = E->lmesh.ELY[lev];
Construct_arrays.c:610:          nox = E->lmesh.NOX[lev];
Construct_arrays.c:611:          noy = E->lmesh.NOY[lev];
Construct_arrays.c:612:          noz = E->lmesh.NOZ[lev];
Construct_arrays.c:613:	  elz = E->lmesh.ELZ[lev];
Construct_arrays.c:614:	  ely = E->lmesh.ELY[lev];
Construct_arrays.c:617:          if (!E->control.NMULTIGRID)  {
Construct_arrays.c:619:             if (lev == E->mesh.levmax-1)
Construct_arrays.c:620:                 elzu = E->lmesh.ELZ[E->mesh.levmax];
Construct_arrays.c:629:		  for(l=1;l<=enodes[E->mesh.nsd];l++)   {
Construct_arrays.c:630:		      E->EL[lev][m][elt].sub[l] = eltu
Construct_arrays.c:652:    const int dims=E->mesh.nsd;
Construct_arrays.c:653:    const int n=loc_mat_size[E->mesh.nsd];
Construct_arrays.c:655:/*     if(E->parallel.me==0) */
Construct_arrays.c:658:    for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Construct_arrays.c:660:      for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Construct_arrays.c:662:	for(el=1;el<=E->lmesh.NEL[lev];el++)    {
Construct_arrays.c:664:	    get_elt_k(E,el,E->elt_k[lev][m][el].k,lev,m,0);
Construct_arrays.c:666:	    if (E->control.augmented_Lagr)
Construct_arrays.c:667:	        get_aug_k(E,el,E->elt_k[lev][m][el].k,lev,m);
Construct_arrays.c:669:            build_diagonal_of_K(E,el,E->elt_k[lev][m][el].k,lev,m);
Construct_arrays.c:674:      (E->solver.exchange_id_d)(E, E->BI[lev], lev);    /*correct BI   */
Construct_arrays.c:676:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Construct_arrays.c:678:            for(j=0;j<E->lmesh.NEQ[lev];j++) {
Construct_arrays.c:679:	       if(E->BI[lev][m][j] ==0.0)  fprintf(stderr,"me= %d level %d, equation %d/%d has zero diagonal term\n",E->parallel.me,lev,j,E->lmesh.NEQ[lev]);
Construct_arrays.c:680:               assert( E->BI[lev][m][j] != 0 /* diagonal of matrix = 0, not acceptable */);
Construct_arrays.c:681:               E->BI[lev][m][j]  = (double) 1.0/E->BI[lev][m][j];
Construct_arrays.c:696:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:699:/*   if(E->control.verbose && E->parallel.me==0) */
Construct_arrays.c:702:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Construct_arrays.c:703:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Construct_arrays.c:704:      for(el=1;el<=E->lmesh.NEL[lev];el++)
Construct_arrays.c:705:        get_elt_g(E,el,E->elt_del[lev][m][el].g,lev,m);
Construct_arrays.c:722:/*     if(E->control.verbose && E->parallel.me==0) */
Construct_arrays.c:725:    for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Construct_arrays.c:726:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Construct_arrays.c:727:            for(el=1;el<=E->lmesh.NEL[lev];el++) {
Construct_arrays.c:728:                get_elt_c(E,el,E->elt_c[lev][m][el].c,lev,m);
Construct_arrays.c:751:  if (E->control.NMULTIGRID)
Construct_arrays.c:754:  if (E->control.NMULTIGRID || E->control.NASSEMBLE) {
Construct_arrays.c:763:  if (E->control.NMULTIGRID || (E->control.NASSEMBLE && !E->control.CONJ_GRAD))
Construct_arrays.c:777:if E->viscosity.z... set to Earth values, and old, num_mat=4 style is
Construct_arrays.c:795:  rl = r + E->sphere.ro;
Construct_arrays.c:797:  for(i = 0;i < E->viscosity.num_mat;i++)
Construct_arrays.c:798:    if(r > (E->sphere.ro - E->viscosity.zbase_layer[i])){
Construct_arrays.c:810:  return(layers_r(E,E->sx[m][3][node]));
Construct_arrays.c:827:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:830:  if(E->viscosity.layer_control) {
Construct_arrays.c:834:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Construct_arrays.c:835:          for(el=1;el<=E->lmesh.nel;el++) {
Construct_arrays.c:837:              nz = ((el-1) % E->lmesh.elz) + 1;
Construct_arrays.c:838:              E->mat[m][el] = E->mesh.elz - (nz + E->lmesh.ezs) + 1;
Construct_arrays.c:841:      for (m=1;m<=E->sphere.caps_per_proc;m++) {
Construct_arrays.c:842:          for(el=1;el<=E->lmesh.nel;el++) {
Construct_arrays.c:843:              E->mat[m][el] = 1;
Construct_arrays.c:844:              nodea = E->ien[m][el].node[2];
Construct_arrays.c:847:                  E->mat[m][el] = llayer;
Convection.c:47:    E->control.CONVECTION = 1;
Convection.c:49:    E->advection.timestep = 0.0;
Convection.c:50:    E->advection.timesteps = 0;
Convection.c:51:    E->advection.temp_iterations = 2; /* petrov-galerkin iterations: minimum value. */
Convection.c:52:    E->advection.total_timesteps = 1;
Convection.c:53:    E->advection.sub_iterations = 1;
Convection.c:54:    E->advection.last_sub_iterations = 1;
Convection.c:55:    E->advection.gamma = 0.5;
Convection.c:56:    E->advection.dt_reduced = 1.0;
Convection.c:58:    E->monitor.T_maxvaried = 1.05;
Convection.c:60:    E->next_buoyancy_field = PG_timestep;
Convection.c:61:    E->next_buoyancy_field_init = PG_timestep_init;
Convection.c:62:    E->special_process_new_buoyancy = twiddle_thumbs;
Convection.c:63:    E->problem_settings = read_convection_settings;
Convection.c:64:    E->problem_derived_values = convection_derived_values;
Convection.c:65:    E->problem_allocate_vars = convection_allocate_memory;
Convection.c:66:    E->problem_boundary_conds = convection_boundary_conditions;
Convection.c:67:    E->problem_initial_fields = convection_initial_fields;
Convection.c:68:    E->problem_update_node_positions = twiddle_thumbs;
Convection.c:69:    E->problem_update_bcs = twiddle_thumbs;
Convection.c:127:    (E->solver.velocity_boundary_conditions)(E);      /* universal */
Convection.c:128:    (E->solver.temperature_boundary_conditions)(E);
Determine_net_rotation.c:70:  const int dims = E->mesh.nsd;
Determine_net_rotation.c:79:  elz = E->lmesh.elz;elx = E->lmesh.elx;ely = E->lmesh.ely;
Determine_net_rotation.c:96:    for (m=1;m <= E->sphere.caps_per_proc;m++)
Determine_net_rotation.c:106:          lnode[1] = E->ien[m][el].node[1];
Determine_net_rotation.c:107:          lnode[2] = E->ien[m][el].node[2];
Determine_net_rotation.c:108:          lnode[3] = E->ien[m][el].node[3];
Determine_net_rotation.c:109:          lnode[4] = E->ien[m][el].node[4];
Determine_net_rotation.c:111:          for(nint=1;nint <= onedvpoints[E->mesh.nsd];nint++)   {
Determine_net_rotation.c:112:            for(d=1;d <= onedvpoints[E->mesh.nsd];d++){
Determine_net_rotation.c:113:	      vtmp = E->M.vpt[GMVINDEX(d,nint)] * dGamma.vpt[GMVGAMMA(0,nint)];
Determine_net_rotation.c:114:	      x[0] += E->x[m][1][lnode[d]] * vtmp; /* coords */
Determine_net_rotation.c:115:	      x[1] += E->x[m][2][lnode[d]] * vtmp;
Determine_net_rotation.c:116:	      x[2] += E->x[m][3][lnode[d]] * vtmp;
Determine_net_rotation.c:118:              v[0] += E->sphere.cap[m].V[1][lnode[d]] * vtmp; /* theta */
Determine_net_rotation.c:119:              v[1] += E->sphere.cap[m].V[2][lnode[d]] * vtmp; /* phi */
Determine_net_rotation.c:124:            lnode[1] = E->ien[m][el].node[5];
Determine_net_rotation.c:125:            lnode[2] = E->ien[m][el].node[6];
Determine_net_rotation.c:126:            lnode[3] = E->ien[m][el].node[7];
Determine_net_rotation.c:127:            lnode[4] = E->ien[m][el].node[8];
Determine_net_rotation.c:129:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Determine_net_rotation.c:130:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++){
Determine_net_rotation.c:131:		vtmp = E->M.vpt[GMVINDEX(d,nint)] * dGamma.vpt[GMVGAMMA(1,nint)];
Determine_net_rotation.c:132:		x[0] += E->x[m][1][lnode[d]] * vtmp; /* coords */
Determine_net_rotation.c:133:		x[1] += E->x[m][2][lnode[d]] * vtmp;
Determine_net_rotation.c:134:		x[2] += E->x[m][3][lnode[d]] * vtmp;
Determine_net_rotation.c:136:		v[0] += E->sphere.cap[m].V[1][lnode[d]] * vtmp;
Determine_net_rotation.c:137:		v[1] += E->sphere.cap[m].V[2][lnode[d]] * vtmp;
Determine_net_rotation.c:153:  MPI_Allreduce(coef,acoef,elz9,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Determine_net_rotation.c:158:  rr = E->sx[1][3][E->ien[1][elz].node[5]] - E->sx[1][3][E->ien[1][1].node[1]];
Determine_net_rotation.c:165:    r1 = E->sx[1][3][E->ien[1][i+1].node[1]]; /* nodal radii for the
Determine_net_rotation.c:171:    r2 = E->sx[1][3][E->ien[1][i+1].node[5]];
Determine_net_rotation.c:173:    //if(E->parallel.me == 0)
Determine_net_rotation.c:193:  if(E->parallel.me == 0)
Determine_net_rotation.c:351://   ADDED BY -OrbData-, AND NODE-VELOCITY OUTPUT FROM -SHELLS-,
Drive_solvers.c:47:  if (E->control.NMULTIGRID || E->control.NASSEMBLE)
Drive_solvers.c:50:    for (i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)
Drive_solvers.c:51:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Drive_solvers.c:52:	E->elt_k[i][m]=(struct EK *)malloc((E->lmesh.NEL[i]+1)*sizeof(struct EK));
Drive_solvers.c:75:  const int neq = E->lmesh.neq;
Drive_solvers.c:77:  E->monitor.visc_iter_count = 0; /* first solution */
Drive_solvers.c:79:  velocities_conform_bcs(E,E->U);
Drive_solvers.c:83:    get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:93:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Drive_solvers.c:102:    E->monitor.visc_iter_count++;
Drive_solvers.c:106:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Drive_solvers.c:108:	  delta_U[m][i] = E->U[m][i] - oldU[m][i];
Drive_solvers.c:109:	  oldU[m][i] = E->U[m][i];
Drive_solvers.c:112:      Udot_mag  = sqrt(global_vdot(E,oldU,oldU,E->mesh.levmax));
Drive_solvers.c:113:      dUdot_mag = vnorm_nonnewt(E,delta_U,oldU,E->mesh.levmax);
Drive_solvers.c:116:      if(E->parallel.me==0){
Drive_solvers.c:118:		dUdot_mag,Udot_mag,E->monitor.visc_iter_count);
Drive_solvers.c:119:	fprintf(E->fp,"Stress dep. visc./plast.: DUdot = %.4e (%.4e) for iteration %d\n",
Drive_solvers.c:120:		dUdot_mag,Udot_mag,E->monitor.visc_iter_count);
Drive_solvers.c:121:	fflush(E->fp);
Drive_solvers.c:123:      if ((E->monitor.visc_iter_count > 50) || 
Drive_solvers.c:124:	  (dUdot_mag < E->viscosity.sdepv_misfit))
Drive_solvers.c:127:      get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:131:      E->monitor.visc_iter_count++;
Drive_solvers.c:135:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Drive_solvers.c:143:  if((E->sphere.caps == 12) &&
Drive_solvers.c:144:     (E->control.remove_rigid_rotation || E->control.remove_angular_momentum)) {
Drive_solvers.c:153:  if(E->viscosity.update_allowed){
Drive_solvers.c:158:    if(E->control.restart){	
Drive_solvers.c:161:      if(E->monitor.solution_cycles ==  E->monitor.solution_cycles_init + 1)
Drive_solvers.c:167:      if(E->monitor.solution_cycles == 0)
Drive_solvers.c:175:  if((E->control.force_iteration) && (E->monitor.solution_cycles == 0)){
Drive_solvers.c:180:  if(E->viscosity.allow_anisotropic_viscosity){
Drive_solvers.c:181:    if(E->viscosity.anivisc_start_from_iso) /* first step will be
Drive_solvers.c:186:      return (E->viscosity.SDEPV || E->viscosity.PDEPV)?(1):(0);
Drive_solvers.c:190:  return ((E->viscosity.SDEPV || E->viscosity.PDEPV)?(1):(0));
Drive_solvers.c:212:  const int neq = E->lmesh.neq;
Drive_solvers.c:214:  velocities_conform_bcs(E,E->U);
Drive_solvers.c:216:  E->monitor.stop_topo_loop = 0;
Drive_solvers.c:217:  E->monitor.topo_loop = 0;
Drive_solvers.c:218:  if(E->monitor.solution_cycles==0) std_timestep(E);
Drive_solvers.c:219:  while(E->monitor.stop_topo_loop == 0) {
Drive_solvers.c:222:	    get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:227:	  if (E->viscosity.SDEPV || E->viscosity.PDEPV) {
Drive_solvers.c:229:		  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Drive_solvers.c:241:			  for (m=1;m<=E->sphere.caps_per_proc;m++)
Drive_solvers.c:243:					  delta_U[m][i] = E->U[m][i] - oldU[m][i];
Drive_solvers.c:244:					  oldU[m][i] = E->U[m][i];
Drive_solvers.c:247:			  Udot_mag  = sqrt(global_vdot(E,oldU,oldU,E->mesh.levmax));
Drive_solvers.c:248:			  dUdot_mag = vnorm_nonnewt(E,delta_U,oldU,E->mesh.levmax);
Drive_solvers.c:250:			  if(E->parallel.me==0){
Drive_solvers.c:253:                              fprintf(E->fp,"Stress dep. visc./plast.: DUdot = %.4e (%.4e) for iteration %d\n",
Drive_solvers.c:255:				  fflush(E->fp);
Drive_solvers.c:258:			  if (count>50 || dUdot_mag<E->viscosity.sdepv_misfit)
Drive_solvers.c:261:			  get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:268:		  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Drive_solvers.c:274:	  E->monitor.topo_loop++;
Drive_solvers.c:278:  if((E->sphere.caps == 12) &&
Drive_solvers.c:279:     (E->control.remove_rigid_rotation || E->control.remove_angular_momentum)) {
Drive_solvers.c:283:  get_STD_freesurf(E,E->slice.freesurf);
Element_calculations.c:55:  const int dims=E->mesh.nsd;
Element_calculations.c:56:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:60:    node = E->ien[m][e].node[a];
Element_calculations.c:62:    a1=E->id[m][node].doff[1];
Element_calculations.c:63:    E->F[m][a1] += elt_f[p];
Element_calculations.c:64:    a2=E->id[m][node].doff[2];
Element_calculations.c:65:    E->F[m][a2] += elt_f[p+1];
Element_calculations.c:66:    a3=E->id[m][node].doff[3];
Element_calculations.c:67:    E->F[m][a3] += elt_f[p+2];
Element_calculations.c:91:  const int neq=E->lmesh.neq;
Element_calculations.c:92:  const int nel=E->lmesh.nel;
Element_calculations.c:93:  const int lev=E->mesh.levmax;
Element_calculations.c:95:  get_buoyancy(E,E->buoyancy);
Element_calculations.c:97:  for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Element_calculations.c:100:      E->F[m][a] = 0.0;
Element_calculations.c:108:    for(i=1; i<=E->boundary.nel; i++) {
Element_calculations.c:109:      e = E->boundary.element[m][i];
Element_calculations.c:113:          if(E->control.pseudo_free_surf)
Element_calculations.c:122:  (E->solver.exchange_id_d)(E, E->F, lev);
Element_calculations.c:123:  strip_bcs_from_residual(E,E->F,lev);
Element_calculations.c:125:  /* compute the norm of E->F */
Element_calculations.c:126:  E->monitor.fdotf = sqrt(global_vdot(E, E->F, E->F, lev));
Element_calculations.c:128:  if(E->parallel.me==0) {
Element_calculations.c:130:              E->monitor.fdotf);
Element_calculations.c:131:      fprintf(E->fp, "Momentum equation force %.9e\n",
Element_calculations.c:132:              E->monitor.fdotf);
Element_calculations.c:300:    const int nn=loc_mat_size[E->mesh.nsd];
Element_calculations.c:303:    const int dims=E->mesh.nsd;
Element_calculations.c:312:    if (iconv || (el-1)%E->lmesh.ELZ[lev]==0)
Element_calculations.c:313:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,m,0);
Element_calculations.c:320:      W[k]=g_point[k].weight[dims-1]*E->GDA[lev][m][el].vpt[k]*E->EVI[lev][m][off];
Element_calculations.c:322:      if(E->viscosity.allow_anisotropic_viscosity){
Element_calculations.c:325:			 E->EVIn1[lev][m][off], E->EVIn2[lev][m][off], 
Element_calculations.c:326:			 E->EVIn3[lev][m][off],
Element_calculations.c:327:			 E->EVI2[lev][m][off],E->avmode[lev][m][off],
Element_calculations.c:333:    get_ba(&(E->N), &(E->GNX[lev][m][el]), &E->element_Cc, &E->element_Ccx,
Element_calculations.c:334:           rtf, E->mesh.nsd, ba);
Element_calculations.c:344:	if(E->viscosity.allow_anisotropic_viscosity){
Element_calculations.c:357:	  if(E->control.inv_gruneisen != 0)
Element_calculations.c:376:	  if(E->control.inv_gruneisen != 0)
Element_calculations.c:436:  if(E->control.NMULTIGRID||E->control.NASSEMBLE)
Element_calculations.c:458:  const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:459:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:460:  const int dims=E->mesh.nsd;
Element_calculations.c:461:  const int nel=E->lmesh.NEL[level];
Element_calculations.c:462:  const int neq=E->lmesh.NEQ[level];
Element_calculations.c:464:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Element_calculations.c:470:	ii = E->IEN[level][m][e].node[a];
Element_calculations.c:471:	a1 = E->ID[level][m][ii].doff[1];
Element_calculations.c:472:	a2 = E->ID[level][m][ii].doff[2];
Element_calculations.c:473:	a3 = E->ID[level][m][ii].doff[3];
Element_calculations.c:475:	        nodeb = E->IEN[level][m][e].node[b];
Element_calculations.c:480:		        E->elt_k[level][m][e].k[ii] *
Element_calculations.c:481:			u[m][E->ID[level][m][nodeb].doff[1]]
Element_calculations.c:482:		      + E->elt_k[level][m][e].k[ii+1] *
Element_calculations.c:483:			u[m][E->ID[level][m][nodeb].doff[2]]
Element_calculations.c:484:		      + E->elt_k[level][m][e].k[ii+2] *
Element_calculations.c:485:			u[m][E->ID[level][m][nodeb].doff[3]];
Element_calculations.c:488:		        E->elt_k[level][m][e].k[ii+n] *
Element_calculations.c:489:			u[m][E->ID[level][m][nodeb].doff[1]]
Element_calculations.c:490:		      + E->elt_k[level][m][e].k[ii+n+1] *
Element_calculations.c:491:			u[m][E->ID[level][m][nodeb].doff[2]]
Element_calculations.c:492:		      + E->elt_k[level][m][e].k[ii+n+2] *
Element_calculations.c:493:			u[m][E->ID[level][m][nodeb].doff[3]];
Element_calculations.c:496:		        E->elt_k[level][m][e].k[ii+n+n] *
Element_calculations.c:497:			u[m][E->ID[level][m][nodeb].doff[1]]
Element_calculations.c:498:		      + E->elt_k[level][m][e].k[ii+n+n+1] *
Element_calculations.c:499:			u[m][E->ID[level][m][nodeb].doff[2]]
Element_calculations.c:500:		      + E->elt_k[level][m][e].k[ii+n+n+2] *
Element_calculations.c:501:			u[m][E->ID[level][m][nodeb].doff[3]];
Element_calculations.c:509:    (E->solver.exchange_id_d)(E, Au, level);
Element_calculations.c:536:    const int neq=E->lmesh.NEQ[level];
Element_calculations.c:537:    const int nno=E->lmesh.NNO[level];
Element_calculations.c:538:    const int dims=E->mesh.nsd;
Element_calculations.c:542:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Element_calculations.c:551:       eqn1=E->ID[level][m][e].doff[1];
Element_calculations.c:552:       eqn2=E->ID[level][m][e].doff[2];
Element_calculations.c:553:       eqn3=E->ID[level][m][e].doff[3];
Element_calculations.c:559:       C=E->Node_map[level][m] + (e-1)*max_eqn;
Element_calculations.c:560:       B1=E->Eqn_k1[level][m]+(e-1)*max_eqn;
Element_calculations.c:561:       B2=E->Eqn_k2[level][m]+(e-1)*max_eqn;
Element_calculations.c:562:       B3=E->Eqn_k3[level][m]+(e-1)*max_eqn;
Element_calculations.c:576:     (E->solver.exchange_id_d)(E, Au, level);
Element_calculations.c:593:    const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:594:    const int dims=E->mesh.nsd;
Element_calculations.c:595:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:598:	    node=E->IEN[level][m][el].node[a];
Element_calculations.c:600:	    a1 = E->ID[level][m][node].doff[1];
Element_calculations.c:602:	    E->BI[level][m][a1] += elt_k[p*n+p];
Element_calculations.c:605:	    a2 = E->ID[level][m][node].doff[2];
Element_calculations.c:607:	    E->BI[level][m][a2] += elt_k[p*n+p];
Element_calculations.c:610:	    a1 = E->ID[level][m][node].doff[3];
Element_calculations.c:612:	    E->BI[level][m][a1] += elt_k[p*n+p];
Element_calculations.c:626: for (level=E->mesh.gridmin;level<=E->mesh.gridmax;level++)
Element_calculations.c:628:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Element_calculations.c:630:     npno = E->lmesh.NPNO[level];
Element_calculations.c:631:     neq=E->lmesh.NEQ[level];
Element_calculations.c:634:	E->BPI[level][m][e]=1.0;
Element_calculations.c:636:     if(!E->control.precondition)
Element_calculations.c:642:	    E->BPI[level][m][e] = 1.0/BU;
Element_calculations.c:644:	    E->BPI[level][m][e] = 1.0;
Element_calculations.c:662:    const int nel = E->lmesh.NEL[level];
Element_calculations.c:663:    const int ends = enodes[E->mesh.nsd];
Element_calculations.c:664:    const int dims = E->mesh.nsd;
Element_calculations.c:665:    const int npno = E->lmesh.NPNO[level];
Element_calculations.c:667:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Element_calculations.c:671:                b = E->IEN[level][m][e].node[a];
Element_calculations.c:672:                j1= E->ID[level][m][b].doff[1];
Element_calculations.c:673:                j2= E->ID[level][m][b].doff[2];
Element_calculations.c:674:                j3= E->ID[level][m][b].doff[3];
Element_calculations.c:675:                result[m][e] += E->elt_c[level][m][e].c[p  ][0] * U[m][j1]
Element_calculations.c:676:                              + E->elt_c[level][m][e].c[p+1][0] * U[m][j2]
Element_calculations.c:677:                              + E->elt_c[level][m][e].c[p+2][0] * U[m][j3];
Element_calculations.c:711:    const int nel=E->lmesh.NEL[level];
Element_calculations.c:712:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:713:    const int dims=E->mesh.nsd;
Element_calculations.c:714:    const int npno=E->lmesh.NPNO[level];
Element_calculations.c:716:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Element_calculations.c:720:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Element_calculations.c:724:	    b = E->IEN[level][m][e].node[a];
Element_calculations.c:725:	    j1= E->ID[level][m][b].doff[1];
Element_calculations.c:726:            j2= E->ID[level][m][b].doff[2];
Element_calculations.c:727:	    j3= E->ID[level][m][b].doff[3];
Element_calculations.c:728:	    divU[m][e] += E->elt_del[level][m][e].g[p  ][0] * U[m][j1]
Element_calculations.c:729:	                + E->elt_del[level][m][e].g[p+1][0] * U[m][j2]
Element_calculations.c:730:	                + E->elt_del[level][m][e].g[p+2][0] * U[m][j3];
Element_calculations.c:751:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:752:  const int dims=E->mesh.nsd;
Element_calculations.c:754:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Element_calculations.c:756:    nel=E->lmesh.NEL[lev];
Element_calculations.c:757:    neq=E->lmesh.NEQ[lev];
Element_calculations.c:769:	     b = E->IEN[lev][m][e].node[a];
Element_calculations.c:770:	     j1= E->ID[lev][m][b].doff[1];
Element_calculations.c:771:	     j2= E->ID[lev][m][b].doff[2];
Element_calculations.c:772:	     j3= E->ID[lev][m][b].doff[3];
Element_calculations.c:773:		        /*for(b=0;b<ploc_mat_size[E->mesh.nsd];b++)  */
Element_calculations.c:774:             gradP[m][j1] += E->elt_del[lev][m][e].g[p  ][0] * P[m][e];
Element_calculations.c:775:             gradP[m][j2] += E->elt_del[lev][m][e].g[p+1][0] * P[m][e];
Element_calculations.c:776:             gradP[m][j3] += E->elt_del[lev][m][e].g[p+2][0] * P[m][e];
Element_calculations.c:781:  (E->solver.exchange_id_d)(E, gradP,  lev); /*  correct gradP   */
Element_calculations.c:800:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:801:    const int dims=E->mesh.nsd;
Element_calculations.c:803:    npno=E->lmesh.NPNO[level];
Element_calculations.c:812:      node = E->IEN[level][m][e].node[a];
Element_calculations.c:813:      j=E->ID[level][m][node].doff[1];
Element_calculations.c:814:      gradP[p] += E->BI[level][m][j]*E->elt_del[level][m][e].g[p][0];
Element_calculations.c:816:      j=E->ID[level][m][node].doff[2];
Element_calculations.c:817:      gradP[p+1] += E->BI[level][m][j]*E->elt_del[level][m][e].g[p+1][0];
Element_calculations.c:819:      j=E->ID[level][m][node].doff[3];
Element_calculations.c:820:      gradP[p+2] += E->BI[level][m][j]*E->elt_del[level][m][e].g[p+2][0];
Element_calculations.c:833:      divU +=E->elt_del[level][m][e].g[p][0] * gradP[p];
Element_calculations.c:834:      divU +=E->elt_del[level][m][e].g[p+1][0] * gradP[p+1];
Element_calculations.c:835:      divU +=E->elt_del[level][m][e].g[p+2][0] * gradP[p+2];
Element_calculations.c:854:    const int dims = E->mesh.nsd;
Element_calculations.c:857:    if ((el-1)%E->lmesh.ELZ[lev]==0)
Element_calculations.c:858:        construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,m,1);
Element_calculations.c:860:    temp = p_point[1].weight[dims-1] * E->GDA[lev][m][el].ppt[1];
Element_calculations.c:862:    switch (E->refstate.choice) {
Element_calculations.c:867:        beta = - E->control.disptn_number * E->control.inv_gruneisen;
Element_calculations.c:871:                x[i] = E->N.ppt[GNPINDEX(a,1)]
Element_calculations.c:872:                    * E->element_Cc.ppt[BPINDEX(3,i,a,1)];
Element_calculations.c:884:            j = E->IEN[lev][m][el].node[a];
Element_calculations.c:885:            nz = (j - 1) % E->lmesh.noz + 1;
Element_calculations.c:886:            rho[a] = E->refstate.rho[nz];
Element_calculations.c:897:                x[i] = rho[a] * E->GNX[lev][m][el].ppt[GNPXINDEX(2,a,1)]
Element_calculations.c:898:                    * E->N.ppt[GNPINDEX(a,1)]
Element_calculations.c:899:                    * E->element_Cc.ppt[BPINDEX(3,i,a,1)];
Element_calculations.c:937:   const int dims=E->mesh.nsd;
Element_calculations.c:942:   if ((el-1)%E->lmesh.ELZ[lev]==0)
Element_calculations.c:943:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,m,1);
Element_calculations.c:947:   temp = p_point[1].weight[dims-1] * E->GDA[lev][m][el].ppt[1];
Element_calculations.c:950:   if(E->viscosity.allow_anisotropic_viscosity && modify_g){
Element_calculations.c:960:			E->EVIn1[lev][m][off], E->EVIn2[lev][m][off], E->EVIn3[lev][m][off],
Element_calculations.c:961:			E->EVI2[lev][m][off],E->avmode[lev][m][off],
Element_calculations.c:967:     get_ba_p(&(E->N),&(E->GNX[lev][m][el]),&E->element_Cc, &E->element_Ccx,rtf,E->mesh.nsd,ba);
Element_calculations.c:994:	 x[i] = E->GNX[lev][m][el].ppt[GNPXINDEX(2,a,1)] * E->element_Cc.ppt[BPINDEX(3,i,a,1)] + 
Element_calculations.c:995:	   2.0 * ra * E->N.ppt[GNPINDEX(a,1)]*E->element_Cc.ppt[BPINDEX(3,i,a,1)] + 
Element_calculations.c:997:	   (E->GNX[lev][m][el].ppt[GNPXINDEX(0,a,1)]*E->element_Cc.ppt[BPINDEX(1,i,a,1)] +
Element_calculations.c:998:	    E->N.ppt[GNPINDEX(a,1)]*E->element_Ccx.ppt[BPXINDEX(1,i,1,a,1)] +
Element_calculations.c:999:	    ct * E->N.ppt[GNPINDEX(a,1)] * E->element_Cc.ppt[BPINDEX(1,i,a,1)] +
Element_calculations.c:1000:	    si * (E->GNX[lev][m][el].ppt[GNPXINDEX(1,a,1)] * E->element_Cc.ppt[BPINDEX(2,i,a,1)] +
Element_calculations.c:1001:		  E->N.ppt[GNPINDEX(a,1)] * E->element_Ccx.ppt[BPXINDEX(2,i,2,a,1)]));
Element_calculations.c:1007:      /* fprintf (E->fp,"B= %d %d %g %g %g %g %g\n",el,a,E->GDA[lev][m][el].ppt[1],E->GNX[lev][m][el].ppt[GNPXINDEX(0,a,1)],E->GNX[lev][m][el].ppt[GNPXINDEX(1,a,1)],elt_del[p][0],elt_del[p+1][0]);
Element_calculations.c:1036:  const int dims=E->mesh.nsd;
Element_calculations.c:1041:  es = (el-1)/E->lmesh.elz + 1;
Element_calculations.c:1043:  if ((el-1)%E->lmesh.elz==0)
Element_calculations.c:1044:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,E->mesh.levmax,m,0);
Element_calculations.c:1049:    force[p] = E->buoyancy[m][E->ien[m][el].node[p]];
Element_calculations.c:1054:      force_at_gs[j] += force[k] * E->N.vpt[GNVINDEX(k,j)] ;
Element_calculations.c:1059:      nodea=E->ien[m][el].node[a];
Element_calculations.c:1063:        elt_f[p] += force_at_gs[j] * E->N.vpt[GNVINDEX(a,j)]
Element_calculations.c:1064:           *E->gDA[m][el].vpt[j]*g_point[j].weight[dims-1]
Element_calculations.c:1065:           *E->element_Cc.vpt[BVINDEX(3,i,a,j)];
Element_calculations.c:1074:            nodeb=E->ien[m][el].node[b];
Element_calculations.c:1075:            if ((E->node[m][nodeb]&type)&&(E->sphere.cap[m].VB[j][nodeb]!=0.0)){
Element_calculations.c:1077:                get_elt_k(E,el,elt_k,E->mesh.levmax,m,1);
Element_calculations.c:1082:                elt_f[p] -= elt_k[p*n+q] * E->sphere.cap[m].VB[j][nodeb];
Element_calculations.c:1105:	const int dims=E->mesh.nsd;
Element_calculations.c:1116:	int el = E->boundary.element[m][bel];
Element_calculations.c:1120:	const float rho = E->data.density;
Element_calculations.c:1121:	const float g = E->data.grav_acc;
Element_calculations.c:1123:	const float eta = E->data.ref_viscosity;
Element_calculations.c:1124:	const float kappa = E->data.therm_diff;
Element_calculations.c:1128:	if(E->control.side_sbcs)
Element_calculations.c:1130:			nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Element_calculations.c:1132:				value = E->sbc.SB[m][side][d][ E->sbc.node[m][nodea] ];
Element_calculations.c:1133:				flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Element_calculations.c:1142:				nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Element_calculations.c:1144:					value = E->sphere.cap[m].VB[d][nodea];
Element_calculations.c:1145:					flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Element_calculations.c:1159:				     E->mesh.levmax,m,0,side);
Element_calculations.c:1165:				traction_at_gs[d][k] += traction[d][j] * E->M.vpt[GMVINDEX(j,k)] ;
Element_calculations.c:1177:				elt_tr[p] += tmp * E->M.vpt[GMVINDEX(j,k)]
Element_calculations.c:1178:					* E->boundary.det[m][side][k][bel] * g_1d[k].weight[dims-1];
Element_calculations.c:1188:	const int dims=E->mesh.nsd;
Element_calculations.c:1199:	int el = E->boundary.element[m][bel];
Element_calculations.c:1203:	const float rho = E->data.density;
Element_calculations.c:1204:	const float g = E->data.grav_acc;
Element_calculations.c:1206:	const float eta = E->data.ref_viscosity;
Element_calculations.c:1207:	const float kappa = E->data.therm_diff;
Element_calculations.c:1211:	if(E->control.side_sbcs)
Element_calculations.c:1213:			nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Element_calculations.c:1215:				value = E->sbc.SB[m][side][d][ E->sbc.node[m][nodea] ];
Element_calculations.c:1216:				flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Element_calculations.c:1222:		if( side == SIDE_TOP && E->parallel.me_loc[3]==E->parallel.nprocz-1 && (el%E->lmesh.elz==0)) {
Element_calculations.c:1224:				nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Element_calculations.c:1225:				nodeas = E->ien[m][el].node[ sidenodes[side][a] ]/E->lmesh.noz;
Element_calculations.c:1229:					*(E->slice.freesurf[m][nodeas]+E->sphere.cap[m].V[3][nodea]*E->advection.timestep);
Element_calculations.c:1230:				if(E->parallel.me==11 && nodea==3328)
Element_calculations.c:1231:					fprintf(stderr,"traction=%e vnew=%e timestep=%e coeff=%e\n",traction[3][a],E->sphere.cap[m].V[3][nodea],E->advection.timestep,-1.0*factor*rho*g*(R*R*R)/(eta*kappa));
Element_calculations.c:1234:				if(found && E->parallel.me==1)
Element_calculations.c:1236:						E->parallel.me,bel,el,side,SIDE_TOP,a,sidenodes[side][a],
Element_calculations.c:1237:						E->ien[m][el].node[ sidenodes[side][a] ],E->lmesh.noz,
Element_calculations.c:1245:				nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Element_calculations.c:1247:					value = E->sphere.cap[m].VB[d][nodea];
Element_calculations.c:1248:					flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Element_calculations.c:1262:				     E->mesh.levmax,m,0,side);
Element_calculations.c:1268:				traction_at_gs[d][k] += traction[d][j] * E->M.vpt[GMVINDEX(j,k)] ;
Element_calculations.c:1280:				elt_tr[p] += tmp * E->M.vpt[GMVINDEX(j,k)]
Element_calculations.c:1281:					* E->boundary.det[m][side][k][bel] * g_1d[k].weight[dims-1];
Element_calculations.c:1302:     const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:1303:     const int ends=enodes[E->mesh.nsd];
Element_calculations.c:1304:     const int vpts=vpoints[E->mesh.nsd];
Element_calculations.c:1305:     const int dims=E->mesh.nsd;
Element_calculations.c:1310:	  Visc += E->EVI[level][m][(el-1)*vpts+a];
Element_calculations.c:1315:        nodea=E->IEN[level][m][el].node[a];
Element_calculations.c:1317:           nodeb=E->IEN[level][m][el].node[b];      /* for Kab dims*dims  */
Element_calculations.c:1319:	   elt_k[i  ] += Visc*E->control.augmented*
Element_calculations.c:1320:	              E->elt_del[level][m][el].g[p[a]][0]*
Element_calculations.c:1321:		      E->elt_del[level][m][el].g[p[b]][0];   /*for 11 */
Element_calculations.c:1322:	   elt_k[i+1] += Visc*E->control.augmented*
Element_calculations.c:1323:	              E->elt_del[level][m][el].g[p[a]][0]*
Element_calculations.c:1324:		      E->elt_del[level][m][el].g[p[b]+1][0];  /* for 12 */
Element_calculations.c:1325:	   elt_k[i+n] += Visc*E->control.augmented*
Element_calculations.c:1326:	              E->elt_del[level][m][el].g[p[a]+1][0]*
Element_calculations.c:1327:		      E->elt_del[level][m][el].g[p[b]][0];    /* for 21 */
Element_calculations.c:1328:	   elt_k[i+n+1] += Visc*E->control.augmented*
Element_calculations.c:1329:	              E->elt_del[level][m][el].g[p[a]+1][0]*
Element_calculations.c:1330:		      E->elt_del[level][m][el].g[p[b]+1][0];  /* for 22 */
Element_calculations.c:1333:	       elt_k[i+2] += Visc*E->control.augmented*
Element_calculations.c:1334:	              E->elt_del[level][m][el].g[p[a]][0]*
Element_calculations.c:1335:		      E->elt_del[level][m][el].g[p[b]+2][0];  /* for 13 */
Element_calculations.c:1336:	       elt_k[i+n+2] += Visc*E->control.augmented*
Element_calculations.c:1337:	              E->elt_del[level][m][el].g[p[a]+1][0]*
Element_calculations.c:1338:		      E->elt_del[level][m][el].g[p[b]+2][0];  /* for 23 */
Element_calculations.c:1339:	       elt_k[i+n+n] += Visc*E->control.augmented*
Element_calculations.c:1340:	              E->elt_del[level][m][el].g[p[a]+2][0]*
Element_calculations.c:1341:		      E->elt_del[level][m][el].g[p[b]][0];    /* for 31 */
Element_calculations.c:1342:	       elt_k[i+n+n+1] += Visc*E->control.augmented*
Element_calculations.c:1343:	              E->elt_del[level][m][el].g[p[a]+2][0]*
Element_calculations.c:1344:		      E->elt_del[level][m][el].g[p[b]+1][0];  /* for 32 */
Element_calculations.c:1345:	       elt_k[i+n+n+2] += Visc*E->control.augmented*
Element_calculations.c:1346:	              E->elt_del[level][m][el].g[p[a]+2][0]*
Element_calculations.c:1347:		      E->elt_del[level][m][el].g[p[b]+2][0];  /* for 33 */
Full_boundary_conditions.c:57:  for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--)
Full_boundary_conditions.c:58:    for (j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_boundary_conditions.c:59:      noz = E->mesh.NOZ[lv];
Full_boundary_conditions.c:60:      if(E->mesh.topvbc != 1) {	/* free slip top */
Full_boundary_conditions.c:61:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,VBX,0,lv,j);
Full_boundary_conditions.c:62:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,1,lv,j);
Full_boundary_conditions.c:63:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,VBY,0,lv,j);
Full_boundary_conditions.c:64:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,SBX,1,lv,j);
Full_boundary_conditions.c:65:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,0,lv,j);
Full_boundary_conditions.c:66:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,SBY,1,lv,j);
Full_boundary_conditions.c:69:	if((lv==E->mesh.gridmax) && E->control.ggrd.vtop_control)
Full_boundary_conditions.c:74:      if(E->mesh.botvbc != 1) {	/* free slip bottom */
Full_boundary_conditions.c:75:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,VBX,0,lv,j);
Full_boundary_conditions.c:76:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,1,lv,j);
Full_boundary_conditions.c:77:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,VBY,0,lv,j);
Full_boundary_conditions.c:78:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,SBX,1,lv,j);
Full_boundary_conditions.c:79:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,SBZ,0,lv,j);
Full_boundary_conditions.c:80:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,SBY,1,lv,j);
Full_boundary_conditions.c:83:      if(E->mesh.topvbc == 1) {	/* velocity/no slip BC */
Full_boundary_conditions.c:84:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,VBX,1,lv,j);
Full_boundary_conditions.c:85:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,1,lv,j);
Full_boundary_conditions.c:86:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,VBY,1,lv,j);
Full_boundary_conditions.c:87:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,SBX,0,lv,j);
Full_boundary_conditions.c:88:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,0,lv,j);
Full_boundary_conditions.c:89:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,SBY,0,lv,j);
Full_boundary_conditions.c:93:	if((lv==E->mesh.gridmax) && E->control.ggrd.vtop_control)
Full_boundary_conditions.c:98:        if(E->control.vbcs_file){ /* this should either only be called
Full_boundary_conditions.c:105:	  if((lv == E->mesh.gridmin) && (j == E->sphere.caps_per_proc))
Full_boundary_conditions.c:110:      if(E->mesh.botvbc == 1) {	/* velocity bottom BC */
Full_boundary_conditions.c:111:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,VBX,1,lv,j);
Full_boundary_conditions.c:112:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,1,lv,j);
Full_boundary_conditions.c:113:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,VBY,1,lv,j);
Full_boundary_conditions.c:114:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,SBX,0,lv,j);
Full_boundary_conditions.c:115:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,SBZ,0,lv,j);
Full_boundary_conditions.c:116:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,SBY,0,lv,j);
Full_boundary_conditions.c:120:      if(E->control.side_sbcs)
Full_boundary_conditions.c:123:/* if(E->control.verbose) { */
Full_boundary_conditions.c:124:/*  for (j=1;j<=E->sphere.caps_per_proc;j++) */
Full_boundary_conditions.c:125:/*    for (node=1;node<=E->lmesh.nno;node++) */
Full_boundary_conditions.c:126:/*       fprintf(E->fp_out,"m=%d VB== %d %g %g %g flag %u %u %u\n",j,node,E->sphere.cap[j].VB[1][node],E->sphere.cap[j].VB[2][node],E->sphere.cap[j].VB[3][node],E->node[j][node]&VBX,E->node[j][node]&VBY,E->node[j][node]&VBZ); */
Full_boundary_conditions.c:127:/*  fflush(E->fp_out); */
Full_boundary_conditions.c:136:	anything at present, if E->mesh.toplayerbc != 0
Full_boundary_conditions.c:151:  lev = E->mesh.levmax;
Full_boundary_conditions.c:152:  for (j=1;j<=E->sphere.caps_per_proc;j++)    {
Full_boundary_conditions.c:153:    noz = E->mesh.noz;
Full_boundary_conditions.c:154:    if(E->mesh.toptbc == 1)    {
Full_boundary_conditions.c:155:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,1,lev,j);
Full_boundary_conditions.c:156:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,0,lev,j);
Full_boundary_conditions.c:157:      if(E->control.tbcs_file)
Full_boundary_conditions.c:161:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,0,lev,j);
Full_boundary_conditions.c:162:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,1,lev,j);
Full_boundary_conditions.c:165:    if(E->mesh.bottbc == 1)    {
Full_boundary_conditions.c:166:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,1,lev,j);
Full_boundary_conditions.c:167:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,0,lev,j);
Full_boundary_conditions.c:170:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,0,lev,j);
Full_boundary_conditions.c:171:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,1,lev,j);
Full_boundary_conditions.c:174:    if(E->control.lith_age_time==1)  {
Full_boundary_conditions.c:186:  E->temperatures_conform_bcs = temperatures_conform_bcs;
Full_boundary_conditions.c:199:  if(dirn > E->mesh.nsd)
Full_boundary_conditions.c:205:      rowl = E->lmesh.NOZ[level];
Full_boundary_conditions.c:207:  if ( ( (ROW==1) && (E->parallel.me_loc[3]==0) ) ||
Full_boundary_conditions.c:208:       ( (ROW==E->mesh.NOZ[level]) && (E->parallel.me_loc[3]==E->parallel.nprocz-1) ) ) {
Full_boundary_conditions.c:212:      for(j=1;j<=E->lmesh.NOY[level];j++)
Full_boundary_conditions.c:213:    	for(i=1;i<=E->lmesh.NOX[level];i++)     {
Full_boundary_conditions.c:214:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Full_boundary_conditions.c:215:    	  E->NODE[level][m][node] = E->NODE[level][m][node] & (~ mask);
Full_boundary_conditions.c:221:      for(j=1;j<=E->lmesh.NOY[level];j++)
Full_boundary_conditions.c:222:        for(i=1;i<=E->lmesh.NOX[level];i++)       {
Full_boundary_conditions.c:223:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Full_boundary_conditions.c:224:    	  E->NODE[level][m][node] = E->NODE[level][m][node] | (mask);
Full_boundary_conditions.c:225:    	  if(level==E->mesh.levmax)   /* NB */
Full_boundary_conditions.c:239:  fprintf(E->fp,"Periodic boundary conditions\n");
Full_boundary_conditions.c:247: fprintf(E->fp,"Periodic temperature boundary conditions\n");
Full_geometry_cartesian.c:38:  E->mesh.nsd = 2;
Full_geometry_cartesian.c:39:  E->mesh.dof = 2;
Full_geometry_cartesian.c:48:  E->mesh.nsd = 2;
Full_geometry_cartesian.c:49:  E->mesh.dof = 3;
Full_geometry_cartesian.c:57:  E->mesh.nsd = 3;
Full_geometry_cartesian.c:58:  E->mesh.dof = 3;
Full_geometry_cartesian.c:65:  E->mesh.nsd = 3;
Full_geometry_cartesian.c:66:  E->mesh.dof = 3;
Full_geometry_cartesian.c:68:  E->sphere.caps = 12;
Full_geometry_cartesian.c:69:  E->sphere.max_connections = 6;
Full_obsolete.c:46:  E->parallel.me = 0;
Full_obsolete.c:47:  E->parallel.nproc = 1;
Full_obsolete.c:48:  E->parallel.me_loc[1] = 0;
Full_obsolete.c:49:  E->parallel.me_loc[2] = 0;
Full_obsolete.c:50:  E->parallel.me_loc[3] = 0;
Full_obsolete.c:53:  MPI_Comm_rank(E->parallel.world, &(E->parallel.me) );
Full_obsolete.c:54:  MPI_Comm_size(E->parallel.world, &(E->parallel.nproc) );
Full_obsolete.c:78: const int dims = E->mesh.nsd;
Full_obsolete.c:86: if (E->parallel.nprocz==1)  {
Full_obsolete.c:87:    if (E->parallel.me==0) fprintf(stderr,"scatter_to_nlayer should not be called\n");
Full_obsolete.c:92:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Full_obsolete.c:94:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:96:   SD = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Full_obsolete.c:99:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:101:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:110:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:111:    if (E->parallel.me==rootid)
Full_obsolete.c:112:      for (d=0;d<E->parallel.nprocz;d++)  {
Full_obsolete.c:114:        for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Full_obsolete.c:115:          k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:116:          for (j=1;j<=E->lmesh.NOY[lev];j++)
Full_obsolete.c:117:            for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Full_obsolete.c:118:              node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Full_obsolete.c:119:              node1= k1+ (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Full_obsolete.c:127:           MPI_Send(SD,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],rootid,E->parallel.world);
Full_obsolete.c:130:           for (i=0;i<E->lmesh.NEQ[lev];i++)
Full_obsolete.c:134:        MPI_Recv(AUo[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,rootid,E->parallel.world,&status);
Full_obsolete.c:149: const int dims = E->mesh.nsd;
Full_obsolete.c:157: if (E->parallel.nprocz==1)  {
Full_obsolete.c:158:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Full_obsolete.c:163:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Full_obsolete.c:165:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:167:   RV = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Full_obsolete.c:170:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:172:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:181:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:182:    if (E->parallel.me!=rootid)
Full_obsolete.c:183:       MPI_Send(AUi[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,E->parallel.me,E->parallel.world);
Full_obsolete.c:185:       for (d=0;d<E->parallel.nprocz;d++) {
Full_obsolete.c:187:	   MPI_Recv(RV,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],processors[d],E->parallel.world,&status);
Full_obsolete.c:189:           for (node=0;node<E->lmesh.NEQ[lev];node++)
Full_obsolete.c:192:         for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Full_obsolete.c:193:           k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:194:           for (j=1;j<=E->lmesh.NOY[lev];j++)
Full_obsolete.c:195:             for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Full_obsolete.c:196:               node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Full_obsolete.c:197:               node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Full_obsolete.c:225: if (E->parallel.nprocz==1)  {
Full_obsolete.c:226:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Full_obsolete.c:231:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Full_obsolete.c:232:   NNO = NOZ*E->lmesh.NOX[lev]*E->lmesh.NOY[lev];
Full_obsolete.c:234:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:235:   RV = (float *)malloc((E->lmesh.NNO[lev]+2)*sizeof(float));
Full_obsolete.c:238:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:240:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:249:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:250:    if (E->parallel.me!=rootid) {
Full_obsolete.c:251:       MPI_Send(AUi[m],E->lmesh.NNO[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Full_obsolete.c:256:       for (d=0;d<E->parallel.nprocz;d++) {
Full_obsolete.c:258:           MPI_Recv(RV,E->lmesh.NNO[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Full_obsolete.c:260:	   for (node=1;node<=E->lmesh.NNO[lev];node++)
Full_obsolete.c:263:         for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Full_obsolete.c:264:           k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:265:           for (j=1;j<=E->lmesh.NOY[lev];j++)
Full_obsolete.c:266:             for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Full_obsolete.c:267:               node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Full_obsolete.c:268:               node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Full_obsolete.c:293: if (E->parallel.nprocz==1)  {
Full_obsolete.c:294:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Full_obsolete.c:299:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz;
Full_obsolete.c:300:   NNO = NOZ*E->lmesh.ELX[lev]*E->lmesh.ELY[lev];
Full_obsolete.c:302:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:303:   RV = (float *)malloc((E->lmesh.NEL[lev]+2)*sizeof(float));
Full_obsolete.c:306:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:308:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:317:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:318:    if (E->parallel.me!=rootid) {
Full_obsolete.c:319:       MPI_Send(AUi[m],E->lmesh.NEL[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Full_obsolete.c:324:       for (d=0;d<E->parallel.nprocz;d++) {
Full_obsolete.c:326:           MPI_Recv(RV,E->lmesh.NEL[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Full_obsolete.c:328:	   for (e=1;e<=E->lmesh.NEL[lev];e++)
Full_obsolete.c:331:         for (k=1;k<=E->lmesh.ELZ[lev];k++)   {
Full_obsolete.c:332:           k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:333:           for (j=1;j<=E->lmesh.ELY[lev];j++)
Full_obsolete.c:334:             for (i=1;i<=E->lmesh.ELX[lev];i++)   {
Full_obsolete.c:335:               e = k + (i-1)*E->lmesh.ELZ[lev] + (j-1)*E->lmesh.ELZ[lev]*E->lmesh.ELX[lev];
Full_obsolete.c:336:               e1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.ELX[lev];
Full_obsolete.c:363: if (E->parallel.nprocxy==1)   return;
Full_obsolete.c:365: nsl = E->sphere.nsf+1;
Full_obsolete.c:366: me = E->parallel.me;
Full_obsolete.c:370:   for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:371:     RG[i] = ( float *)malloc((E->sphere.nsf+1)*sizeof(float));
Full_obsolete.c:376: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:377:   to_everyone = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Full_obsolete.c:382:     MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c:388: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:389:   from_proc = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Full_obsolete.c:393:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c:399: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:400:   for (j=1;j<=E->sphere.nsf; j++)  {
Full_obsolete.c:423: if (E->parallel.nprocz==1)   return;
Full_obsolete.c:425: jumpp = E->sphere.hindice;
Full_obsolete.c:426: nsl = E->sphere.hindice*2;
Full_obsolete.c:427: me = E->parallel.me;
Full_obsolete.c:430: if (E->parallel.me_loc[3]==dest_proc)
Full_obsolete.c:433: for (i=0;i<E->sphere.hindice;i++)   {
Full_obsolete.c:439: if (E->parallel.me_loc[3]!=dest_proc)    {  /* send TG */
Full_obsolete.c:440:     to_proc = E->parallel.me_sph*E->parallel.nprocz+E->parallel.nprocz-1;
Full_obsolete.c:442:     MPI_Send(TG,nsl,MPI_FLOAT,to_proc,mst,E->parallel.world);
Full_obsolete.c:447: if (E->parallel.me_loc[3]==dest_proc)  {
Full_obsolete.c:448:   for (i=1;i<E->parallel.nprocz;i++) {
Full_obsolete.c:451:      MPI_Recv(RG,nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&status1);
Full_obsolete.c:453:      for (j=0;j<E->sphere.hindice;j++)   {
Full_obsolete.c:461: if (E->parallel.me_loc[3]==dest_proc)
Full_obsolete.c:482: if (E->parallel.nprocxy==1)   return;
Full_obsolete.c:484: nsl = E->sphere.hindice*2;
Full_obsolete.c:485: me = E->parallel.me;
Full_obsolete.c:487: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:492: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:493:   to_everyone = E->parallel.nprocz*(i-1) + loc_proc;
Full_obsolete.c:498:     MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c:504: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:505:   from_proc = E->parallel.nprocz*(i-1) + loc_proc;
Full_obsolete.c:509:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c:515: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:521: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:536:  i = cases[E->sphere.caps_per_proc];
Full_obsolete.c:538:  E->parallel.nproc_sph[1] = incases3[i].xy[0];
Full_obsolete.c:539:  E->parallel.nproc_sph[2] = incases3[i].xy[1];
Full_obsolete.c:541:  E->sphere.lelx = E->sphere.elx/E->parallel.nproc_sph[1];
Full_obsolete.c:542:  E->sphere.lely = E->sphere.ely/E->parallel.nproc_sph[2];
Full_obsolete.c:543:  E->sphere.lsnel = E->sphere.lely*E->sphere.lelx;
Full_obsolete.c:544:  E->sphere.lnox = E->sphere.lelx + 1;
Full_obsolete.c:545:  E->sphere.lnoy = E->sphere.lely + 1;
Full_obsolete.c:546:  E->sphere.lnsf = E->sphere.lnox*E->sphere.lnoy;
Full_obsolete.c:548:  for (i=0;i<=E->parallel.nprocz-1;i++)
Full_obsolete.c:549:    if (E->parallel.me_loc[3] == i)    {
Full_obsolete.c:550:      E->parallel.me_sph = (E->parallel.me-i)/E->parallel.nprocz;
Full_obsolete.c:551:      E->parallel.me_loc_sph[1] = E->parallel.me_sph%E->parallel.nproc_sph[1];
Full_obsolete.c:552:      E->parallel.me_loc_sph[2] = E->parallel.me_sph/E->parallel.nproc_sph[1];
Full_obsolete.c:555:  E->sphere.lexs = E->sphere.lelx * E->parallel.me_loc_sph[1];
Full_obsolete.c:556:  E->sphere.leys = E->sphere.lely * E->parallel.me_loc_sph[2];
Full_obsolete.c:577:    record_h = E->control.record_every;
Full_obsolete.c:579:    if ( (ii == 0) || ((ii % record_h) == 0) || E->control.DIRECTII)    {
Full_obsolete.c:585:    if ( ((ii == 0) || ((ii % E->control.record_every) == 0))
Full_obsolete.c:586:	 || E->control.DIRECTII)     {
Full_obsolete.c:610:  int lev = E->mesh.levmax;
Full_obsolete.c:616:  const int nno = E->lmesh.nno;
Full_obsolete.c:617:  const int nsd = E->mesh.nsd;
Full_obsolete.c:622:/*       ii = E->lmesh.nsf; */
Full_obsolete.c:623:/*       m = (E->parallel.me_loc[3]==0)?ii:0; */
Full_obsolete.c:626:      /* size2 = (E->lmesh.nel+1)*sizeof(float); */
Full_obsolete.c:629:  sprintf(output_file,"%s.coord.%d",E->control.data_file,E->parallel.me);
Full_obsolete.c:632:     fprintf(E->fp,"(Output.c #1) Cannot open %s\n",output_file);
Full_obsolete.c:635:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_obsolete.c:636:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Full_obsolete.c:637:    for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:638:      fprintf(fp1,"%.3e %.3e %.3e\n",E->sx[j][1][i],E->sx[j][2][i],E->sx[j][3][i]);
Full_obsolete.c:646:  sprintf(output_file,"%s.visc.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:648:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_obsolete.c:649:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Full_obsolete.c:650:    for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:651:      fprintf(fp1,"%.3e\n",E->VI[lev][j][i]);
Full_obsolete.c:656:  sprintf(output_file,"%s.velo.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:658:  fprintf(fp1,"%d %d %.5e\n",file_number,E->lmesh.nno,E->monitor.elapsed_time);
Full_obsolete.c:659:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_obsolete.c:660:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Full_obsolete.c:661:     for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:662:       fprintf(fp1,"%.6e %.6e %.6e %.6e\n",E->sphere.cap[j].V[1][i],E->sphere.cap[j].V[2][i],E->sphere.cap[j].V[3][i],E->T[j][i]);
Full_obsolete.c:663:     /* for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:664:	fprintf(fp1,"%.6e\n",E->T[j][i]); */
Full_obsolete.c:669:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)      {
Full_obsolete.c:670:    sprintf(output_file,"%s.surf.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:672:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Full_obsolete.c:673:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Full_obsolete.c:674:      for(i=1;i<=E->lmesh.nsf;i++)   {
Full_obsolete.c:675:	s = i*E->lmesh.noz;
Full_obsolete.c:676:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpg[j][i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Full_obsolete.c:683:  if (E->parallel.me_loc[3]==0)      {
Full_obsolete.c:684:    sprintf(output_file,"%s.botm.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:686:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Full_obsolete.c:687:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Full_obsolete.c:688:      for(i=1;i<=E->lmesh.nsf;i++)  {
Full_obsolete.c:689:	s = (i-1)*E->lmesh.noz + 1;
Full_obsolete.c:690:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Full_obsolete.c:698:/*   if (E->parallel.me<E->parallel.nprocz)  { */
Full_obsolete.c:699:/*     sprintf(output_file,"%s.ave_r.%d.%d",E->control.data_file,E->parallel.me,file_number); */
Full_obsolete.c:701:/*     for(j=1;j<=E->lmesh.noz;j++)  { */
Full_obsolete.c:702:/*         fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]); */
Full_obsolete.c:736:  size2= (E->lmesh.nno+1)*sizeof(float);
Full_obsolete.c:738:  sprintf(output_file,"%s.%05d.SZZ",E->control.data_file,file_number);
Full_obsolete.c:762:  if (E->parallel.me==proc_loc)  {
Full_obsolete.c:764:     sprintf(output_file,"%s.%s_intp",E->control.data_file,filen);
Full_obsolete.c:766:     for (i=E->sphere.nox;i>=1;i--)
Full_obsolete.c:767:     for (j=1;j<=E->sphere.noy;j++)  {
Full_obsolete.c:768:        node = i + (j-1)*E->sphere.nox;
Full_obsolete.c:769:        t = 90-E->sphere.sx[1][node]*rad;
Full_obsolete.c:770:        f = E->sphere.sx[2][node]*rad;
Full_obsolete.c:776:     fprintf(E->fp,"lmaxx=%.4e lminx=%.4e for %s\n",maxx,minx,filen);
Full_obsolete.c:779:     sprintf(output_file,"%s.%s_sharm",E->control.data_file,filen);
Full_obsolete.c:783:     for (ll=0;ll<=E->output.llmax;ll++)
Full_obsolete.c:785:        i = E->sphere.hindex[ll][mm];
Full_obsolete.c:828:	    E->trace.Have_C=(double *)malloc((E->lmesh.noz+2)*sizeof(double));
Full_obsolete.c:829:	    E->trace.Havel_tracers=(double *)malloc((E->lmesh.elz+2)*sizeof(double));
Full_obsolete.c:836:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_obsolete.c:838:	    reltrac[j]=(double *) malloc((E->lmesh.nel+1)*sizeof(double));
Full_obsolete.c:839:	    for (kk=1;kk<=E->lmesh.nel;kk++)
Full_obsolete.c:841:		    reltrac[j][kk]=(1.0*E->composition.ieltrac[j][kk]);
Full_obsolete.c:845:    return_elementwise_horiz_ave(E,reltrac,E->trace.Havel_tracers);
Full_obsolete.c:847:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_obsolete.c:852:    if (E->parallel.me<E->parallel.nprocz)
Full_obsolete.c:854:	    sprintf(output_file,"%s.ave_tracers.%d.%d",E->control.data_file,E->parallel.me,E->monitor.solution_cycles);
Full_obsolete.c:856:	    for(kk=1;kk<=E->lmesh.elz;kk++)
Full_obsolete.c:858:		    halfpoint=0.5*(E->sx[1][3][kk+1]+E->sx[1][3][kk]);
Full_obsolete.c:859:		    fprintf(fp2,"%.4e %.4e\n",halfpoint,E->trace.Havel_tracers[kk]);
Full_obsolete.c:866:    if (E->composition.chemical_buoyancy==1)
Full_obsolete.c:868:	    return_horiz_ave(E,E->composition.comp_node,E->trace.Have_C);
Full_obsolete.c:871:	    if (E->parallel.me<E->parallel.nprocz)
Full_obsolete.c:873:		    sprintf(output_file,"%s.ave_c.%d.%d",E->control.data_file,E->parallel.me,E->monitor.solution_cycles);
Full_obsolete.c:875:		    for(kk=1;kk<=E->lmesh.noz;kk++)
Full_obsolete.c:877:			    fprintf(fp2,"%.4e %.4e\n",E->sx[1][3][kk],E->trace.Have_C[kk]);
Full_obsolete.c:913:    fprintf(E->trace.fpt,"ERROR(icheck_regular_neighbors)-this subroutine is no longer used !\n");
Full_obsolete.c:914:    fflush(E->trace.fpt);
Full_obsolete.c:925:                    if ( (new_ntheta>0)&&(new_ntheta<=E->trace.numtheta[j])&&(new_nphi>0)&&(new_nphi<=E->trace.numphi[j]) )
Full_obsolete.c:927:                            iregel=new_ntheta+(new_nphi-1)*E->trace.numtheta[j];
Full_obsolete.c:928:                            if ((iregel>0) && (iregel<=E->trace.numregel[j]))
Full_obsolete.c:970:    fprintf(E->trace.fpt,"ERROR(iquick element)-this routine is no longer used!\n");
Full_obsolete.c:971:    fflush(E->trace.fpt);
Full_obsolete.c:978:      fprintf(E->trace.fpt,"AA: ichoice: %d\n",ichoice);
Full_obsolete.c:979:      fflush(E->trace.fpt);
Full_obsolete.c:987:      iregnode[3]=iregel+nphi+E->trace.numtheta[j]+1;
Full_obsolete.c:988:      iregnode[4]=iregel+nphi+E->trace.numtheta[j];
Full_obsolete.c:992:    itemp2=itemp1+E->trace.numtheta[j];
Full_obsolete.c:1001:            if ((iregnode[kk]<1) || (iregnode[kk]>E->trace.numregnodes[j]) )
Full_obsolete.c:1003:                    fprintf(E->trace.fpt,"ERROR(iquick)-weird regnode %d\n",iregnode[kk]);
Full_obsolete.c:1004:                    fflush(E->trace.fpt);
Full_obsolete.c:1015:            if (E->trace.regnodetoel[j][iregnode[kk]]<=0) goto next_corner;
Full_obsolete.c:1020:                    if (E->trace.regnodetoel[j][iregnode[kk]]==E->trace.regnodetoel[j][iregnode[pp]]) goto next_corner;
Full_obsolete.c:1023:            imap[ichoice]=E->trace.regnodetoel[j][iregnode[kk]];
Full_obsolete.c:1034:    E->trace.istat_ichoice[j][ichoice]++;
Full_parallel_related.c:57:  me = E->parallel.me;
Full_parallel_related.c:59:  if ( E->parallel.nprocx != E->parallel.nprocy ) {
Full_parallel_related.c:60:    if (E->parallel.me==0) fprintf(stderr,"!!!! nprocx must equal to nprocy \n");
Full_parallel_related.c:64:  surf_proc_per_cap = E->parallel.nprocx * E->parallel.nprocy;
Full_parallel_related.c:65:  proc_per_cap = surf_proc_per_cap * E->parallel.nprocz;
Full_parallel_related.c:66:  total_proc = E->sphere.caps * proc_per_cap;
Full_parallel_related.c:67:  E->parallel.total_surf_proc = E->sphere.caps * surf_proc_per_cap;
Full_parallel_related.c:69:  if ( total_proc != E->parallel.nproc ) {
Full_parallel_related.c:70:    if (E->parallel.me==0) fprintf(stderr,"!!!! # of requested CPU is incorrect (expected: %i got: %i)\n",
Full_parallel_related.c:71:				   total_proc, E->parallel.nproc);
Full_parallel_related.c:75:  E->sphere.caps_per_proc = max(1,E->sphere.caps*E->parallel.nprocz/E->parallel.nproc);
Full_parallel_related.c:77:  if (E->sphere.caps_per_proc > 1) {
Full_parallel_related.c:78:    if (E->parallel.me==0) fprintf(stderr,"!!!! # caps per proc > 1 is not supported.\n \n");
Full_parallel_related.c:86:  E->parallel.me_loc[3] = (me - cap_id_surf*proc_per_cap) % E->parallel.nprocz;
Full_parallel_related.c:89:  E->parallel.me_loc[1] = ((me - cap_id_surf*proc_per_cap - E->parallel.me_loc[3])/E->parallel.nprocz) % E->parallel.nprocx;
Full_parallel_related.c:92:  E->parallel.me_loc[2] = ((((me - cap_id_surf*proc_per_cap - E->parallel.me_loc[3])/E->parallel.nprocz) - E->parallel.me_loc[1])/E->parallel.nprocx) % E->parallel.nprocy;
Full_parallel_related.c:99:the second oordinate as fi, which goes E-W. Here we use R-L as the first
Full_parallel_related.c:105:[xyz] is x=E->parallel.me_loc[1],y=E->parallel.me_loc[2],z=E->parallel.me_loc[3]
Full_parallel_related.c:110:  i = cases[E->sphere.caps_per_proc]; /* 1 for more than 12 processors */
Full_parallel_related.c:112:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Full_parallel_related.c:113:    temp = pid_surf*E->sphere.caps_per_proc + j-1; /* cap number (out of 12) */
Full_parallel_related.c:114:    E->sphere.capid[j] = incases1[i].links[temp]; /* id (1~12) of the current cap */
Full_parallel_related.c:120:     E->sphere.max_connections = 8;
Full_parallel_related.c:124:  E->parallel.loc2proc_map = (int ****) malloc(E->sphere.caps*sizeof(int ***));
Full_parallel_related.c:125:  for (m=0;m<E->sphere.caps;m++)  {
Full_parallel_related.c:126:    E->parallel.loc2proc_map[m] = (int ***) malloc(E->parallel.nprocx*sizeof(int **));
Full_parallel_related.c:127:    for (i=0;i<E->parallel.nprocx;i++) {
Full_parallel_related.c:128:      E->parallel.loc2proc_map[m][i] = (int **) malloc(E->parallel.nprocy*sizeof(int *));
Full_parallel_related.c:129:      for (j=0;j<E->parallel.nprocy;j++)
Full_parallel_related.c:130:	E->parallel.loc2proc_map[m][i][j] = (int *) malloc(E->parallel.nprocz*sizeof(int));
Full_parallel_related.c:134:  for (m=0;m<E->sphere.caps;m++)
Full_parallel_related.c:135:    for (i=0;i<E->parallel.nprocx;i++)
Full_parallel_related.c:136:      for (j=0;j<E->parallel.nprocy;j++)
Full_parallel_related.c:137:	for (k=0;k<E->parallel.nprocz;k++) {
Full_parallel_related.c:138:	  if (E->sphere.caps_per_proc>1) {
Full_parallel_related.c:139:	    temp = cases[E->sphere.caps_per_proc];
Full_parallel_related.c:140:	    E->parallel.loc2proc_map[m][i][j][k] = incases2[temp].links[m-1];
Full_parallel_related.c:143:	    E->parallel.loc2proc_map[m][i][j][k] = m*proc_per_cap
Full_parallel_related.c:144:	      + j*E->parallel.nprocx*E->parallel.nprocz
Full_parallel_related.c:145:	      + i*E->parallel.nprocz + k;
Full_parallel_related.c:148:  if (E->control.verbose) {
Full_parallel_related.c:149:    fprintf(E->fp_out,"me=%d loc1=%d loc2=%d loc3=%d\n",me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3]);
Full_parallel_related.c:150:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Full_parallel_related.c:151:      fprintf(E->fp_out,"capid[%d]=%d \n",j,E->sphere.capid[j]);
Full_parallel_related.c:153:    for (m=0;m<E->sphere.caps;m++)
Full_parallel_related.c:154:      for (j=0;j<E->parallel.nprocy;j++)
Full_parallel_related.c:155:	for (i=0;i<E->parallel.nprocx;i++)
Full_parallel_related.c:156:	  for (k=0;k<E->parallel.nprocz;k++)
Full_parallel_related.c:157:	    fprintf(E->fp_out,"loc2proc_map[cap=%d][x=%d][y=%d][z=%d] = %d\n",
Full_parallel_related.c:158:		    m,i,j,k,E->parallel.loc2proc_map[m][i][j][k]);
Full_parallel_related.c:160:    fflush(E->fp_out);
Full_parallel_related.c:166:  E->exchange_node_d = exchange_node_d;
Full_parallel_related.c:167:  E->exchange_node_f = exchange_node_f;
Full_parallel_related.c:180:  processors = (int *) malloc((E->parallel.total_surf_proc+1)*sizeof(int));
Full_parallel_related.c:182:  k = E->parallel.me_loc[3];
Full_parallel_related.c:184:  for (m=0;m<E->sphere.caps;m++)
Full_parallel_related.c:185:    for (i=0;i<E->parallel.nprocx;i++)
Full_parallel_related.c:186:      for (j=0;j<E->parallel.nprocy;j++) {
Full_parallel_related.c:187:	processors[n] = E->parallel.loc2proc_map[m][i][j][k];
Full_parallel_related.c:191:  MPI_Comm_group(E->parallel.world, &world_g);
Full_parallel_related.c:192:  MPI_Group_incl(world_g, E->parallel.total_surf_proc, processors, &horizon_g);
Full_parallel_related.c:193:  MPI_Comm_create(E->parallel.world, horizon_g, &(E->parallel.horizontal_comm));
Full_parallel_related.c:195:  if (E->control.verbose) {
Full_parallel_related.c:196:    fprintf(E->fp_out,"horizontal group of me=%d loc3=%d\n",E->parallel.me,E->parallel.me_loc[3]);
Full_parallel_related.c:197:    for (j=0;j<E->parallel.total_surf_proc;j++) {
Full_parallel_related.c:198:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Full_parallel_related.c:200:    fflush(E->fp_out);
Full_parallel_related.c:217:  processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_parallel_related.c:219:  m = E->sphere.capid[1] - 1;  /* assume 1 cap per proc. */
Full_parallel_related.c:220:  i = E->parallel.me_loc[1];
Full_parallel_related.c:221:  j = E->parallel.me_loc[2];
Full_parallel_related.c:223:  for (k=0;k<E->parallel.nprocz;k++) {
Full_parallel_related.c:224:      processors[k] = E->parallel.loc2proc_map[m][i][j][k];
Full_parallel_related.c:227:  MPI_Comm_group(E->parallel.world, &world_g);
Full_parallel_related.c:228:  MPI_Group_incl(world_g, E->parallel.nprocz, processors, &vertical_g);
Full_parallel_related.c:229:  MPI_Comm_create(E->parallel.world, vertical_g, &(E->parallel.vertical_comm));
Full_parallel_related.c:231:  if (E->control.verbose) {
Full_parallel_related.c:232:    fprintf(E->fp_out,"vertical group of me=%d loc1=%d loc2=%d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2]);
Full_parallel_related.c:233:    for (j=0;j<E->parallel.nprocz;j++) {
Full_parallel_related.c:234:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Full_parallel_related.c:236:    fflush(E->fp_out);
Full_parallel_related.c:254:  me = E->parallel.me;
Full_parallel_related.c:256:  E->lmesh.elx = E->mesh.elx/E->parallel.nprocx;
Full_parallel_related.c:257:  E->lmesh.elz = E->mesh.elz/E->parallel.nprocz;
Full_parallel_related.c:258:  E->lmesh.ely = E->mesh.ely/E->parallel.nprocy;
Full_parallel_related.c:259:  E->lmesh.nox = E->lmesh.elx + 1;
Full_parallel_related.c:260:  E->lmesh.noz = E->lmesh.elz + 1;
Full_parallel_related.c:261:  E->lmesh.noy = E->lmesh.ely + 1;
Full_parallel_related.c:263:  E->lmesh.exs = E->parallel.me_loc[1]*E->lmesh.elx;
Full_parallel_related.c:264:  E->lmesh.eys = E->parallel.me_loc[2]*E->lmesh.ely;
Full_parallel_related.c:265:  E->lmesh.ezs = E->parallel.me_loc[3]*E->lmesh.elz;
Full_parallel_related.c:266:  E->lmesh.nxs = E->parallel.me_loc[1]*E->lmesh.elx+1;
Full_parallel_related.c:267:  E->lmesh.nys = E->parallel.me_loc[2]*E->lmesh.ely+1;
Full_parallel_related.c:268:  E->lmesh.nzs = E->parallel.me_loc[3]*E->lmesh.elz+1;
Full_parallel_related.c:270:  E->lmesh.nno = E->lmesh.noz*E->lmesh.nox*E->lmesh.noy;
Full_parallel_related.c:271:  E->lmesh.nel = E->lmesh.ely*E->lmesh.elx*E->lmesh.elz;
Full_parallel_related.c:272:  E->lmesh.npno = E->lmesh.nel;
Full_parallel_related.c:274:  E->lmesh.nsf = E->lmesh.nno/E->lmesh.noz;
Full_parallel_related.c:275:  E->lmesh.snel = E->lmesh.elx*E->lmesh.ely;
Full_parallel_related.c:277:  for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)   {
Full_parallel_related.c:279:     if (E->control.NMULTIGRID)  {
Full_parallel_related.c:280:        nox = E->lmesh.elx/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Full_parallel_related.c:281:        noy = E->lmesh.ely/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Full_parallel_related.c:282:        noz = E->lmesh.elz/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Full_parallel_related.c:283:        E->parallel.redundant[i]=0;
Full_parallel_related.c:286:        { noz = E->lmesh.noz;
Full_parallel_related.c:287:          noy = E->lmesh.noy;
Full_parallel_related.c:288:          nox = E->lmesh.nox;
Full_parallel_related.c:291:     E->lmesh.ELX[i] = nox-1;
Full_parallel_related.c:292:     E->lmesh.ELY[i] = noy-1;
Full_parallel_related.c:293:     E->lmesh.ELZ[i] = noz-1;
Full_parallel_related.c:294:     E->lmesh.NOZ[i] = noz;
Full_parallel_related.c:295:     E->lmesh.NOY[i] = noy;
Full_parallel_related.c:296:     E->lmesh.NOX[i] = nox;
Full_parallel_related.c:297:     E->lmesh.NNO[i] = nox * noz * noy;
Full_parallel_related.c:298:     E->lmesh.NNOV[i] = E->lmesh.NNO[i];
Full_parallel_related.c:299:     E->lmesh.SNEL[i] = E->lmesh.ELX[i]*E->lmesh.ELY[i];
Full_parallel_related.c:301:     E->lmesh.NEL[i] = (nox-1) * (noz-1) * (noy-1);
Full_parallel_related.c:302:     E->lmesh.NPNO[i] = E->lmesh.NEL[i] ;
Full_parallel_related.c:304:     E->lmesh.NEQ[i] = E->mesh.nsd * E->lmesh.NNOV[i] ;
Full_parallel_related.c:306:     E->lmesh.EXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i];
Full_parallel_related.c:307:     E->lmesh.EYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i];
Full_parallel_related.c:308:     E->lmesh.EZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i];
Full_parallel_related.c:309:     E->lmesh.NXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i]+1;
Full_parallel_related.c:310:     E->lmesh.NYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i]+1;
Full_parallel_related.c:311:     E->lmesh.NZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i]+1;
Full_parallel_related.c:315:fprintf(stderr,"b %d %d %d %d %d %d %d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3],E->lmesh.nzs,E->lmesh.nys,E->lmesh.noy);
Full_parallel_related.c:340:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)   {
Full_parallel_related.c:341:    for(m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:342:      nel = E->lmesh.NEL[lev];
Full_parallel_related.c:343:      elx = E->lmesh.ELX[lev];
Full_parallel_related.c:344:      elz = E->lmesh.ELZ[lev];
Full_parallel_related.c:345:      ely = E->lmesh.ELY[lev];
Full_parallel_related.c:346:      nox = E->lmesh.NOX[lev];
Full_parallel_related.c:347:      noy = E->lmesh.NOY[lev];
Full_parallel_related.c:348:      noz = E->lmesh.NOZ[lev];
Full_parallel_related.c:349:      nno = E->lmesh.NNO[lev];
Full_parallel_related.c:357:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Full_parallel_related.c:358:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:361:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:369:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Full_parallel_related.c:370:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:373:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:382:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Full_parallel_related.c:383:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:386:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:393:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Full_parallel_related.c:394:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:397:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:406:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Full_parallel_related.c:407:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:410:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:417:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Full_parallel_related.c:418:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:421:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:428:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[2];lnode++) {
Full_parallel_related.c:429:          node = E->parallel.NODE[lev][m][lnode].bound[2];
Full_parallel_related.c:430:          E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Full_parallel_related.c:433:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[3];lnode++) {
Full_parallel_related.c:434:          node = E->parallel.NODE[lev][m][lnode].bound[3];
Full_parallel_related.c:435:          E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Full_parallel_related.c:442:      if (E->sphere.capid[m] == 1 &&
Full_parallel_related.c:443:          E->parallel.me_loc[1] == 0 &&
Full_parallel_related.c:444:          E->parallel.me_loc[2] == 0)
Full_parallel_related.c:447:              E->NODE[lev][m][node] = E->NODE[lev][m][node] & ~SKIP;
Full_parallel_related.c:451:      if (E->sphere.capid[m] == E->sphere.caps &&
Full_parallel_related.c:452:          E->parallel.me_loc[1] == E->parallel.nprocx-1 &&
Full_parallel_related.c:453:          E->parallel.me_loc[2] == E->parallel.nprocy-1)
Full_parallel_related.c:456:              E->NODE[lev][m][node] = E->NODE[lev][m][node] & ~SKIP;
Full_parallel_related.c:461:      if (E->parallel.me_loc[3]!=E->parallel.nprocz-1 )
Full_parallel_related.c:462:          for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[6];lnode++) {
Full_parallel_related.c:463:              node = E->parallel.NODE[lev][m][lnode].bound[6];
Full_parallel_related.c:464:              E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Full_parallel_related.c:471:if (E->control.verbose) {
Full_parallel_related.c:472: fprintf(E->fp_out,"output_shared_nodes %d \n",E->parallel.me);
Full_parallel_related.c:473: for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Full_parallel_related.c:474:   for (m=1;m<=E->sphere.caps_per_proc;m++)      {
Full_parallel_related.c:475:    fprintf(E->fp_out,"lev=%d  me=%d capid=%d m=%d \n",lev,E->parallel.me,E->sphere.capid[m],m);
Full_parallel_related.c:477:      for (i=1;i<=E->parallel.NUM_NNO[lev][m].bound[ii];i++)
Full_parallel_related.c:478:        fprintf(E->fp_out,"ii=%d   %d %d \n",ii,i,E->parallel.NODE[lev][m][i].bound[ii]);
Full_parallel_related.c:481:    for (node=1;node<=E->lmesh.NNO[lev];node++)
Full_parallel_related.c:482:      if((E->NODE[lev][m][node] & SKIP)) {
Full_parallel_related.c:484:        fprintf(E->fp_out,"skip %d %d \n",lnode,node);
Full_parallel_related.c:487: fflush(E->fp_out);
Full_parallel_related.c:514:  const int dims=E->mesh.nsd;
Full_parallel_related.c:516:  me = E->parallel.me;
Full_parallel_related.c:517:  nprocx = E->parallel.nprocx;
Full_parallel_related.c:518:  nprocy = E->parallel.nprocy;
Full_parallel_related.c:519:  nprocz = E->parallel.nprocz;
Full_parallel_related.c:521:  tscaps = E->parallel.total_surf_proc;
Full_parallel_related.c:522:  lx = E->parallel.me_loc[1];
Full_parallel_related.c:523:  ly = E->parallel.me_loc[2];
Full_parallel_related.c:524:  lz = E->parallel.me_loc[3];
Full_parallel_related.c:527:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Full_parallel_related.c:528:    nox = E->lmesh.NOX[lev];
Full_parallel_related.c:529:    noz = E->lmesh.NOZ[lev];
Full_parallel_related.c:530:    noy = E->lmesh.NOY[lev];
Full_parallel_related.c:532:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:533:      cap = E->sphere.capid[m] - 1;  /* which cap I am in (0~11) */
Full_parallel_related.c:538:	target = E->parallel.loc2proc_map[cap][lx-1][ly][lz];
Full_parallel_related.c:542:	  target = E->parallel.loc2proc_map[temp][nprocx-1][ly][lz];
Full_parallel_related.c:546:	  target = E->parallel.loc2proc_map[temp][ly][0][lz];
Full_parallel_related.c:549:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:555:	target = E->parallel.loc2proc_map[cap][lx+1][ly][lz];
Full_parallel_related.c:559:	  target = E->parallel.loc2proc_map[temp][0][ly][lz];
Full_parallel_related.c:563:	  target = E->parallel.loc2proc_map[temp][ly][nprocy-1][lz];
Full_parallel_related.c:565:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:571:	target = E->parallel.loc2proc_map[cap][lx][ly-1][lz];
Full_parallel_related.c:575:	  target = E->parallel.loc2proc_map[temp][lx][nprocy-1][lz];
Full_parallel_related.c:579:	  target = E->parallel.loc2proc_map[temp][0][lx][lz];
Full_parallel_related.c:582:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:588:	target = E->parallel.loc2proc_map[cap][lx][ly+1][lz];
Full_parallel_related.c:592:	  target = E->parallel.loc2proc_map[temp][lx][0][lz];
Full_parallel_related.c:596:	  target = E->parallel.loc2proc_map[temp][nprocx-1][lx][lz];
Full_parallel_related.c:599:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:609:	    target = E->parallel.loc2proc_map[temp][lx][ly][lz];
Full_parallel_related.c:612:	    target = E->parallel.PROCESSOR[lev][m].pass[1] - nprocz;
Full_parallel_related.c:614:	    target = E->parallel.PROCESSOR[lev][m].pass[3] - nprocxz;
Full_parallel_related.c:616:	    target = E->parallel.PROCESSOR[lev][m].pass[1] - nprocxz;
Full_parallel_related.c:618:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:627:	    target = E->parallel.loc2proc_map[temp][lx][ly][lz];
Full_parallel_related.c:630:	    target = E->parallel.PROCESSOR[lev][m].pass[2] + nprocz;
Full_parallel_related.c:632:	    target = E->parallel.PROCESSOR[lev][m].pass[4] + nprocxz;
Full_parallel_related.c:634:	    target = E->parallel.PROCESSOR[lev][m].pass[2] + nprocxz;
Full_parallel_related.c:636:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:644:	    target = E->parallel.PROCESSOR[lev][m].pass[4] - nprocxz;
Full_parallel_related.c:646:	    target = E->parallel.PROCESSOR[lev][m].pass[1] + nprocz;
Full_parallel_related.c:648:	    target = E->parallel.PROCESSOR[lev][m].pass[1] + nprocxz;
Full_parallel_related.c:650:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:658:	    target = E->parallel.PROCESSOR[lev][m].pass[2] - nprocz;
Full_parallel_related.c:660:	    target = E->parallel.PROCESSOR[lev][m].pass[3] + nprocxz;
Full_parallel_related.c:662:	    target = E->parallel.PROCESSOR[lev][m].pass[2] - nprocxz;
Full_parallel_related.c:664:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:669:      E->parallel.TNUM_PASS[lev][m] = npass;
Full_parallel_related.c:675:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Full_parallel_related.c:678:      E->parallel.NUM_PASSz[lev].bound[ii] = 1;
Full_parallel_related.c:680:	E->parallel.NUM_PASSz[lev].bound[ii] = 0;
Full_parallel_related.c:682:	E->parallel.NUM_PASSz[lev].bound[ii] = 0;
Full_parallel_related.c:684:      for (p=1;p<=E->parallel.NUM_PASSz[lev].bound[ii];p++)  {
Full_parallel_related.c:687:	kkkp = kkk + E->sphere.max_connections;
Full_parallel_related.c:689:	E->parallel.NUM_NODEz[lev].pass[kkk] = 0;
Full_parallel_related.c:690:	E->parallel.NUM_NEQz[lev].pass[kkk] = 0;
Full_parallel_related.c:692:	for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:693:	  cap = E->sphere.capid[m] - 1;  /* which cap I am in (0~11) */
Full_parallel_related.c:694:	  E->parallel.PROCESSORz[lev].pass[kkk] =
Full_parallel_related.c:695:	    E->parallel.loc2proc_map[cap][lx][ly][lz+((ii==5)?-1:1)];
Full_parallel_related.c:698:	  for (k=1;k<=E->parallel.NUM_NNO[lev][m].bound[ii];k++)   {
Full_parallel_related.c:699:	    node = E->parallel.NODE[lev][m][k].bound[ii];
Full_parallel_related.c:700:	    E->parallel.EXCHANGE_NODE[lev][m][++kk].pass[kkkp] = node;
Full_parallel_related.c:702:	      E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkkp] =
Full_parallel_related.c:703:		E->ID[lev][m][node].doff[doff];
Full_parallel_related.c:705:	  E->parallel.NUM_NODE[lev][m].pass[kkkp] = kk;
Full_parallel_related.c:706:	  E->parallel.NUM_NEQ[lev][m].pass[kkkp] = jj;
Full_parallel_related.c:707:	  E->parallel.NUM_NODEz[lev].pass[kkk] += kk;
Full_parallel_related.c:708:	  E->parallel.NUM_NEQz[lev].pass[kkk] += jj;
Full_parallel_related.c:714:    E->parallel.TNUM_PASSz[lev] = kkk;
Full_parallel_related.c:719:  if(E->control.verbose) {
Full_parallel_related.c:720:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Full_parallel_related.c:721:      fprintf(E->fp_out,"output_communication route surface for lev=%d \n",lev);
Full_parallel_related.c:722:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Full_parallel_related.c:723:	fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",E->parallel.me,E->sphere.capid[m],E->parallel.TNUM_PASS[lev][m]);
Full_parallel_related.c:724:	for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:725:	  fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d eqn and %d node\n",E->parallel.me,k,E->parallel.PROCESSOR[lev][m].pass[k],E->parallel.NUM_NEQ[lev][m].pass[k],E->parallel.NUM_NODE[lev][m].pass[k]);
Full_parallel_related.c:726:	  fprintf(E->fp_out,"Eqn:\n");  
Full_parallel_related.c:727:	  for (ii=1;ii<=E->parallel.NUM_NEQ[lev][m].pass[k];ii++)  
Full_parallel_related.c:728:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_ID[lev][m][ii].pass[k]);  
Full_parallel_related.c:729:	  fprintf(E->fp_out,"Node:\n");  
Full_parallel_related.c:730:	  for (ii=1;ii<=E->parallel.NUM_NODE[lev][m].pass[k];ii++)  
Full_parallel_related.c:731:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_NODE[lev][m][ii].pass[k]);  
Full_parallel_related.c:735:      fprintf(E->fp_out,"output_communication route vertical \n");
Full_parallel_related.c:736:      fprintf(E->fp_out," me= %d pass  %d \n",E->parallel.me,E->parallel.TNUM_PASSz[lev]);
Full_parallel_related.c:737:      for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)   {
Full_parallel_related.c:738:	kkkp = k + E->sphere.max_connections;
Full_parallel_related.c:739:	fprintf(E->fp_out,"proc %d and pass  %d to proc %d\n",E->parallel.me,k,E->parallel.PROCESSORz[lev].pass[k]);
Full_parallel_related.c:740:	for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Full_parallel_related.c:741:	  fprintf(E->fp_out,"cap=%d eqn=%d node=%d\n",E->sphere.capid[m],E->parallel.NUM_NEQ[lev][m].pass[kkkp],E->parallel.NUM_NODE[lev][m].pass[kkkp]);
Full_parallel_related.c:742:	  for (ii=1;ii<=E->parallel.NUM_NEQ[lev][m].pass[kkkp];ii++) 
Full_parallel_related.c:743:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_ID[lev][m][ii].pass[kkkp]); 
Full_parallel_related.c:744:	  for (ii=1;ii<=E->parallel.NUM_NODE[lev][m].pass[kkkp];ii++) 
Full_parallel_related.c:745:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_NODE[lev][m][ii].pass[kkkp]); 
Full_parallel_related.c:749:    fflush(E->fp_out);
Full_parallel_related.c:771:  const int dims=E->mesh.nsd;
Full_parallel_related.c:773:  me = E->parallel.me;
Full_parallel_related.c:774:  nprocz = E->parallel.nprocz;
Full_parallel_related.c:777:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Full_parallel_related.c:778:    nox = E->lmesh.NOX[lev];
Full_parallel_related.c:779:    noz = E->lmesh.NOZ[lev];
Full_parallel_related.c:780:    noy = E->lmesh.NOY[lev];
Full_parallel_related.c:782:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:783:      j = E->sphere.capid[m];
Full_parallel_related.c:785:      for (kkk=1;kkk<=E->parallel.TNUM_PASS[lev][m];kkk++) {
Full_parallel_related.c:788:          E->parallel.NUM_sNODE[lev][m].pass[kkk] =
Full_parallel_related.c:789:                           E->parallel.NUM_NNO[lev][m].bound[ii]/noz;
Full_parallel_related.c:791:          for (k=1;k<=E->parallel.NUM_sNODE[lev][m].pass[kkk];k++)   {
Full_parallel_related.c:793:            node = (E->parallel.NODE[lev][m][lnode].bound[ii]-1)/noz + 1;
Full_parallel_related.c:794:            E->parallel.EXCHANGE_sNODE[lev][m][k].pass[kkk] = node;
Full_parallel_related.c:799:          E->parallel.NUM_sNODE[lev][m].pass[kkk]=1;
Full_parallel_related.c:801:          for (k=1;k<=E->parallel.NUM_sNODE[lev][m].pass[kkk];k++)   {
Full_parallel_related.c:802:            node = E->parallel.EXCHANGE_NODE[lev][m][k].pass[kkk]/noz + 1;
Full_parallel_related.c:803:            E->parallel.EXCHANGE_sNODE[lev][m][k].pass[kkk] = node;
Full_parallel_related.c:812:  if(E->control.verbose) {
Full_parallel_related.c:813:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Full_parallel_related.c:814:      fprintf(E->fp_out,"output_communication route surface for lev=%d \n",lev);
Full_parallel_related.c:815:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Full_parallel_related.c:816:	fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",E->parallel.me,E->sphere.capid[m],E->parallel.TNUM_PASS[lev][m]);
Full_parallel_related.c:817:	for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++) {
Full_parallel_related.c:818:	  fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d node\n",E->parallel.me,k,E->parallel.PROCESSOR[lev][m].pass[k],E->parallel.NUM_sNODE[lev][m].pass[k]);
Full_parallel_related.c:819:	  fprintf(E->fp_out,"Node:\n");
Full_parallel_related.c:820:	  for (ii=1;ii<=E->parallel.NUM_sNODE[lev][m].pass[k];ii++)
Full_parallel_related.c:821:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_sNODE[lev][m][ii].pass[k]);
Full_parallel_related.c:826:    fflush(E->fp_out);
Full_parallel_related.c:842:  const int dims=E->mesh.nsd;
Full_parallel_related.c:844:  E->parallel.NUM_NODE[lev][m].pass[npass] = E->parallel.NUM_NNO[lev][m].bound[bd];
Full_parallel_related.c:847:  for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[npass];kk++)   {
Full_parallel_related.c:848:    node = E->parallel.NODE[lev][m][kk].bound[bd];
Full_parallel_related.c:849:    E->parallel.EXCHANGE_NODE[lev][m][kk].pass[npass] = node;
Full_parallel_related.c:851:      E->parallel.EXCHANGE_ID[lev][m][++jj].pass[npass] = E->ID[lev][m][node].doff[doff];
Full_parallel_related.c:854:  E->parallel.NUM_NEQ[lev][m].pass[npass] = jj;
Full_parallel_related.c:867:  const int dims=E->mesh.nsd;
Full_parallel_related.c:869:  E->parallel.NUM_NODE[lev][m].pass[npass] = num_node;
Full_parallel_related.c:872:  for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[npass];kk++)   {
Full_parallel_related.c:874:    E->parallel.EXCHANGE_NODE[lev][m][kk].pass[npass] = node;
Full_parallel_related.c:876:      E->parallel.EXCHANGE_ID[lev][m][++jj].pass[npass] = E->ID[lev][m][node].doff[doff];
Full_parallel_related.c:879:  E->parallel.NUM_NEQ[lev][m].pass[npass] = jj;
Full_parallel_related.c:887:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:888:     for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:890:       sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Full_parallel_related.c:919: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:920:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:921:     sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Full_parallel_related.c:928: for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:929:   kk = (1+E->parallel.NUM_NEQz[lev].pass[k])*sizeof(double);
Full_parallel_related.c:936:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:937:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Full_parallel_related.c:939:      for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++) {
Full_parallel_related.c:940:        S[k][j-1] = U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ];
Full_parallel_related.c:943:      if (E->parallel.PROCESSOR[lev][m].pass[k] != E->parallel.me &&
Full_parallel_related.c:944:	  E->parallel.PROCESSOR[lev][m].pass[k] != -1) {
Full_parallel_related.c:946:          MPI_Isend(S[k], E->parallel.NUM_NEQ[lev][m].pass[k], MPI_DOUBLE,
Full_parallel_related.c:947:		    E->parallel.PROCESSOR[lev][m].pass[k], 1,
Full_parallel_related.c:948:		    E->parallel.world, &request[idb-1]);
Full_parallel_related.c:953:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:954:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:956:      if (E->parallel.PROCESSOR[lev][m].pass[k] != E->parallel.me &&
Full_parallel_related.c:957:	  E->parallel.PROCESSOR[lev][m].pass[k] != -1) {
Full_parallel_related.c:959:	 MPI_Irecv(R[k],E->parallel.NUM_NEQ[lev][m].pass[k], MPI_DOUBLE,
Full_parallel_related.c:960:		   E->parallel.PROCESSOR[lev][m].pass[k], 1,
Full_parallel_related.c:961:		   E->parallel.world, &request[idb-1]);
Full_parallel_related.c:964:	for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Full_parallel_related.c:965:           U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ] += S[k][j-1];
Full_parallel_related.c:972:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:973:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:975:      if (E->parallel.PROCESSOR[lev][m].pass[k] != E->parallel.me &&
Full_parallel_related.c:976:	  E->parallel.PROCESSOR[lev][m].pass[k] != -1) {
Full_parallel_related.c:977:	for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Full_parallel_related.c:978:	  U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ] += R[k][j-1];
Full_parallel_related.c:985:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:987:    kk = k + E->sphere.max_connections;
Full_parallel_related.c:989:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:990:      for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[kk];j++)
Full_parallel_related.c:991:        SV[jj++] = U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[kk] ];
Full_parallel_related.c:993:    MPI_Sendrecv(SV, E->parallel.NUM_NEQz[lev].pass[k], MPI_DOUBLE,
Full_parallel_related.c:994:		 E->parallel.PROCESSORz[lev].pass[k], 1,
Full_parallel_related.c:995:                 RV, E->parallel.NUM_NEQz[lev].pass[k], MPI_DOUBLE,
Full_parallel_related.c:996:		 E->parallel.PROCESSORz[lev].pass[k], 1,
Full_parallel_related.c:997:		 E->parallel.world, &status1);
Full_parallel_related.c:1000:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:1001:      for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[kk];j++)
Full_parallel_related.c:1002:        U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[kk] ] += RV[jj++];
Full_parallel_related.c:1005: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:1006:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:1036: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:1037:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:1039:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(double);
Full_parallel_related.c:1046: for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:1047:   sizeofk = (1+E->parallel.NUM_NODEz[lev].pass[k])*sizeof(double);
Full_parallel_related.c:1055:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:1056:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Full_parallel_related.c:1059:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:1060:        S[kk][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Full_parallel_related.c:1062:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me) {
Full_parallel_related.c:1063:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:1065:        MPI_Isend(S[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Full_parallel_related.c:1066:             E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:1072:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:1073:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:1076:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)  {
Full_parallel_related.c:1077:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:1079:         MPI_Irecv(R[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Full_parallel_related.c:1080:         E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:1086:         for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:1087:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += S[kk][j-1];
Full_parallel_related.c:1094:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:1095:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:1098:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)
Full_parallel_related.c:1099:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:1100:        for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:1101:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[kk][j-1];
Full_parallel_related.c:1108:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:1110:    kk = k + E->sphere.max_connections;
Full_parallel_related.c:1112:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:1113:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Full_parallel_related.c:1114:        SV[jj++] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ];
Full_parallel_related.c:1116:    MPI_Sendrecv(SV,E->parallel.NUM_NODEz[lev].pass[k],MPI_DOUBLE,
Full_parallel_related.c:1117:             E->parallel.PROCESSORz[lev].pass[k],1,
Full_parallel_related.c:1118:                 RV,E->parallel.NUM_NODEz[lev].pass[k],MPI_DOUBLE,
Full_parallel_related.c:1119:             E->parallel.PROCESSORz[lev].pass[k],1,E->parallel.world,&status1);
Full_parallel_related.c:1122:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:1123:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Full_parallel_related.c:1124:        U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ] += RV[jj++];
Full_parallel_related.c:1128: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:1129:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:1161: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:1162:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:1164:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(float);
Full_parallel_related.c:1171: for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:1172:   sizeofk = (1+E->parallel.NUM_NODEz[lev].pass[k])*sizeof(float);
Full_parallel_related.c:1180:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:1181:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Full_parallel_related.c:1184:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:1185:        S[kk][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Full_parallel_related.c:1187:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me) {
Full_parallel_related.c:1188:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:1190:        MPI_Isend(S[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Full_parallel_related.c:1191:             E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:1197:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:1198:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:1201:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)  {
Full_parallel_related.c:1202:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:1204:         MPI_Irecv(R[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Full_parallel_related.c:1205:         E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:1211:         for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:1212:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += S[kk][j-1];
Full_parallel_related.c:1219:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:1220:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:1223:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)
Full_parallel_related.c:1224:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:1225:        for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:1226:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[kk][j-1];
Full_parallel_related.c:1233:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:1235:    kk = k + E->sphere.max_connections;
Full_parallel_related.c:1237:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:1238:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Full_parallel_related.c:1239:        SV[jj++] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ];
Full_parallel_related.c:1241:    MPI_Sendrecv(SV,E->parallel.NUM_NODEz[lev].pass[k],MPI_FLOAT,
Full_parallel_related.c:1242:             E->parallel.PROCESSORz[lev].pass[k],1,
Full_parallel_related.c:1243:                 RV,E->parallel.NUM_NODEz[lev].pass[k],MPI_FLOAT,
Full_parallel_related.c:1244:             E->parallel.PROCESSORz[lev].pass[k],1,E->parallel.world,&status1);
Full_parallel_related.c:1247:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:1248:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Full_parallel_related.c:1249:        U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ] += RV[jj++];
Full_parallel_related.c:1253: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:1254:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:1282:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:1283:     for (k=1;k<=E->parallel.TNUM_PASS[E->mesh.levmax][m];k++)  {
Full_parallel_related.c:1285:       sizeofk = (1+2*E->parallel.NUM_sNODE[E->mesh.levmax][m].pass[k])*sizeof(float);
Full_parallel_related.c:1293:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:1294:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Full_parallel_related.c:1298:      for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)  {
Full_parallel_related.c:1299:        S[kk][j-1] = U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Full_parallel_related.c:1300:        S[kk][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]]
Full_parallel_related.c:1301:                   = U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Full_parallel_related.c:1304:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me) {
Full_parallel_related.c:1305:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:1307:         MPI_Isend(S[kk],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Full_parallel_related.c:1308:             E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:1315:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:1316:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:1319:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)  {
Full_parallel_related.c:1320:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:1323:         MPI_Irecv(R[kk],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Full_parallel_related.c:1324:           E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:1330:         for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)     {
Full_parallel_related.c:1331:           U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] += S[kk][j-1];
Full_parallel_related.c:1332:           U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] +=
Full_parallel_related.c:1333:                               S[kk][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]];
Full_parallel_related.c:1341:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:1342:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:1346:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)
Full_parallel_related.c:1347:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:1348:        for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)    {
Full_parallel_related.c:1349:           U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] += R[kk][j-1];
Full_parallel_related.c:1350:           U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] +=
Full_parallel_related.c:1351:                              R[kk][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]];
Full_parallel_related.c:1358:  for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:1359:    for (k=1;k<=E->parallel.TNUM_PASS[E->mesh.levmax][m];k++)  {
Full_read_input_from_files.c:57:    const int dims=E->mesh.nsd;
Full_read_input_from_files.c:66:    nox=E->mesh.nox;
Full_read_input_from_files.c:67:    noy=E->mesh.noy;
Full_read_input_from_files.c:68:    noz=E->mesh.noz;
Full_read_input_from_files.c:69:    nox1=E->lmesh.nox;
Full_read_input_from_files.c:70:    noz1=E->lmesh.noz;
Full_read_input_from_files.c:71:    noy1=E->lmesh.noy;
Full_read_input_from_files.c:73:    elx=E->lmesh.elx;
Full_read_input_from_files.c:74:    elz=E->lmesh.elz;
Full_read_input_from_files.c:75:    ely=E->lmesh.ely;
Full_read_input_from_files.c:77:    emax=E->mesh.elx*E->mesh.elz*E->mesh.ely;
Full_read_input_from_files.c:93:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Full_read_input_from_files.c:94:      cap = E->sphere.capid[m] - 1;  /* capid: 1-12 */
Full_read_input_from_files.c:100:	if(!E->control.ggrd.vtop_control){
Full_read_input_from_files.c:102:	sprintf(output_file1,"%s%0.0f.%d",E->control.velocity_boundary_file,newage1,cap);
Full_read_input_from_files.c:103:	sprintf(output_file2,"%s%0.0f.%d",E->control.velocity_boundary_file,newage2,cap);
Full_read_input_from_files.c:106:          fprintf(E->fp,"(Problem_related #4) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:112:	    fprintf(E->fp,"(Problem_related #5) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:116:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:117:	  fprintf(E->fp,"Velocity: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:118:	  fprintf(E->fp,"Velocity: File1 = %s\n",output_file1);
Full_read_input_from_files.c:120:	    fprintf(E->fp,"Velocity: File2 = %s\n",output_file2);
Full_read_input_from_files.c:122:	    fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:131:	if(!E->control.ggrd.age_control){
Full_read_input_from_files.c:133:	sprintf(output_file1,"%s%0.0f.%d",E->control.lith_age_file,newage1,cap);
Full_read_input_from_files.c:134:	sprintf(output_file2,"%s%0.0f.%d",E->control.lith_age_file,newage2,cap);
Full_read_input_from_files.c:137:          fprintf(E->fp,"(Problem_related #6) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:143:	    fprintf(E->fp,"(Problem_related #7) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:147:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:148:	  fprintf(E->fp,"Age: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:149:	  fprintf(E->fp,"Age: File1 = %s\n",output_file1);
Full_read_input_from_files.c:151:	    fprintf(E->fp,"Age: File2 = %s\n",output_file2);
Full_read_input_from_files.c:153:	    fprintf(E->fp,"Age: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:162:	if(E->control.ggrd.mat_control == 0){
Full_read_input_from_files.c:164:	sprintf(output_file1,"%s%0.0f.%d",E->control.mat_file,newage1,cap);
Full_read_input_from_files.c:165:	sprintf(output_file2,"%s%0.0f.%d",E->control.mat_file,newage2,cap);
Full_read_input_from_files.c:168:          fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:174:	    fprintf(E->fp,"(Problem_related #9) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:178:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:179:	  fprintf(E->fp,"Mat: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:180:	  fprintf(E->fp,"Mat: File1 = %s\n",output_file1);
Full_read_input_from_files.c:182:	    fprintf(E->fp,"Mat: File2 = %s\n",output_file2);
Full_read_input_from_files.c:184:	    fprintf(E->fp,"Mat: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:193:	sprintf(output_file1,"%s%0.0f.%d",E->control.temperature_boundary_file,newage1,cap);
Full_read_input_from_files.c:194:	sprintf(output_file2,"%s%0.0f.%d",E->control.temperature_boundary_file,newage2,cap);
Full_read_input_from_files.c:197:          fprintf(E->fp,"(Problem_related #10) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:203:	    fprintf(E->fp,"(Problem_related #11) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:207:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:208:	  fprintf(E->fp,"Surface Temperature: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:209:	  fprintf(E->fp,"Surface Temperature: File1 = %s\n",output_file1);
Full_read_input_from_files.c:211:	    fprintf(E->fp,"Surface Temperature: File2 = %s\n",output_file2);
Full_read_input_from_files.c:213:	    fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:225:	if(!E->control.ggrd.vtop_control){ /* grd control is called from boundary conditions subroutine */
Full_read_input_from_files.c:237:	  VB1[1][i] *= E->data.timedir;
Full_read_input_from_files.c:238:	  VB1[2][i] *= E->data.timedir;
Full_read_input_from_files.c:244:	    VB2[1][i] *= E->data.timedir;
Full_read_input_from_files.c:245:	    VB2[2][i] *= E->data.timedir;
Full_read_input_from_files.c:247:	  /* if( E->parallel.me ==0)
Full_read_input_from_files.c:253:	if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Full_read_input_from_files.c:256:	      nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Full_read_input_from_files.c:259:		E->sphere.cap[m].VB[1][nodel] = (VB1[1][nodeg] + (VB2[1][nodeg]-VB1[1][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Full_read_input_from_files.c:260:		E->sphere.cap[m].VB[2][nodel] = (VB1[2][nodeg] + (VB2[2][nodeg]-VB1[2][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Full_read_input_from_files.c:261:		E->sphere.cap[m].VB[3][nodel] = 0.0;
Full_read_input_from_files.c:264:		E->sphere.cap[m].VB[1][nodel] = VB1[1][nodeg] * E->data.scalev;
Full_read_input_from_files.c:265:		E->sphere.cap[m].VB[2][nodel] = VB1[2][nodeg] * E->data.scalev;
Full_read_input_from_files.c:266:		E->sphere.cap[m].VB[3][nodel] = 0.0;
Full_read_input_from_files.c:269:	}   /* end of E->parallel.me_loc[3]==E->parallel.nproczl-1   */
Full_read_input_from_files.c:281:	if(E->control.ggrd.age_control){
Full_read_input_from_files.c:297:              E->age_t[node] = (inputage1 + (inputage2-inputage1)/(newage2-newage1)*(age-newage1))/E->data.scalet;
Full_read_input_from_files.c:300:              E->age_t[node] = inputage1;
Full_read_input_from_files.c:312:	if(E->control.ggrd.mat_control != 0){ /* use netcdf grids */
Full_read_input_from_files.c:322:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_read_input_from_files.c:324:            nodea = E->ien[m][el].node[2];
Full_read_input_from_files.c:327:              E->mat[m][el] = llayer;
Full_read_input_from_files.c:345:          for (m=1;m<=E->sphere.caps_per_proc;m++) {
Full_read_input_from_files.c:349:                  el = j + (i-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Full_read_input_from_files.c:350:                  elg = E->lmesh.ezs+j + (E->lmesh.exs+i-1)*E->mesh.elz + (E->lmesh.eys+k-1)*E->mesh.elz*E->mesh.elx;
Full_read_input_from_files.c:352:                  E->VIP[m][el] = VIP1[elg]+(VIP2[elg]-VIP1[elg])/(newage2-newage1)*(age-newage1);
Full_read_input_from_files.c:353:                  /* E->mat[m][el] = LL1[elg]; */ /*get material numbers from radius internally */
Full_read_input_from_files.c:372:	if(E->control.ggrd.ray_control)
Full_read_input_from_files.c:399:	if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Full_read_input_from_files.c:402:	      nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Full_read_input_from_files.c:405:		E->sphere.cap[m].TB[1][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Full_read_input_from_files.c:406:		E->sphere.cap[m].TB[2][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Full_read_input_from_files.c:407:		E->sphere.cap[m].TB[3][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Full_read_input_from_files.c:410:		E->sphere.cap[m].TB[1][nodel] = TB1[nodeg];
Full_read_input_from_files.c:411:		E->sphere.cap[m].TB[2][nodel] = TB1[nodeg];
Full_read_input_from_files.c:412:		E->sphere.cap[m].TB[3][nodel] = TB1[nodeg];
Full_read_input_from_files.c:415:	}   /* end of E->parallel.me_loc[3]==E->parallel.nproczl-1   */
Full_read_input_from_files.c:423:    fflush(E->fp);
Full_solver.c:65:    E->solver.velocity_boundary_conditions = full_velocity_boundary_conditions;
Full_solver.c:66:    E->solver.temperature_boundary_conditions = full_temperature_boundary_conditions;
Full_solver.c:69:    E->solver.set_2dc_defaults = full_set_2dc_defaults;
Full_solver.c:70:    E->solver.set_2pt5dc_defaults = full_set_2pt5dc_defaults;
Full_solver.c:71:    E->solver.set_3dc_defaults = full_set_3dc_defaults;
Full_solver.c:72:    E->solver.set_3dsphere_defaults = full_set_3dsphere_defaults;
Full_solver.c:75:    E->solver.lith_age_read_files = full_lith_age_read_files;
Full_solver.c:78:    E->solver.parallel_processor_setup = full_parallel_processor_setup;
Full_solver.c:79:    E->solver.parallel_domain_decomp0 = full_parallel_domain_decomp0;
Full_solver.c:80:    E->solver.parallel_domain_boundary_nodes = full_parallel_domain_boundary_nodes;
Full_solver.c:81:    E->solver.parallel_communication_routs_v = full_parallel_communication_routs_v;
Full_solver.c:82:    E->solver.parallel_communication_routs_s = full_parallel_communication_routs_s;
Full_solver.c:83:    E->solver.exchange_id_d = full_exchange_id_d;
Full_solver.c:86:    E->solver.read_input_files_for_timesteps = full_read_input_files_for_timesteps;
Full_solver.c:89:    E->solver.node_locations = full_node_locations;
Full_solver.c:90:    E->solver.construct_boundary = full_construct_boundary;
Full_sphere_related.c:175:  temp = max(E->mesh.noy, E->mesh.nox);
Full_sphere_related.c:200:  temp = E->mesh.noy * E->mesh.nox;
Full_sphere_related.c:213:    E->sphere.cap[(i-1)*3+1].theta[1] = 0.0;
Full_sphere_related.c:214:    E->sphere.cap[(i-1)*3+1].theta[2] = M_PI/4.0+offset;
Full_sphere_related.c:215:    E->sphere.cap[(i-1)*3+1].theta[3] = M_PI/2.0;
Full_sphere_related.c:216:    E->sphere.cap[(i-1)*3+1].theta[4] = M_PI/4.0+offset;
Full_sphere_related.c:217:    E->sphere.cap[(i-1)*3+1].fi[1] = 0.0;
Full_sphere_related.c:218:    E->sphere.cap[(i-1)*3+1].fi[2] = (i-1)*M_PI/2.0;
Full_sphere_related.c:219:    E->sphere.cap[(i-1)*3+1].fi[3] = (i-1)*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:220:    E->sphere.cap[(i-1)*3+1].fi[4] = i*M_PI/2.0;
Full_sphere_related.c:222:    E->sphere.cap[(i-1)*3+2].theta[1] = M_PI/4.0+offset;
Full_sphere_related.c:223:    E->sphere.cap[(i-1)*3+2].theta[2] = M_PI/2.0;
Full_sphere_related.c:224:    E->sphere.cap[(i-1)*3+2].theta[3] = 3*M_PI/4.0-offset;
Full_sphere_related.c:225:    E->sphere.cap[(i-1)*3+2].theta[4] = M_PI/2.0;
Full_sphere_related.c:226:    E->sphere.cap[(i-1)*3+2].fi[1] = i*M_PI/2.0;
Full_sphere_related.c:227:    E->sphere.cap[(i-1)*3+2].fi[2] = i*M_PI/2.0 - M_PI/4.0;
Full_sphere_related.c:228:    E->sphere.cap[(i-1)*3+2].fi[3] = i*M_PI/2.0;
Full_sphere_related.c:229:    E->sphere.cap[(i-1)*3+2].fi[4] = i*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:235:    E->sphere.cap[j].theta[1] = M_PI/2.0;
Full_sphere_related.c:236:    E->sphere.cap[j].theta[2] = 3*M_PI/4.0-offset;
Full_sphere_related.c:237:    E->sphere.cap[j].theta[3] = M_PI;
Full_sphere_related.c:238:    E->sphere.cap[j].theta[4] = 3*M_PI/4.0-offset;
Full_sphere_related.c:239:    E->sphere.cap[j].fi[1] = (i-1)*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:240:    E->sphere.cap[j].fi[2] = (i-1)*M_PI/2.0;
Full_sphere_related.c:241:    E->sphere.cap[j].fi[3] = 0.0;
Full_sphere_related.c:242:    E->sphere.cap[j].fi[4] = i*M_PI/2.0;
Full_sphere_related.c:255:    x[i] = E->data.ra * sin(E->sphere.cap[icap].theta[i])*cos(E->sphere.cap[icap].fi[i]);
Full_sphere_related.c:256:    y[i] = E->data.ra * sin(E->sphere.cap[icap].theta[i])*sin(E->sphere.cap[icap].fi[i]);
Full_sphere_related.c:257:    z[i] = E->data.rc * cos(E->sphere.cap[icap].theta[i]);
Full_sphere_related.c:266:    x[i] = sin(E->sphere.cap[icap].theta[i])*cos(E->sphere.cap[icap].fi[i]);
Full_sphere_related.c:267:    y[i] = sin(E->sphere.cap[icap].theta[i])*sin(E->sphere.cap[icap].fi[i]);
Full_sphere_related.c:268:    z[i] = cos(E->sphere.cap[icap].theta[i]);
Full_sphere_related.c:287:  lev = E->mesh.levmax;
Full_sphere_related.c:290:     elx = E->lmesh.ELX[lev]*E->parallel.nprocx;
Full_sphere_related.c:291:     ely = E->lmesh.ELY[lev]*E->parallel.nprocy;
Full_sphere_related.c:294:     lelx = E->lmesh.ELX[lev];
Full_sphere_related.c:295:     lely = E->lmesh.ELY[lev];
Full_sphere_related.c:303:     for (j=0, i=E->lmesh.nxs; j<lnox; j++, i++) {
Full_sphere_related.c:312:     for (j=0, i=E->lmesh.nxs; j<lnox; j++, i++) {
Full_sphere_related.c:321:     for (k=0, i=E->lmesh.nys; k<lnoy; k++, i++) {
Full_sphere_related.c:330:     for (k=0, i=E->lmesh.nys; k<lnoy; k++, i++) {
Full_sphere_related.c:361:                 fprintf(stderr, "Error(Full_coord_of_cap): cannot find intersection point! rank=%d, nx=%d, ny=%d\n", E->parallel.me, j, k);
Full_sphere_related.c:376:     if(E->parallel.me_loc[2] == 0) {
Full_sphere_related.c:385:     if(E->parallel.me_loc[2] == E->parallel.nprocy-1) {
Full_sphere_related.c:394:     if(E->parallel.me_loc[1] == 0) {
Full_sphere_related.c:403:     if(E->parallel.me_loc[1] == E->parallel.nprocx-1) {
Full_sphere_related.c:414:     efac2 = E->data.ellipticity*(2.0 - E->data.ellipticity)/
Full_sphere_related.c:415:       ((1.- E->data.ellipticity)*(1.-E->data.ellipticity));
Full_sphere_related.c:417:     for (lev=E->mesh.levmax, step=1; lev>=E->mesh.levmin; lev--, step*=2) {
Full_sphere_related.c:420:       lvnox = E->lmesh.NOX[lev];
Full_sphere_related.c:421:       lvnoy = E->lmesh.NOY[lev];
Full_sphere_related.c:422:       lvnoz = E->lmesh.NOZ[lev];
Full_sphere_related.c:432:	   rfac = E->data.ra*1./sqrt(1.0+efac2*cost*cost);
Full_sphere_related.c:439:	     E->SX[lev][m][1][node] = theta;
Full_sphere_related.c:440:	     E->SX[lev][m][2][node] = fi;
Full_sphere_related.c:441:	     E->SX[lev][m][3][node] = rfac * E->sphere.R[lev][i];
Full_sphere_related.c:444:	     E->X[lev][m][1][node] = E->data.ra * E->sphere.R[lev][i]*sint*cosf;
Full_sphere_related.c:445:	     E->X[lev][m][2][node] = E->data.ra * E->sphere.R[lev][i]*sint*sinf;
Full_sphere_related.c:446:	     E->X[lev][m][3][node] = E->data.rc * E->sphere.R[lev][i]*cost;
Full_sphere_related.c:455:     for (lev=E->mesh.levmax, step=1; lev>=E->mesh.levmin; lev--, step*=2) {
Full_sphere_related.c:458:       lvnox = E->lmesh.NOX[lev];
Full_sphere_related.c:459:       lvnoy = E->lmesh.NOY[lev];
Full_sphere_related.c:460:       lvnoz = E->lmesh.NOZ[lev];
Full_sphere_related.c:475:	     E->SX[lev][m][1][node] = theta;
Full_sphere_related.c:476:	     E->SX[lev][m][2][node] = fi;
Full_sphere_related.c:477:	     E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Full_sphere_related.c:480:	     E->X[lev][m][1][node]  = E->sphere.R[lev][i]*sint*cosf;
Full_sphere_related.c:481:	     E->X[lev][m][2][node]  = E->sphere.R[lev][i]*sint*sinf;
Full_sphere_related.c:482:	     E->X[lev][m][3][node]  = E->sphere.R[lev][i]*cost;
Full_tracer_advection.c:101:    int m = E->parallel.me;
Full_tracer_advection.c:108:    E->trace.deltheta[0]=1.0;
Full_tracer_advection.c:109:    E->trace.delphi[0]=1.0;
Full_tracer_advection.c:110:    input_double("regular_grid_deltheta",&(E->trace.deltheta[0]),"1.0",m);
Full_tracer_advection.c:111:    input_double("regular_grid_delphi",&(E->trace.delphi[0]),"1.0",m);
Full_tracer_advection.c:116:    E->trace.ianalytical_tracer_test=0;
Full_tracer_advection.c:117:    /* input_int("analytical_tracer_test",&(E->trace.ianalytical_tracer_test),
Full_tracer_advection.c:137:    if (E->sphere.caps_per_proc>1) {
Full_tracer_advection.c:145:    sprintf(output_file,"%s.tracer_log.%d",E->control.data_file,E->parallel.me);
Full_tracer_advection.c:146:    E->trace.fpt=fopen(output_file,"w");
Full_tracer_advection.c:151:    E->trace.istat_isend=0;
Full_tracer_advection.c:152:    E->trace.istat_iempty=0;
Full_tracer_advection.c:153:    E->trace.istat_elements_checked=0;
Full_tracer_advection.c:154:    E->trace.istat1=0;
Full_tracer_advection.c:159:    E->trace.box_cushion=0.00001;
Full_tracer_advection.c:164:    E->trace.number_of_basic_quantities=12;
Full_tracer_advection.c:169:    E->trace.number_of_extra_quantities = 0;
Full_tracer_advection.c:170:    if (E->trace.nflavors > 0)
Full_tracer_advection.c:171:        E->trace.number_of_extra_quantities += 1;
Full_tracer_advection.c:174:    E->trace.number_of_tracer_quantities =
Full_tracer_advection.c:175:        E->trace.number_of_basic_quantities +
Full_tracer_advection.c:176:        E->trace.number_of_extra_quantities;
Full_tracer_advection.c:187:    if (E->trace.number_of_basic_quantities>99) {
Full_tracer_advection.c:188:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of basic in tracer_defs.h\n");
Full_tracer_advection.c:189:        fflush(E->trace.fpt);
Full_tracer_advection.c:192:    if (E->trace.number_of_extra_quantities>99) {
Full_tracer_advection.c:193:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of extraq in tracer_defs.h\n");
Full_tracer_advection.c:194:        fflush(E->trace.fpt);
Full_tracer_advection.c:197:    if (E->trace.number_of_tracer_quantities>99) {
Full_tracer_advection.c:198:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of rlater in tracer_defs.h\n");
Full_tracer_advection.c:199:        fflush(E->trace.fpt);
Full_tracer_advection.c:219:    if (E->trace.ianalytical_tracer_test==1) {
Full_tracer_advection.c:225:    if (E->composition.on)
Full_tracer_advection.c:228:    fprintf(E->trace.fpt, "Tracer intiailization takes %f seconds.\n",
Full_tracer_advection.c:247:    /* This code works only if E->sphere.caps_per_proc==1 */
Full_tracer_advection.c:298:    int lev=E->mesh.levmax;
Full_tracer_advection.c:299:    int num_ngb = E->parallel.TNUM_PASS[lev][j];
Full_tracer_advection.c:311:    if(E->control.verbose)
Full_tracer_advection.c:312:      fprintf(E->trace.fpt, "Entering lost_souls()\n");
Full_tracer_advection.c:315:    E->trace.istat_isend=E->trace.ilater[j];
Full_tracer_advection.c:317:    for (kk=1; kk<=E->trace.istat_isend; kk++) {
Full_tracer_advection.c:318:        fprintf(E->trace.fpt, "tracer#=%d xx=(%g,%g,%g)\n", kk,
Full_tracer_advection.c:319:                E->trace.rlater[j][0][kk],
Full_tracer_advection.c:320:                E->trace.rlater[j][1][kk],
Full_tracer_advection.c:321:                E->trace.rlater[j][2][kk]);
Full_tracer_advection.c:323:    fflush(E->trace.fpt);
Full_tracer_advection.c:330:    isize[j]=E->trace.ilater[j]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:340:            fprintf(E->trace.fpt,"Error(lost souls)-no memory (u389)\n");
Full_tracer_advection.c:341:            fflush(E->trace.fpt);
Full_tracer_advection.c:348:    ithiscap=E->sphere.capid[j];
Full_tracer_advection.c:350:        ithatcap=E->parallel.PROCESSOR[lev][j].pass[kk];
Full_tracer_advection.c:351:        fprintf(E->trace.fpt,"cap: %d me %d TNUM: %d rank: %d\n",
Full_tracer_advection.c:352:                ithiscap,E->parallel.me,kk,ithatcap);
Full_tracer_advection.c:355:    fflush(E->trace.fpt);
Full_tracer_advection.c:373:    if (E->parallel.nprocz>1) {
Full_tracer_advection.c:378:        idestination_proc=E->parallel.PROCESSOR[lev][j].pass[kk];
Full_tracer_advection.c:381:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:384:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:396:	  isource_proc=E->parallel.me;
Full_tracer_advection.c:398:	  isource_proc=E->parallel.PROCESSOR[lev][j].pass[kk];
Full_tracer_advection.c:400:	fprintf(E->trace.fpt,"%d send %d to proc %d\n",
Full_tracer_advection.c:401:		E->parallel.me,isend[j][kk],isource_proc);
Full_tracer_advection.c:402:	fprintf(E->trace.fpt,"%d recv %d from proc %d\n",
Full_tracer_advection.c:403:		E->parallel.me,ireceive[j][kk],isource_proc);
Full_tracer_advection.c:410:        isize[j]=ireceive[j][ithatcap]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:415:            fprintf(E->trace.fpt,"Error(lost souls)-no memory (c721)\n");
Full_tracer_advection.c:416:            fflush(E->trace.fpt);
Full_tracer_advection.c:428:    if (E->parallel.nprocz>1) {
Full_tracer_advection.c:431:        isize[j]=isend[j][ithatcap]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:441:        idestination_proc=E->parallel.PROCESSOR[lev][j].pass[kk];
Full_tracer_advection.c:443:        isize[j]=isend[j][kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:446:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:448:        isize[j]=ireceive[j][kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:451:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:478:    isize[j]=isum[j]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:481:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (g323)\n");
Full_tracer_advection.c:482:        fflush(E->trace.fpt);
Full_tracer_advection.c:498:            ipos=pp*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:500:            for (mm=0;mm<E->trace.number_of_tracer_quantities;mm++) {
Full_tracer_advection.c:516:    if (E->parallel.nprocz>1) {
Full_tracer_advection.c:522:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:523:            isize[j]=itracers_subject_to_vertical_transport[j]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:527:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (c721)\n");
Full_tracer_advection.c:528:                fflush(E->trace.fpt);
Full_tracer_advection.c:534:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:536:            ithat_processor=E->parallel.PROCESSORz[lev].pass[ivertical_neighbor];
Full_tracer_advection.c:549:                ireceive_position=it*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:564:                    isend_position=isend_z[j][ivertical_neighbor]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:567:                    ilast_receiver_position=(irec[j]-1)*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:569:                    for (mm=0;mm<=(E->trace.number_of_tracer_quantities-1);mm++) {
Full_tracer_advection.c:598:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:600:            idestination_proc = E->parallel.PROCESSORz[lev].pass[kk];
Full_tracer_advection.c:602:                      14,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:605:                      14,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:615:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:616:            fprintf(E->trace.fpt, "PROC: %d IVN: %d (P: %d) "
Full_tracer_advection.c:618:                    E->parallel.me,kk,E->parallel.PROCESSORz[lev].pass[kk],
Full_tracer_advection.c:621:        fflush(E->trace.fpt);
Full_tracer_advection.c:628:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:629:            isize[j]=ireceive_z[j][kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:633:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (t590)\n");
Full_tracer_advection.c:634:                fflush(E->trace.fpt);
Full_tracer_advection.c:642:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:644:            idestination_proc = E->parallel.PROCESSORz[lev].pass[kk];
Full_tracer_advection.c:646:            isize_send=isend_z[j][kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:649:                      15,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:651:            isize_receive=ireceive_z[j][kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:654:                      15,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:667:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:673:        isize[j]=isum[j]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:677:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (i981)\n");
Full_tracer_advection.c:678:                fprintf(E->trace.fpt,"isize: %d\n",isize[j]);
Full_tracer_advection.c:679:                fflush(E->trace.fpt);
Full_tracer_advection.c:685:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:689:                irec_position=irec[j]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:691:                ireceive_position=kk*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:693:                for (mm=0;mm<E->trace.number_of_tracer_quantities;mm++) {
Full_tracer_advection.c:701:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:714:        E->trace.ntracers[j]++;
Full_tracer_advection.c:716:        if (E->trace.ntracers[j]>(E->trace.max_ntracers[j]-5)) expand_tracer_arrays(E,j);
Full_tracer_advection.c:718:        ireceive_position=kk*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:720:        for (mm=0;mm<E->trace.number_of_basic_quantities;mm++) {
Full_tracer_advection.c:723:            E->trace.basicq[j][mm][E->trace.ntracers[j]]=REC[j][ipos];
Full_tracer_advection.c:725:        for (mm=0;mm<E->trace.number_of_extra_quantities;mm++) {
Full_tracer_advection.c:726:            ipos=ireceive_position+E->trace.number_of_basic_quantities+mm;
Full_tracer_advection.c:728:            E->trace.extraq[j][mm][E->trace.ntracers[j]]=REC[j][ipos];
Full_tracer_advection.c:731:        theta=E->trace.basicq[j][0][E->trace.ntracers[j]];
Full_tracer_advection.c:732:        phi=E->trace.basicq[j][1][E->trace.ntracers[j]];
Full_tracer_advection.c:733:        rad=E->trace.basicq[j][2][E->trace.ntracers[j]];
Full_tracer_advection.c:734:        x=E->trace.basicq[j][3][E->trace.ntracers[j]];
Full_tracer_advection.c:735:        y=E->trace.basicq[j][4][E->trace.ntracers[j]];
Full_tracer_advection.c:736:        z=E->trace.basicq[j][5][E->trace.ntracers[j]];
Full_tracer_advection.c:739:        iel=(E->trace.iget_element)(E,j,-99,x,y,z,theta,phi,rad);
Full_tracer_advection.c:742:            fprintf(E->trace.fpt,"Error(lost souls) - element not here?\n");
Full_tracer_advection.c:743:            fprintf(E->trace.fpt,"x,y,z-theta,phi,rad: %f %f %f - %f %f %f\n",x,y,z,theta,phi,rad);
Full_tracer_advection.c:744:            fflush(E->trace.fpt);
Full_tracer_advection.c:748:        E->trace.ielement[j][E->trace.ntracers[j]]=iel;
Full_tracer_advection.c:751:    if(E->control.verbose){
Full_tracer_advection.c:752:      fprintf(E->trace.fpt,"Freeing memory in lost_souls()\n");
Full_tracer_advection.c:753:      fflush(E->trace.fpt);
Full_tracer_advection.c:766:    if(E->control.verbose){
Full_tracer_advection.c:767:      fprintf(E->trace.fpt,"Leaving lost_souls()\n");
Full_tracer_advection.c:768:      fflush(E->trace.fpt);
Full_tracer_advection.c:771:    E->trace.lost_souls_time += CPU_time0() - begin_time;
Full_tracer_advection.c:783:    int lev = E->mesh.levmax;
Full_tracer_advection.c:789:    numtracers=E->trace.ilater[j];
Full_tracer_advection.c:792:        rad=E->trace.rlater[j][2][kk];
Full_tracer_advection.c:793:        x=E->trace.rlater[j][3][kk];
Full_tracer_advection.c:794:        y=E->trace.rlater[j][4][kk];
Full_tracer_advection.c:795:        z=E->trace.rlater[j][5][kk];
Full_tracer_advection.c:799:        if (E->parallel.nprocz>1) {
Full_tracer_advection.c:808:        for (pp=1;pp<=E->parallel.TNUM_PASS[lev][j];pp++) {
Full_tracer_advection.c:817:            fprintf(E->trace.fpt,"Error(lost souls)-should not be here\n");
Full_tracer_advection.c:818:            fprintf(E->trace.fpt,"x: %f y: %f z: %f rad: %f\n",x,y,z,rad);
Full_tracer_advection.c:820:            if (icheck==1) fprintf(E->trace.fpt," icheck here!\n");
Full_tracer_advection.c:821:            else fprintf(E->trace.fpt,"icheck not here!\n");
Full_tracer_advection.c:822:            fflush(E->trace.fpt);
Full_tracer_advection.c:832:        isend_position=(isend[j][ithatcap]-1)*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:834:        for (pp=0;pp<=(E->trace.number_of_tracer_quantities-1);pp++) {
Full_tracer_advection.c:836:            send[j][ithatcap][ipos]=E->trace.rlater[j][pp][kk];
Full_tracer_advection.c:890:    int maxlevel=E->mesh.levmax;
Full_tracer_advection.c:925:                    fprintf(E->trace.fpt,"ERROR(gnomonic_interpolation)-inum>3!\n");
Full_tracer_advection.c:926:                    fflush(E->trace.fpt);
Full_tracer_advection.c:931:                    fprintf(E->trace.fpt,"ERROR(gnomonic_interpolation)-inum>1\n");
Full_tracer_advection.c:932:                    fprintf(E->trace.fpt,"shape %f %f %f\n",shape2d[1],shape2d[2],shape2d[3]);
Full_tracer_advection.c:933:                    fprintf(E->trace.fpt,"u %f v %f element: %d \n",u,v, nelem);
Full_tracer_advection.c:934:                    fprintf(E->trace.fpt,"Element uv boundaries: \n");
Full_tracer_advection.c:936:                        i = (E->ien[j][nelem].node[kk] - 1) / E->lmesh.noz + 1;
Full_tracer_advection.c:937:                        fprintf(E->trace.fpt,"%d: U: %f V:%f\n",kk,E->gnomonic[i].u,E->gnomonic[i].v);
Full_tracer_advection.c:939:                    fprintf(E->trace.fpt,"theta: %f phi: %f rad: %f\n",theta,phi,rad);
Full_tracer_advection.c:940:                    fprintf(E->trace.fpt,"Element theta-phi boundaries: \n");
Full_tracer_advection.c:942:                        fprintf(E->trace.fpt,"%d: Theta: %f Phi:%f\n",kk,E->sx[j][1][E->ien[j][nelem].node[kk]],E->sx[j][2][E->ien[j][nelem].node[kk]]);
Full_tracer_advection.c:945:                    fprintf(E->trace.fpt,"ICHECK?: %d\n",ival);
Full_tracer_advection.c:946:                    ival=(E->trace.iget_element)(E,j,-99,x,y,z,theta,phi,rad);
Full_tracer_advection.c:947:                    fprintf(E->trace.fpt,"New Element?: %d\n",ival);
Full_tracer_advection.c:949:                    fprintf(E->trace.fpt,"New Element (neighs)?: %d\n",ival);
Full_tracer_advection.c:952:                    fprintf(E->trace.fpt,"ICHECK?: %d\n",ival);
Full_tracer_advection.c:955:                    fprintf(E->trace.fpt,"NO LUCK\n");
Full_tracer_advection.c:956:                    fflush(E->trace.fpt);
Full_tracer_advection.c:984:    fprintf(E->trace.fpt, "shp: %e %e %e %e %e %e\n",
Full_tracer_advection.c:1124:    int n = (nelem - 1) / E->lmesh.elz + 1;
Full_tracer_advection.c:1128:    a0=E->trace.shape_coefs[j][iwedge][1][n];
Full_tracer_advection.c:1129:    a1=E->trace.shape_coefs[j][iwedge][2][n];
Full_tracer_advection.c:1130:    a2=E->trace.shape_coefs[j][iwedge][3][n];
Full_tracer_advection.c:1136:    a0=E->trace.shape_coefs[j][iwedge][4][n];
Full_tracer_advection.c:1137:    a1=E->trace.shape_coefs[j][iwedge][5][n];
Full_tracer_advection.c:1138:    a2=E->trace.shape_coefs[j][iwedge][6][n];
Full_tracer_advection.c:1144:    a0=E->trace.shape_coefs[j][iwedge][7][n];
Full_tracer_advection.c:1145:    a1=E->trace.shape_coefs[j][iwedge][8][n];
Full_tracer_advection.c:1146:    a2=E->trace.shape_coefs[j][iwedge][9][n];
Full_tracer_advection.c:1151:    fprintf(E->trace.fpt, "el=%d els=%d iwedge=%d shape=(%e %e %e)\n",
Full_tracer_advection.c:1175:    node1=E->ien[j][nelem].node[1];
Full_tracer_advection.c:1176:    node5=E->ien[j][nelem].node[5];
Full_tracer_advection.c:1178:    rad1=E->sx[j][3][node1];
Full_tracer_advection.c:1179:    rad5=E->sx[j][3][node5];
Full_tracer_advection.c:1201:            fprintf(E->trace.fpt,"ERROR(get_radial_shape)\n");
Full_tracer_advection.c:1202:            fprintf(E->trace.fpt,"shaperad[1]: %f \n",shaperad[1]);
Full_tracer_advection.c:1203:            fprintf(E->trace.fpt,"shaperad[2]: %f \n",shaperad[2]);
Full_tracer_advection.c:1204:            fflush(E->trace.fpt);
Full_tracer_advection.c:1232:    phi_f = E->gnomonic_reference_phi;
Full_tracer_advection.c:1234:    cos_theta_f = E->gnomonic[0].u;
Full_tracer_advection.c:1235:    sin_theta_f = E->gnomonic[0].v;
Full_tracer_advection.c:1253:    fprintf(E->trace.fpt, "(%e %e) -> (%e %e)\n",
Full_tracer_advection.c:1314:    elz=E->lmesh.elz;
Full_tracer_advection.c:1316:    nelsurf=E->lmesh.elx*E->lmesh.ely;
Full_tracer_advection.c:1331:    expansion=2.0*0.5*(M_PI/4.0)/(1.0*E->lmesh.elx);
Full_tracer_advection.c:1335:    if (E->parallel.me==0) fprintf(stderr,"Generating Regular Grid\n");
Full_tracer_advection.c:1341:    for(j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:1350:            for (kk=1;kk<=E->lmesh.nno;kk=kk+E->lmesh.noz)
Full_tracer_advection.c:1353:                    theta=E->sx[j][1][kk];
Full_tracer_advection.c:1354:                    phi=E->sx[j][2][kk];
Full_tracer_advection.c:1371:            deltheta=E->trace.deltheta[0]*M_PI/180.0;
Full_tracer_advection.c:1372:            delphi=E->trace.delphi[0]*M_PI/180.0;
Full_tracer_advection.c:1386:                    fprintf(E->trace.fpt,"Error(make_regular_grid): numtheta: %d numphi: %d\n",numtheta,numphi);
Full_tracer_advection.c:1387:                    fflush(E->trace.fpt);
Full_tracer_advection.c:1396:            E->trace.deltheta[j]=deltheta;
Full_tracer_advection.c:1397:            E->trace.delphi[j]=delphi;
Full_tracer_advection.c:1398:            E->trace.numtheta[j]=numtheta;
Full_tracer_advection.c:1399:            E->trace.numphi[j]=numphi;
Full_tracer_advection.c:1400:            E->trace.thetamax[j]=thetamax;
Full_tracer_advection.c:1401:            E->trace.thetamin[j]=thetamin;
Full_tracer_advection.c:1402:            E->trace.phimax[j]=phimax;
Full_tracer_advection.c:1403:            E->trace.phimin[j]=phimin;
Full_tracer_advection.c:1404:            E->trace.numregel[j]=numregel;
Full_tracer_advection.c:1405:            E->trace.numregnodes[j]=numregnodes;
Full_tracer_advection.c:1407:            if ( ((1.0*numregel)/(1.0*E->lmesh.elx*E->lmesh.ely)) < 0.5 )
Full_tracer_advection.c:1409:                    fprintf(E->trace.fpt,"\n ! WARNING: regular/real ratio low: %f ! \n",
Full_tracer_advection.c:1410:                            ((1.0*numregel)/(1.0*E->lmesh.nel)) );
Full_tracer_advection.c:1411:                    fprintf(E->trace.fpt," Should reduce size of regular mesh\n");
Full_tracer_advection.c:1413:                            ((1.0*numregel)/(1.0*E->lmesh.nel)) );
Full_tracer_advection.c:1415:                    fflush(E->trace.fpt);
Full_tracer_advection.c:1416:                    if (E->trace.itracer_warnings) exit(10);
Full_tracer_advection.c:1421:            fprintf(E->trace.fpt,"\nRegular grid:\n");
Full_tracer_advection.c:1422:            fprintf(E->trace.fpt,"Theta min: %f max: %f \n",thetamin,thetamax);
Full_tracer_advection.c:1423:            fprintf(E->trace.fpt,"Phi min: %f max: %f \n",phimin,phimax);
Full_tracer_advection.c:1424:            fprintf(E->trace.fpt,"Adjusted deltheta: %f delphi: %f\n",deltheta,delphi);
Full_tracer_advection.c:1425:            fprintf(E->trace.fpt,"(numtheta: %d  numphi: %d)\n",numtheta,numphi);
Full_tracer_advection.c:1426:            fprintf(E->trace.fpt,"Number of regular elements: %d  (nodes: %d)\n",numregel,numregnodes);
Full_tracer_advection.c:1428:            fprintf(E->trace.fpt,"regular/real ratio: %f\n",((1.0*numregel)/(1.0*E->lmesh.elx*E->lmesh.ely)));
Full_tracer_advection.c:1429:            fflush(E->trace.fpt);
Full_tracer_advection.c:1438:            if ((E->trace.regnodetoel[j]=(int *)malloc((numregnodes+1)*sizeof(int)))==NULL)
Full_tracer_advection.c:1440:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - uh3ud\n");
Full_tracer_advection.c:1441:                    fflush(E->trace.fpt);
Full_tracer_advection.c:1450:                    E->trace.regnodetoel[j][kk]=-99;
Full_tracer_advection.c:1456:            if (E->parallel.me==0) fprintf(stderr,"Beginning Mapping\n");
Full_tracer_advection.c:1463:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:1464:                    fflush(E->trace.fpt);
Full_tracer_advection.c:1469:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:1470:                    fflush(E->trace.fpt);
Full_tracer_advection.c:1475:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:1476:                    fflush(E->trace.fpt);
Full_tracer_advection.c:1481:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:1482:                    fflush(E->trace.fpt);
Full_tracer_advection.c:1486:            for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz)
Full_tracer_advection.c:1497:                            node=E->ien[j][mm].node[pp];
Full_tracer_advection.c:1498:                            theta=E->sx[j][1][node];
Full_tracer_advection.c:1499:                            phi=E->sx[j][2][node];
Full_tracer_advection.c:1538:            rad=E->sphere.ro;
Full_tracer_advection.c:1545:                    E->trace.regnodetoel[j][kk]=-99;
Full_tracer_advection.c:1565:                      for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz)
Full_tracer_advection.c:1575:                      E->trace.regnodetoel[j][kk]=mm;
Full_tracer_advection.c:1589:                            E->trace.regnodetoel[j][kk]=ilast_el;
Full_tracer_advection.c:1598:                            E->trace.regnodetoel[j][kk]=ival;
Full_tracer_advection.c:1605:                    for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz)
Full_tracer_advection.c:1614:                                            E->trace.regnodetoel[j][kk]=mm;
Full_tracer_advection.c:1622:                    if (E->trace.regnodetoel[j][kk]>0) imap++;
Full_tracer_advection.c:1626:            fprintf(E->trace.fpt,"percentage mapped: %f\n", (1.0*imap)/(1.0*numregnodes)*100.0);
Full_tracer_advection.c:1627:            fflush(E->trace.fpt);
Full_tracer_advection.c:1641:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:1646:                    if (E->trace.regnodetoel[j][kk]!=-99)
Full_tracer_advection.c:1648:                            if ( (E->trace.regnodetoel[j][kk]<1)||(E->trace.regnodetoel[j][kk]>E->lmesh.nel) )
Full_tracer_advection.c:1650:                                    fprintf(stderr,"Error(make_regular_grid)-invalid element: %d\n",E->trace.regnodetoel[j][kk]);
Full_tracer_advection.c:1651:                                    fprintf(E->trace.fpt,"Error(make_regular_grid)-invalid element: %d\n",E->trace.regnodetoel[j][kk]);
Full_tracer_advection.c:1652:                                    fflush(E->trace.fpt);
Full_tracer_advection.c:1664:    if (E->parallel.me==0) fprintf(stderr,"Beginning Regtoel submapping \n");
Full_tracer_advection.c:1670:    for(j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:1693:            numregel= E->trace.numregel[j];
Full_tracer_advection.c:1697:                    if ((E->trace.regtoel[j][pp]=(int *)malloc((numregel+1)*sizeof(int)))==NULL)
Full_tracer_advection.c:1699:                            fprintf(E->trace.fpt,"ERROR(make regular)-no memory 98d (%d %d %d)\n",pp,numregel,j);
Full_tracer_advection.c:1700:                            fflush(E->trace.fpt);
Full_tracer_advection.c:1705:            numtheta=E->trace.numtheta[j];
Full_tracer_advection.c:1706:            numphi=E->trace.numphi[j];
Full_tracer_advection.c:1717:                            for (pp=0;pp<=4;pp++) E->trace.regtoel[j][pp][iregel]=-33;
Full_tracer_advection.c:1721:                                    fprintf(E->trace.fpt,"ERROR(make_regular_grid)-weird iregel: %d (max: %d)\n",iregel,numregel);
Full_tracer_advection.c:1722:                                    fflush(E->trace.fpt);
Full_tracer_advection.c:1728:                            iregnode[3]=iregel+nphi+E->trace.numtheta[j]+1;
Full_tracer_advection.c:1729:                            iregnode[4]=iregel+nphi+E->trace.numtheta[j];
Full_tracer_advection.c:1735:                                            fprintf(E->trace.fpt,"ERROR(make regular)-bad regnode %d\n",iregnode[kk]);
Full_tracer_advection.c:1736:                                            fflush(E->trace.fpt);
Full_tracer_advection.c:1739:                                    if (E->trace.regnodetoel[j][iregnode[kk]]>E->lmesh.nel)
Full_tracer_advection.c:1741:                                            fprintf(E->trace.fpt,"AABB HERE %d %d %d %d\n",iregel,iregnode[kk],kk,E->trace.regnodetoel[j][iregnode[kk]]);
Full_tracer_advection.c:1742:                                            fflush(E->trace.fpt);
Full_tracer_advection.c:1755:                                    if (E->trace.regnodetoel[j][iregnode[kk]]<=0) goto next_corner;
Full_tracer_advection.c:1760:                                            if (E->trace.regnodetoel[j][iregnode[kk]]==E->trace.regnodetoel[j][iregnode[pp]]) goto next_corner;
Full_tracer_advection.c:1763:                                    itemp[ichoice]=E->trace.regnodetoel[j][iregnode[kk]];
Full_tracer_advection.c:1767:                                            fprintf(E->trace.fpt,"ERROR(make regular) - weird ichoice %d \n",ichoice);
Full_tracer_advection.c:1768:                                            fflush(E->trace.fpt);
Full_tracer_advection.c:1771:                                    if ((itemp[ichoice]<0) || (itemp[ichoice]>E->lmesh.nel) )
Full_tracer_advection.c:1773:                                            fprintf(E->trace.fpt,"ERROR(make regular) - weird element choice %d %d\n",itemp[ichoice],ichoice);
Full_tracer_advection.c:1774:                                            fflush(E->trace.fpt);
Full_tracer_advection.c:1786:                                    fprintf(E->trace.fpt,"ERROR(make_regular)-wierd ichoice %d\n",ichoice);
Full_tracer_advection.c:1787:                                    fflush(E->trace.fpt);
Full_tracer_advection.c:1793:                                    E->trace.regtoel[j][0][iregel]=-1;
Full_tracer_advection.c:1795:                                      fprintf(E->trace.fpt,"HH1: (%p) iregel: %d ichoice: %d value: %d %d\n",&E->trace.regtoel[j][1][iregel],iregel,ichoice,E->trace.regtoel[j][0][iregel],E->trace.regtoel[j][1][iregel]);
Full_tracer_advection.c:1800:                                    E->trace.regtoel[j][0][iregel]=0;
Full_tracer_advection.c:1801:                                    E->trace.regtoel[j][1][iregel]=itemp[1];
Full_tracer_advection.c:1804:                                      fprintf(E->trace.fpt,"HH2: (%p) iregel: %d ichoice: %d value: %d %d\n",&E->trace.regtoel[j][1][iregel],iregel,ichoice,E->trace.regtoel[j][0][iregel],E->trace.regtoel[j][1][iregel]);
Full_tracer_advection.c:1807:                                    if (itemp[1]<1 || itemp[1]>E->lmesh.nel)
Full_tracer_advection.c:1809:                                            fprintf(E->trace.fpt,"ERROR(make_regular)-huh? wierd itemp\n");
Full_tracer_advection.c:1810:                                            fflush(E->trace.fpt);
Full_tracer_advection.c:1816:                                    E->trace.regtoel[j][0][iregel]=ichoice;
Full_tracer_advection.c:1819:                                            E->trace.regtoel[j][pp][iregel]=itemp[pp];
Full_tracer_advection.c:1822:                                              fprintf(E->trace.fpt,"HH:(%p)  iregel: %d ichoice: %d pp: %d value: %d %d\n",&E->trace.regtoel[j][pp][iregel],iregel,ichoice,pp,itemp[pp],E->trace.regtoel[j][pp][iregel]);
Full_tracer_advection.c:1824:                                            if (itemp[pp]<1 || itemp[pp]>E->lmesh.nel)
Full_tracer_advection.c:1826:                                                    fprintf(E->trace.fpt,"ERROR(make_regular)-huh? wierd itemp 2 \n");
Full_tracer_advection.c:1827:                                                    fflush(E->trace.fpt);
Full_tracer_advection.c:1834:                                    fprintf(E->trace.fpt,"ERROR(make_regular)- should not be here! %d\n",ichoice);
Full_tracer_advection.c:1835:                                    fflush(E->trace.fpt);
Full_tracer_advection.c:1843:            free (E->trace.regnodetoel[j]);
Full_tracer_advection.c:1847:            for (kk=1;kk<=E->trace.numregel[j];kk++)
Full_tracer_advection.c:1849:                    if ((E->trace.regtoel[j][0][kk]<-1)||(E->trace.regtoel[j][0][kk]>4))
Full_tracer_advection.c:1851:                            fprintf(E->trace.fpt,"ERROR(make regular) regtoel ichoice0? %d %d \n",kk,E->trace.regtoel[j][pp][kk]);
Full_tracer_advection.c:1852:                            fflush(E->trace.fpt);
Full_tracer_advection.c:1857:                            if (((E->trace.regtoel[j][pp][kk]<1)&&(E->trace.regtoel[j][pp][kk]!=-33))||(E->trace.regtoel[j][pp][kk]>E->lmesh.nel))
Full_tracer_advection.c:1859:                                    fprintf(E->trace.fpt,"ERROR(make regular) (%p) regtoel? %d %d(%d) %d\n",&E->trace.regtoel[j][pp][kk],kk,pp,E->trace.regtoel[j][0][kk],E->trace.regtoel[j][pp][kk]);
Full_tracer_advection.c:1860:                                    fflush(E->trace.fpt);
Full_tracer_advection.c:1869:    fprintf(E->trace.fpt,"Mapping completed (%f seconds)\n",CPU_time0()-start_time);
Full_tracer_advection.c:1870:    fflush(E->trace.fpt);
Full_tracer_advection.c:1874:    if (E->parallel.me==0) fprintf(stderr,"Mapping completed (%f seconds)\n",CPU_time0()-start_time);
Full_tracer_advection.c:1878:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:1883:            fprintf(E->trace.fpt,"\n\nInformation regarding number of real elements per regular elements\n");
Full_tracer_advection.c:1884:            fprintf(E->trace.fpt," (stats done on regular elements that were used)\n");
Full_tracer_advection.c:1885:            fprintf(E->trace.fpt,"Ichoice is number of real elements touched by a regular element\n");
Full_tracer_advection.c:1886:            fprintf(E->trace.fpt,"  (ichoice=0 is optimal)\n");
Full_tracer_advection.c:1887:            fprintf(E->trace.fpt,"Ichoice=0: %f percent\n",(100.0*istat_ichoice[j][0])/(1.0*isum));
Full_tracer_advection.c:1888:            fprintf(E->trace.fpt,"Ichoice=1: %f percent\n",(100.0*istat_ichoice[j][1])/(1.0*isum));
Full_tracer_advection.c:1889:            fprintf(E->trace.fpt,"Ichoice=2: %f percent\n",(100.0*istat_ichoice[j][2])/(1.0*isum));
Full_tracer_advection.c:1890:            fprintf(E->trace.fpt,"Ichoice=3: %f percent\n",(100.0*istat_ichoice[j][3])/(1.0*isum));
Full_tracer_advection.c:1891:            fprintf(E->trace.fpt,"Ichoice=4: %f percent\n",(100.0*istat_ichoice[j][4])/(1.0*isum));
Full_tracer_advection.c:1905:    fprintf(E->trace.fpt,"\nTracing Activated! (proc: %d)\n",E->parallel.me);
Full_tracer_advection.c:1906:    fprintf(E->trace.fpt,"   Allen K. McNamara 12-2003\n\n");
Full_tracer_advection.c:1908:    if (E->trace.ic_method==0)
Full_tracer_advection.c:1910:            fprintf(E->trace.fpt,"Generating New Tracer Array\n");
Full_tracer_advection.c:1911:            fprintf(E->trace.fpt,"Tracers per element: %d\n",E->trace.itperel);
Full_tracer_advection.c:1913:    if (E->trace.ic_method==1)
Full_tracer_advection.c:1915:            fprintf(E->trace.fpt,"Reading tracer file %s\n",E->trace.tracer_file);
Full_tracer_advection.c:1917:    if (E->trace.ic_method==2)
Full_tracer_advection.c:1919:            fprintf(E->trace.fpt,"Reading individual tracer files\n");
Full_tracer_advection.c:1922:    fprintf(E->trace.fpt,"Number of tracer flavors: %d\n", E->trace.nflavors);
Full_tracer_advection.c:1924:    if (E->trace.nflavors && E->trace.ic_method==0) {
Full_tracer_advection.c:1925:        fprintf(E->trace.fpt,"Initialized tracer flavors by: %d\n", E->trace.ic_method_for_flavors);
Full_tracer_advection.c:1926:        if (E->trace.ic_method_for_flavors == 0) {
Full_tracer_advection.c:1928:            fprintf(E->trace.fpt,"Layered tracer flavors\n");
Full_tracer_advection.c:1929:            for (i=0; i<E->trace.nflavors-1; i++)
Full_tracer_advection.c:1930:                fprintf(E->trace.fpt,"Interface Height: %d %f\n",i,E->trace.z_interface[i]);
Full_tracer_advection.c:1933:	else if((E->trace.ic_method_for_flavors == 1)||(E->trace.ic_method_for_flavors == 99)) {
Full_tracer_advection.c:1935:            fprintf(E->trace.fpt,"netcdf grd assigned tracer flavors\n");
Full_tracer_advection.c:1936:	    if( E->trace.ggrd_layers > 0)
Full_tracer_advection.c:1937:	      fprintf(E->trace.fpt,"file: %s top %i layers\n",E->trace.ggrd_file,
Full_tracer_advection.c:1938:		      E->trace.ggrd_layers);
Full_tracer_advection.c:1940:	      fprintf(E->trace.fpt,"file: %s only layer %i\n",E->trace.ggrd_file,
Full_tracer_advection.c:1941:		      -E->trace.ggrd_layers);
Full_tracer_advection.c:1946:            fprintf(E->trace.fpt,"Sorry-This IC methods for Flavors are Unavailable %d\n",E->trace.ic_method_for_flavors);
Full_tracer_advection.c:1947:            fflush(E->trace.fpt);
Full_tracer_advection.c:1952:    for (i=0; i<E->trace.nflavors-2; i++) {
Full_tracer_advection.c:1953:        if (E->trace.z_interface[i] < E->trace.z_interface[i+1]) {
Full_tracer_advection.c:1954:            fprintf(E->trace.fpt,"Sorry - The %d-th z_interface is smaller than the next one.\n", i);
Full_tracer_advection.c:1955:            fflush(E->trace.fpt);
Full_tracer_advection.c:1964:    fprintf(E->trace.fpt,"Regular Grid-> deltheta: %f delphi: %f\n",
Full_tracer_advection.c:1965:            E->trace.deltheta[0],E->trace.delphi[0]);
Full_tracer_advection.c:1972:    fprintf(E->trace.fpt,"Box Cushion: %f\n",E->trace.box_cushion);
Full_tracer_advection.c:1973:    fprintf(E->trace.fpt,"Number of Basic Quantities: %d\n",
Full_tracer_advection.c:1974:            E->trace.number_of_basic_quantities);
Full_tracer_advection.c:1975:    fprintf(E->trace.fpt,"Number of Extra Quantities: %d\n",
Full_tracer_advection.c:1976:            E->trace.number_of_extra_quantities);
Full_tracer_advection.c:1977:    fprintf(E->trace.fpt,"Total Number of Tracer Quantities: %d\n",
Full_tracer_advection.c:1978:            E->trace.number_of_tracer_quantities);
Full_tracer_advection.c:1983:    if (E->trace.ianalytical_tracer_test==1)
Full_tracer_advection.c:1985:            fprintf(E->trace.fpt,"\n\n ! Analytical Test Being Performed ! \n");
Full_tracer_advection.c:1986:            fprintf(E->trace.fpt,"(some of the above parameters may not be used or applied\n");
Full_tracer_advection.c:1987:            fprintf(E->trace.fpt,"Velocity functions given in main code\n");
Full_tracer_advection.c:1988:            fflush(E->trace.fpt);
Full_tracer_advection.c:1991:    if (E->trace.itracer_warnings==0)
Full_tracer_advection.c:1993:            fprintf(E->trace.fpt,"\n WARNING EXITS ARE TURNED OFF! TURN THEM ON!\n");
Full_tracer_advection.c:1995:            fflush(E->trace.fpt);
Full_tracer_advection.c:2028:    elx=E->lmesh.elx;
Full_tracer_advection.c:2029:    ely=E->lmesh.ely;
Full_tracer_advection.c:2030:    elz=E->lmesh.elz;
Full_tracer_advection.c:2068:            if ((neighbor[kk]>=1)&&(neighbor[kk]<=E->lmesh.nel))
Full_tracer_advection.c:2097:    int elz=E->lmesh.elz;
Full_tracer_advection.c:2098:    int numel=E->lmesh.nel;
Full_tracer_advection.c:2162:    ibottom_node=E->ien[1][nel].node[1];
Full_tracer_advection.c:2163:    itop_node=E->ien[1][nel].node[5];
Full_tracer_advection.c:2165:    bottom_rad=E->sx[1][3][ibottom_node];
Full_tracer_advection.c:2166:    top_rad=E->sx[1][3][itop_node];
Full_tracer_advection.c:2188:    int lev = E->mesh.levmax;
Full_tracer_advection.c:2194:    E->trace.istat_elements_checked++;
Full_tracer_advection.c:2201:            node=E->ien[j][nel].node[kk+4];
Full_tracer_advection.c:2203:            rnode[kk][1]=E->x[j][1][node];
Full_tracer_advection.c:2204:            rnode[kk][2]=E->x[j][2][node];
Full_tracer_advection.c:2205:            rnode[kk][3]=E->x[j][3][node];
Full_tracer_advection.c:2207:            rnode[kk][4]=E->sx[j][1][node];
Full_tracer_advection.c:2208:            rnode[kk][5]=E->sx[j][2][node];
Full_tracer_advection.c:2210:            rnode[kk][6]=E->SinCos[lev][j][2][node]; /* cos(theta) */
Full_tracer_advection.c:2211:            rnode[kk][7]=E->SinCos[lev][j][0][node]; /* sin(theta) */
Full_tracer_advection.c:2212:            rnode[kk][8]=E->SinCos[lev][j][3][node]; /* cos(phi) */
Full_tracer_advection.c:2213:            rnode[kk][9]=E->SinCos[lev][j][1][node]; /* sin(phi) */
Full_tracer_advection.c:2251:            rnode[kk][1]=E->trace.xcap[icap][kk];
Full_tracer_advection.c:2252:            rnode[kk][2]=E->trace.ycap[icap][kk];
Full_tracer_advection.c:2253:            rnode[kk][3]=E->trace.zcap[icap][kk];
Full_tracer_advection.c:2254:            rnode[kk][4]=E->trace.theta_cap[icap][kk];
Full_tracer_advection.c:2255:            rnode[kk][5]=E->trace.phi_cap[icap][kk];
Full_tracer_advection.c:2256:            rnode[kk][6]=E->trace.cos_theta[icap][kk];
Full_tracer_advection.c:2257:            rnode[kk][7]=E->trace.sin_theta[icap][kk];
Full_tracer_advection.c:2258:            rnode[kk][8]=E->trace.cos_phi[icap][kk];
Full_tracer_advection.c:2259:            rnode[kk][9]=E->trace.sin_phi[icap][kk];
Full_tracer_advection.c:2362:            fprintf(E->trace.fpt,"Error(icheck_bounds)-too many tries\n");
Full_tracer_advection.c:2363:            fprintf(E->trace.fpt,"Rads: %f %f %f %f\n",rad1,rad2,rad3,rad4);
Full_tracer_advection.c:2364:            fprintf(E->trace.fpt,"Test Point: %f %f %f  \n",test_point[1],test_point[2],test_point[3]);
Full_tracer_advection.c:2365:            fprintf(E->trace.fpt,"Nodal points: 1: %f %f %f\n",rnode1[1],rnode1[2],rnode1[3]);
Full_tracer_advection.c:2366:            fprintf(E->trace.fpt,"Nodal points: 2: %f %f %f\n",rnode2[1],rnode2[2],rnode2[3]);
Full_tracer_advection.c:2367:            fprintf(E->trace.fpt,"Nodal points: 3: %f %f %f\n",rnode3[1],rnode3[2],rnode3[3]);
Full_tracer_advection.c:2368:            fprintf(E->trace.fpt,"Nodal points: 4: %f %f %f\n",rnode4[1],rnode4[2],rnode4[3]);
Full_tracer_advection.c:2369:            fflush(E->trace.fpt);
Full_tracer_advection.c:2409:      fprintf(stderr,"%d: icheck: %d\n",E->parallel.me,icheck);
Full_tracer_advection.c:2410:      fprintf(stderr,"%d: rads: %f %f %f %f\n",E->parallel.me,rad1,rad2,rad3,rad4);
Full_tracer_advection.c:2479:    max_radius = E->sphere.ro - E->trace.box_cushion;
Full_tracer_advection.c:2480:    min_radius = E->sphere.ri + E->trace.box_cushion;
Full_tracer_advection.c:2577:    elx=E->lmesh.elx;
Full_tracer_advection.c:2578:    ely=E->lmesh.ely;
Full_tracer_advection.c:2579:    elz=E->lmesh.elz;
Full_tracer_advection.c:2586:    if (E->parallel.nprocz>1)
Full_tracer_advection.c:2609:    if (E->trace.regtoel[j][0][iregel]==0)
Full_tracer_advection.c:2611:            iel=E->trace.regtoel[j][1][iregel];
Full_tracer_advection.c:2630:    if (E->trace.regtoel[j][0][iregel]>0)
Full_tracer_advection.c:2633:            ichoice=E->trace.regtoel[j][0][iregel];
Full_tracer_advection.c:2636:                    nelem=E->trace.regtoel[j][kk][iregel];
Full_tracer_advection.c:2700:                            ineighbor=E->trace.regtoel[j][kk][iregel];
Full_tracer_advection.c:2713:    E->trace.istat1++;
Full_tracer_advection.c:2718:      fprintf(E->trace.fpt,"WARNING(full_iget_element)-doing a full search!\n");
Full_tracer_advection.c:2719:      fprintf(E->trace.fpt,"  Most often means tracers have moved more than 1 element away\n");
Full_tracer_advection.c:2720:      fprintf(E->trace.fpt,"  or regular element resolution is way too low.\n");
Full_tracer_advection.c:2721:      fprintf(E->trace.fpt,"  COLUMN: %d \n",iel);
Full_tracer_advection.c:2722:      fprintf(E->trace.fpt,"  PREVIOUS ELEMENT: %d \n",iprevious_element);
Full_tracer_advection.c:2723:      fprintf(E->trace.fpt,"  x,y,z,theta,phi,rad: %f %f %f   %f %f %f\n",x,y,z,theta,phi,rad);
Full_tracer_advection.c:2724:      fflush(E->trace.fpt);
Full_tracer_advection.c:2725:      if (E->trace.itracer_warnings) exit(10);
Full_tracer_advection.c:2728:    if (E->trace.istat1%100==0)
Full_tracer_advection.c:2730:            fprintf(E->trace.fpt,"Checked all elements %d times already this turn\n",E->trace.istat1);
Full_tracer_advection.c:2731:            fflush(E->trace.fpt);
Full_tracer_advection.c:2741:    fprintf(E->trace.fpt,"Error(full_iget_element) - element not found\n");
Full_tracer_advection.c:2742:    fprintf(E->trace.fpt,"x,y,z,theta,phi,iregel %.15e %.15e %.15e %.15e %.15e %d\n",
Full_tracer_advection.c:2744:    fflush(E->trace.fpt);
Full_tracer_advection.c:2767:    int elz=E->lmesh.elz;
Full_tracer_advection.c:2786:            node=E->ien[j][iradial_element].node[8];
Full_tracer_advection.c:2787:            top_rad=E->sx[j][3][node];
Full_tracer_advection.c:2798:    fprintf(E->trace.fpt,"Error(iget_radial_element)-out of range %f %d %d %d\n",rad,j,iel,ibottom_element);
Full_tracer_advection.c:2799:    fflush(E->trace.fpt);
Full_tracer_advection.c:2826:    if (theta<E->trace.thetamin[j]) return -99;
Full_tracer_advection.c:2827:    if (theta>E->trace.thetamax[j]) return -99;
Full_tracer_advection.c:2831:    rdum=theta-E->trace.thetamin[j];
Full_tracer_advection.c:2832:    idum=rdum/E->trace.deltheta[j];
Full_tracer_advection.c:2835:    rdum=phi-E->trace.phimin[j];
Full_tracer_advection.c:2836:    idum=rdum/E->trace.delphi[j];
Full_tracer_advection.c:2839:    iregel=*ntheta+(*nphi-1)*E->trace.numtheta[j];
Full_tracer_advection.c:2843:    if (iregel>E->trace.numregel[j]) return -99;
Full_tracer_advection.c:2857:/* E->gnomonic[node].u = u                                      */
Full_tracer_advection.c:2858:/* E->gnomonic[node].v = v                                      */
Full_tracer_advection.c:2863:    const int lev = E->mesh.levmax;
Full_tracer_advection.c:2870:    if ((E->gnomonic = malloc((E->lmesh.nsf+1)*sizeof(struct CITCOM_GNOMONIC)))
Full_tracer_advection.c:2876:    sint = E->SinCos[lev][j][0];
Full_tracer_advection.c:2877:    sinf = E->SinCos[lev][j][1];
Full_tracer_advection.c:2878:    cost = E->SinCos[lev][j][2];
Full_tracer_advection.c:2879:    cosf = E->SinCos[lev][j][3];
Full_tracer_advection.c:2883:    refnode = 1 + E->lmesh.noz * ((E->lmesh.noy / 2) * E->lmesh.nox
Full_tracer_advection.c:2884:                                  + E->lmesh.nox / 2);
Full_tracer_advection.c:2885:    phi_f = E->gnomonic_reference_phi = E->sx[j][2][refnode];
Full_tracer_advection.c:2888:    theta_f = E->sx[j][1][refnode];
Full_tracer_advection.c:2889:    for (i=1; i<=E->lmesh.nsf; i++) {
Full_tracer_advection.c:2890:        fprintf(E->trace.fpt, "i=%d (%e %e %e %e)\n",
Full_tracer_advection.c:2893:    fprintf(E->trace.fpt, "%d %d %d ref=(%e %e)\n",
Full_tracer_advection.c:2894:            E->lmesh.noz, E->lmesh.nsf, refnode, theta_f, phi_f);
Full_tracer_advection.c:2898:    E->gnomonic[0].u = cost[refnode];
Full_tracer_advection.c:2899:    E->gnomonic[0].v = sint[refnode];
Full_tracer_advection.c:2904:    for (i=1, n=1; i<=E->lmesh.nsf; i++, n+=E->lmesh.noz) {
Full_tracer_advection.c:2905:        dphi = E->sx[j][2][n] - phi_f;
Full_tracer_advection.c:2912:        E->gnomonic[i].u = u;
Full_tracer_advection.c:2913:        E->gnomonic[i].v = v;
Full_tracer_advection.c:2916:        fprintf(E->trace.fpt, "n=%d ns=%d cosc=%e (%e %e) -> (%e %e)\n",
Full_tracer_advection.c:2917:                n, i, cosc, E->sx[j][1][n], E->sx[j][2][n], u, v);
Full_tracer_advection.c:2955:            if ((E->trace.shape_coefs[j][iwedge][kk] =
Full_tracer_advection.c:2956:                 (double *)malloc((E->lmesh.snel+1)*sizeof(double))) == NULL) {
Full_tracer_advection.c:2957:                fprintf(E->trace.fpt,"ERROR(find shape coefs)-not enough memory(a)\n");
Full_tracer_advection.c:2958:                fflush(E->trace.fpt);
Full_tracer_advection.c:2964:    for (i=1, nelem=1; i<=E->lmesh.snel; i++, nelem+=E->lmesh.elz) {
Full_tracer_advection.c:2969:            snode = (E->ien[j][nelem].node[kk]-1) / E->lmesh.noz + 1;
Full_tracer_advection.c:2970:            u[kk] = E->gnomonic[snode].u;
Full_tracer_advection.c:2971:            v[kk] = E->gnomonic[snode].v;
Full_tracer_advection.c:3000:            E->trace.shape_coefs[j][iwedge][1][i] = a0;
Full_tracer_advection.c:3001:            E->trace.shape_coefs[j][iwedge][2][i] = a1;
Full_tracer_advection.c:3002:            E->trace.shape_coefs[j][iwedge][3][i] = a2;
Full_tracer_advection.c:3011:            E->trace.shape_coefs[j][iwedge][4][i] = a0;
Full_tracer_advection.c:3012:            E->trace.shape_coefs[j][iwedge][5][i] = a1;
Full_tracer_advection.c:3013:            E->trace.shape_coefs[j][iwedge][6][i] = a2;
Full_tracer_advection.c:3022:            E->trace.shape_coefs[j][iwedge][7][i] = a0;
Full_tracer_advection.c:3023:            E->trace.shape_coefs[j][iwedge][8][i] = a1;
Full_tracer_advection.c:3024:            E->trace.shape_coefs[j][iwedge][9][i] = a2;
Full_tracer_advection.c:3027:            fprintf(E->trace.fpt, "el=%d els=%d iwedge=%d shape=(%e %e %e, %e %e %e, %e %e %e)\n",
Full_tracer_advection.c:3029:                    E->trace.shape_coefs[j][iwedge][1][i],
Full_tracer_advection.c:3030:                    E->trace.shape_coefs[j][iwedge][2][i],
Full_tracer_advection.c:3031:                    E->trace.shape_coefs[j][iwedge][3][i],
Full_tracer_advection.c:3032:                    E->trace.shape_coefs[j][iwedge][4][i],
Full_tracer_advection.c:3033:                    E->trace.shape_coefs[j][iwedge][5][i],
Full_tracer_advection.c:3034:                    E->trace.shape_coefs[j][iwedge][6][i],
Full_tracer_advection.c:3035:                    E->trace.shape_coefs[j][iwedge][7][i],
Full_tracer_advection.c:3036:                    E->trace.shape_coefs[j][iwedge][8][i],
Full_tracer_advection.c:3037:                    E->trace.shape_coefs[j][iwedge][9][i]);
Full_tracer_advection.c:3108:    fprintf(E->trace.fpt,"Starting Analytical Test\n");
Full_tracer_advection.c:3109:    if (E->parallel.me==0) fprintf(stderr,"Starting Analytical Test\n");
Full_tracer_advection.c:3110:    fflush(E->trace.fpt);
Full_tracer_advection.c:3114:    E->trace.box_cushion=0.0000;
Full_tracer_advection.c:3121:    E->advection.timestep=dt;
Full_tracer_advection.c:3123:    fprintf(E->trace.fpt,"steps: %d  dt: %f\n",nsteps,dt);
Full_tracer_advection.c:3127:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:3129:            for (kk=1;kk<=E->lmesh.nno;kk++)
Full_tracer_advection.c:3132:                    theta=E->sx[j][1][kk];
Full_tracer_advection.c:3133:                    phi=E->sx[j][2][kk];
Full_tracer_advection.c:3134:                    rad=E->sx[j][3][kk];
Full_tracer_advection.c:3138:                    E->sphere.cap[j].V[1][kk]=vel_s[1];
Full_tracer_advection.c:3139:                    E->sphere.cap[j].V[2][kk]=vel_s[2];
Full_tracer_advection.c:3140:                    E->sphere.cap[j].V[3][kk]=vel_s[3];
Full_tracer_advection.c:3153:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:3155:            if (E->trace.ntracers[j]>10)
Full_tracer_advection.c:3157:                    fprintf(E->trace.fpt,"Warning(analytical)-too many tracers to print!\n");
Full_tracer_advection.c:3158:                    fflush(E->trace.fpt);
Full_tracer_advection.c:3159:                    if (E->trace.itracer_warnings) exit(10);
Full_tracer_advection.c:3165:    E->monitor.solution_cycles=0;
Full_tracer_advection.c:3166:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:3168:            for (pp=1;pp<=E->trace.ntracers[j];pp++)
Full_tracer_advection.c:3170:                    theta=E->trace.basicq[j][0][pp];
Full_tracer_advection.c:3171:                    phi=E->trace.basicq[j][1][pp];
Full_tracer_advection.c:3172:                    rad=E->trace.basicq[j][2][pp];
Full_tracer_advection.c:3174:                    fprintf(E->trace.fpt,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:3176:                    if (pp==1) fprintf(stderr,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:3191:            E->monitor.solution_cycles=kk;
Full_tracer_advection.c:3198:            for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:3200:                    for (pp=1;pp<=E->trace.ntracers[j];pp++)
Full_tracer_advection.c:3202:                            theta=E->trace.basicq[j][0][pp];
Full_tracer_advection.c:3203:                            phi=E->trace.basicq[j][1][pp];
Full_tracer_advection.c:3204:                            rad=E->trace.basicq[j][2][pp];
Full_tracer_advection.c:3206:                            fprintf(E->trace.fpt,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:3208:                            if (pp==1) fprintf(stderr,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:3223:    fflush(E->trace.fpt);
Full_tracer_advection.c:3226:    fprintf(E->trace.fpt,"\n\nComparison to Runge-Kutte\n");
Full_tracer_advection.c:3227:    if (E->parallel.me==0) fprintf(stderr,"Comparison to Runge-Kutte\n");
Full_tracer_advection.c:3229:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:3231:            my_number=E->trace.ntracers[j];
Full_tracer_advection.c:3234:    MPI_Allreduce(&my_number,&number,1,MPI_INT,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3236:    fprintf(E->trace.fpt,"Number of tracers: %d\n", number);
Full_tracer_advection.c:3237:    if (E->parallel.me==0) fprintf(stderr,"Number of tracers: %d\n", number);
Full_tracer_advection.c:3243:            fprintf(E->trace.fpt,"(Note: RK comparison only appropriate for one tracing particle (%d here) \n",number);
Full_tracer_advection.c:3244:            if (E->parallel.me==0) fprintf(stderr,"(Note: RK comparison only appropriate for one tracing particle (%d here) \n",number);
Full_tracer_advection.c:3245:            fflush(E->trace.fpt);
Full_tracer_advection.c:3252:    MPI_Allreduce(&my_theta0,&theta0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3253:    MPI_Allreduce(&my_phi0,&phi0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3254:    MPI_Allreduce(&my_rad0,&rad0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3255:    MPI_Allreduce(&my_thetaf,&thetaf,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3256:    MPI_Allreduce(&my_phif,&phif,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3257:    MPI_Allreduce(&my_radf,&radf,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3290:    fprintf(E->trace.fpt,"Citcom calculation: steps: %d  dt: %f\n",nsteps,dt);
Full_tracer_advection.c:3291:    fprintf(E->trace.fpt,"  (nodes per cap: %d x %d x %d)\n",E->lmesh.nox,E->lmesh.noy,(E->lmesh.noz-1)*E->parallel.nprocz+1);
Full_tracer_advection.c:3292:    fprintf(E->trace.fpt,"                    starting position: theta: %f phi: %f rad: %f\n", theta0,phi0,rad0);
Full_tracer_advection.c:3293:    fprintf(E->trace.fpt,"                    final position: theta: %f phi: %f rad: %f\n", thetaf,phif,radf);
Full_tracer_advection.c:3294:    fprintf(E->trace.fpt,"                    (final time: %f) \n",time );
Full_tracer_advection.c:3296:    fprintf(E->trace.fpt,"\n\nRunge-Kutte calculation: steps: %d  dt: %g\n",nrunge_steps,runge_dt);
Full_tracer_advection.c:3297:    fprintf(E->trace.fpt,"                    starting position: theta: %f phi: %f rad: %f\n", theta0,phi0,rad0);
Full_tracer_advection.c:3298:    fprintf(E->trace.fpt,"                    final position: theta: %f phi: %f rad: %f\n",xf_s[1],xf_s[2],xf_s[3]);
Full_tracer_advection.c:3299:    fprintf(E->trace.fpt,"                    path length: %f \n",runge_path_length );
Full_tracer_advection.c:3300:    fprintf(E->trace.fpt,"                    (final time: %f) \n",runge_time );
Full_tracer_advection.c:3302:    fprintf(E->trace.fpt,"\n\n Difference between Citcom and RK: %e  (diff per path length: %e)\n\n",difference,difperpath);
Full_tracer_advection.c:3304:    if (E->parallel.me==0)
Full_tracer_advection.c:3307:            fprintf(stderr,"  (nodes per cap: %d x %d x %d)\n",E->lmesh.nox,E->lmesh.noy,(E->lmesh.noz-1)*E->parallel.nprocz+1);
Full_tracer_advection.c:3322:    fflush(E->trace.fpt);
Full_tracer_advection.c:3494:    fprintf(E->trace.fpt,"HERE (Before Sync): %d\n",i);
Full_tracer_advection.c:3495:    fflush(E->trace.fpt);
Full_tracer_advection.c:3497:    fprintf(E->trace.fpt,"HERE (After Sync): %d\n",i);
Full_tracer_advection.c:3498:    fflush(E->trace.fpt);
Full_version_dependent.c:53:    for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Full_version_dependent.c:54:        for (i=1;i<=E->lmesh.NNO[lev];i++) {
Full_version_dependent.c:55:            t[0] = E->X[lev][m][1][i]*dircos[1][1]+
Full_version_dependent.c:56:                E->X[lev][m][2][i]*dircos[1][2]+
Full_version_dependent.c:57:                E->X[lev][m][3][i]*dircos[1][3];
Full_version_dependent.c:58:            t[1] = E->X[lev][m][1][i]*dircos[2][1]+
Full_version_dependent.c:59:                E->X[lev][m][2][i]*dircos[2][2]+
Full_version_dependent.c:60:                E->X[lev][m][3][i]*dircos[2][3];
Full_version_dependent.c:61:            t[2] = E->X[lev][m][1][i]*dircos[3][1]+
Full_version_dependent.c:62:                E->X[lev][m][2][i]*dircos[3][2]+
Full_version_dependent.c:63:                E->X[lev][m][3][i]*dircos[3][3];
Full_version_dependent.c:65:            E->X[lev][m][1][i] = t[0];
Full_version_dependent.c:66:            E->X[lev][m][2][i] = t[1];
Full_version_dependent.c:67:            E->X[lev][m][3][i] = t[2];
Full_version_dependent.c:68:            E->SX[lev][m][1][i] = acos(t[2]/E->SX[lev][m][3][i]);
Full_version_dependent.c:69:            E->SX[lev][m][2][i] = myatan(t[1],t[0]);
Full_version_dependent.c:94:  rr = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Full_version_dependent.c:95:  RR = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Full_version_dependent.c:98:  switch(E->control.coor){
Full_version_dependent.c:101:    dr = (E->sphere.ro-E->sphere.ri)/(E->mesh.noz-1);
Full_version_dependent.c:103:    for (k=1;k <= E->mesh.noz;k++)  {
Full_version_dependent.c:104:      rr[k] = E->sphere.ri + (k-1)*dr;
Full_version_dependent.c:108:    sprintf(output_file,"%s",E->control.coor_file);
Full_version_dependent.c:111:      fprintf(E->fp,"(Nodal_mesh.c #1) Cannot open %s\n",output_file);
Full_version_dependent.c:115:    for (k=1;k<=E->mesh.noz;k++)  {
Full_version_dependent.c:138:  for (i=1;i<=E->mesh.noz;i++)  {
Full_version_dependent.c:139:      E->sphere.gr[i] = rr[i];
Full_version_dependent.c:140:      /* if(E->parallel.me==0) fprintf(stderr, "%d %f\n", i, E->sphere.gr[i]); */
Full_version_dependent.c:143:  for (i=1;i<=E->lmesh.noz;i++)  {
Full_version_dependent.c:144:    k = E->lmesh.nzs+i-1;
Full_version_dependent.c:151:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Full_version_dependent.c:153:    if (E->control.NMULTIGRID)
Full_version_dependent.c:154:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Full_version_dependent.c:158:      for (i=1;i<=E->lmesh.NOZ[lev];i++)
Full_version_dependent.c:159:         E->sphere.R[lev][i] = RR[(i-1)*step+1];
Full_version_dependent.c:166:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Full_version_dependent.c:167:     ii = E->sphere.capid[j];
Full_version_dependent.c:171:  if (E->control.verbose) {
Full_version_dependent.c:172:      for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Full_version_dependent.c:173:          fprintf(E->fp_out,"output_coordinates before rotation %d \n",lev);
Full_version_dependent.c:174:          for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_version_dependent.c:175:              for (i=1;i<=E->lmesh.NNO[lev];i++)
Full_version_dependent.c:176:                  if(i%E->lmesh.NOZ[lev]==1)
Full_version_dependent.c:177:                      fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Full_version_dependent.c:179:      fflush(E->fp_out);
Full_version_dependent.c:184:  ro = -0.5*(M_PI/4.0)/E->mesh.elx;
Full_version_dependent.c:197:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Full_version_dependent.c:198:     ii = E->sphere.capid[j];
Full_version_dependent.c:202:  if (E->control.verbose) {
Full_version_dependent.c:203:      for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Full_version_dependent.c:204:          fprintf(E->fp_out,"output_coordinates after rotation %d \n",lev);
Full_version_dependent.c:205:          for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_version_dependent.c:206:              for (i=1;i<=E->lmesh.NNO[lev];i++)
Full_version_dependent.c:207:                  if(i%E->lmesh.NOZ[lev]==1)
Full_version_dependent.c:208:                      fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Full_version_dependent.c:210:      fflush(E->fp_out);
Full_version_dependent.c:216:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Full_version_dependent.c:217:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_version_dependent.c:218:      for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Full_version_dependent.c:219:	tg = theta_g(E->SX[lev][j][1][i],E);
Full_version_dependent.c:220:	E->SinCos[lev][j][0][i] = sin(tg); /*  */
Full_version_dependent.c:221:	E->SinCos[lev][j][1][i] = sin(E->SX[lev][j][2][i]);
Full_version_dependent.c:222:	E->SinCos[lev][j][2][i] = cos(tg);
Full_version_dependent.c:223:	E->SinCos[lev][j][3][i] = cos(E->SX[lev][j][2][i]);
Full_version_dependent.c:227:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Full_version_dependent.c:228:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_version_dependent.c:229:      for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Full_version_dependent.c:230:	E->SinCos[lev][j][0][i] = sin(E->SX[lev][j][1][i]); /* sin(theta) */
Full_version_dependent.c:231:	E->SinCos[lev][j][1][i] = sin(E->SX[lev][j][2][i]); /* sin(phi) */
Full_version_dependent.c:232:	E->SinCos[lev][j][2][i] = cos(E->SX[lev][j][1][i]); /* cos(theta) */
Full_version_dependent.c:233:	E->SinCos[lev][j][3][i] = cos(E->SX[lev][j][2][i]); /* cos(phi) */
Full_version_dependent.c:248:  const int dims=E->mesh.nsd;
Full_version_dependent.c:253:  int max_size = 2*E->lmesh.elx*E->lmesh.ely + 1;
Full_version_dependent.c:254:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Full_version_dependent.c:255:    E->boundary.element[m] = (int *)malloc(max_size*sizeof(int));
Full_version_dependent.c:258:      E->boundary.normal[m][d] = (int *)malloc(max_size*sizeof(int));
Full_version_dependent.c:261:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Full_version_dependent.c:263:    for(k=1; k<=E->lmesh.ely; k++)
Full_version_dependent.c:264:      for(j=1; j<=E->lmesh.elx; j++) {
Full_version_dependent.c:265:	if(E->parallel.me_loc[3] == 0) {
Full_version_dependent.c:267:	  el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Full_version_dependent.c:268:	  E->boundary.element[m][count] = el;
Full_version_dependent.c:269:	  E->boundary.normal[m][dims][count] = -1;
Full_version_dependent.c:271:	      E->boundary.normal[m][d][count] = 0;
Full_version_dependent.c:275:	if(E->parallel.me_loc[3] == E->parallel.nprocz - 1) {
Full_version_dependent.c:276:	  i = E->lmesh.elz;
Full_version_dependent.c:277:	  el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Full_version_dependent.c:278:	  E->boundary.element[m][count] = el;
Full_version_dependent.c:279:	  E->boundary.normal[m][dims][count] = 1;
Full_version_dependent.c:281:	    E->boundary.normal[m][d][count] = 0;
Full_version_dependent.c:287:    E->boundary.nel = count - 1;
General_matrix_functions.c:76:  neq  = E->lmesh.NEQ[high_lev];
General_matrix_functions.c:78:  for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:89:  if (!E->control.NMULTIGRID) {
General_matrix_functions.c:92:    cycles = E->control.v_steps_low;
General_matrix_functions.c:100:    if(E->parallel.me==0){	/* output */
General_matrix_functions.c:110:      if(E->parallel.me==0){	/* output  */
General_matrix_functions.c:115:    }  while (!valid && counts < E->control.max_mg_cycles);
General_matrix_functions.c:133:  if(E->control.print_convergence&&E->parallel.me==0)   {
General_matrix_functions.c:134:    fprintf(E->fp,"%s residual (%03d) = %.3e from %.3e to %.3e in %5.2f secs \n",
General_matrix_functions.c:136:    fflush(E->fp);
General_matrix_functions.c:141:  E->monitor.momentum_residual = residual;
General_matrix_functions.c:142:  E->control.total_iteration_cycles += count;
General_matrix_functions.c:143:  E->control.total_v_solver_calls += 1;
General_matrix_functions.c:176:    const int levmin = E->mesh.levmin;
General_matrix_functions.c:177:    const int levmax = E->mesh.levmax;
General_matrix_functions.c:186:    for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)
General_matrix_functions.c:187:      for(m=1;m<=E->sphere.caps_per_proc;m++)    {
General_matrix_functions.c:188:	del_vel[i][m]=(double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
General_matrix_functions.c:189:	AU[i][m] = (double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
General_matrix_functions.c:190:	vel[i][m]=(double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
General_matrix_functions.c:191:	res[i][m]=(double *)malloc((E->lmesh.NEQ[i])*sizeof(double));
General_matrix_functions.c:192:	if (i<E->mesh.levmax)
General_matrix_functions.c:193:	  fl[i][m]=(double *)malloc((E->lmesh.NEQ[i])*sizeof(double));
General_matrix_functions.c:196:    Vnmax = E->control.mg_cycle;
General_matrix_functions.c:210:    cycles = E->control.v_steps_low;
General_matrix_functions.c:222:        for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:223:          for(j=0;j<E->lmesh.NEQ[lev];j++)
General_matrix_functions.c:226:        for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:227:          for(j=0;j<E->lmesh.NEQ[lev];j++)
General_matrix_functions.c:235:          cycles=((dlev==levmax)?E->control.v_steps_high:E->control.down_heavy);
General_matrix_functions.c:239:          for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:240:             for(i=0;i<E->lmesh.NEQ[dlev];i++)  {
General_matrix_functions.c:249:       cycles = E->control.v_steps_low;
General_matrix_functions.c:253:            cycles=((ulev==levmax)?E->control.v_steps_high:E->control.up_heavy);
General_matrix_functions.c:262:            for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:263:              for(i=0;i<E->lmesh.NEQ[ulev];i++)   {
General_matrix_functions.c:268:              for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:269:                for(i=0;i<E->lmesh.NEQ[ulev];i++)   {
General_matrix_functions.c:277:   for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:278:     for(j=0;j<E->lmesh.NEQ[levmax];j++)   {
General_matrix_functions.c:285:      for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)
General_matrix_functions.c:286:        for(m=1;m<=E->sphere.caps_per_proc;m++) {
General_matrix_functions.c:291:	  if (i<E->mesh.levmax)
General_matrix_functions.c:332:    const int mem_lev=E->mesh.levmax;
General_matrix_functions.c:333:    const int high_neq = E->lmesh.NEQ[level];
General_matrix_functions.c:337:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
General_matrix_functions.c:338:      r0[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:339:      r1[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:340:      r2[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:341:      z0[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:342:      z1[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:343:      p1[m] = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:344:      p2[m] = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:345:      Ap[m] = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:348:    for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:361:    for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:363:         z1[m][i] = E->BI[level][m][i] * r1[m][i];
General_matrix_functions.c:368:          for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:374:            for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:390:        for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:398:        for(m=1;m<=E->sphere.caps_per_proc;m++)    {
General_matrix_functions.c:413:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
General_matrix_functions.c:460:    const int dims=E->mesh.nsd;
General_matrix_functions.c:462:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:463:    const int neq=E->lmesh.NEQ[level];
General_matrix_functions.c:464:    const int nel=E->lmesh.NEL[level];
General_matrix_functions.c:465:    const int nno=E->lmesh.NNO[level];
General_matrix_functions.c:470:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
General_matrix_functions.c:480:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:487:     for (m=1;m<=E->sphere.caps_per_proc;m++) {
General_matrix_functions.c:493:	    elt_k = E->elt_k[level][m][e].k;
General_matrix_functions.c:496:		node=E->IEN[level][m][e].node[i];
General_matrix_functions.c:499:		if(E->NODE[level][m][node] & VBX)
General_matrix_functions.c:501:		if(E->NODE[level][m][node] & VBY)
General_matrix_functions.c:503:		if(E->NODE[level][m][node] & VBZ)
General_matrix_functions.c:510:		node=E->IEN[level][m][e].node[i];
General_matrix_functions.c:514:		eqn1=E->ID[level][m][node].doff[1];
General_matrix_functions.c:515:		eqn2=E->ID[level][m][node].doff[2];
General_matrix_functions.c:516:                eqn3=E->ID[level][m][node].doff[3];
General_matrix_functions.c:524:		    node1=E->IEN[level][m][e].node[j];
General_matrix_functions.c:526:	            eqn11=E->ID[level][m][node1].doff[1];
General_matrix_functions.c:527:		    eqn12=E->ID[level][m][node1].doff[2];
General_matrix_functions.c:528:		    eqn13=E->ID[level][m][node1].doff[3];
General_matrix_functions.c:540:		node=E->IEN[level][m][e].node[i];
General_matrix_functions.c:544:		eqn1=E->ID[level][m][node].doff[1];
General_matrix_functions.c:545:		eqn2=E->ID[level][m][node].doff[2];
General_matrix_functions.c:546:		eqn3=E->ID[level][m][node].doff[3];
General_matrix_functions.c:552:		d0[m][eqn1] += (dd[m][eqn1] = w[(i-1)*dims]*(F[m][eqn1]-Ad[m][eqn1])*E->BI[level][m][eqn1]);
General_matrix_functions.c:553:		d0[m][eqn2] += (dd[m][eqn2] = w[(i-1)*dims+1]*(F[m][eqn2]-Ad[m][eqn2])*E->BI[level][m][eqn2]);
General_matrix_functions.c:554:		d0[m][eqn3] += (dd[m][eqn3] = w[(i-1)*dims+2]*(F[m][eqn3]-Ad[m][eqn3])*E->BI[level][m][eqn3]);
General_matrix_functions.c:560:		   node1=E->IEN[level][m][e].node[j];
General_matrix_functions.c:562:		   eqn11=E->ID[level][m][node1].doff[1];
General_matrix_functions.c:563:		   eqn12=E->ID[level][m][node1].doff[2];
General_matrix_functions.c:564:		   eqn13=E->ID[level][m][node1].doff[3];
General_matrix_functions.c:578:        (E->solver.exchange_id_d)(E, Ad, level);
General_matrix_functions.c:579:        (E->solver.exchange_id_d)(E, d0, level);
General_matrix_functions.c:587:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
General_matrix_functions.c:629:    const int dims=E->mesh.nsd;
General_matrix_functions.c:631:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:632:    const int neq=E->lmesh.NEQ[level];
General_matrix_functions.c:633:    const int num_nodes=E->lmesh.NNO[level];
General_matrix_functions.c:634:    const int nox=E->lmesh.NOX[level];
General_matrix_functions.c:635:    const int noz=E->lmesh.NOY[level];
General_matrix_functions.c:636:    const int noy=E->lmesh.NOZ[level];
General_matrix_functions.c:648:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:657:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:658: 	for(j=0;j<=E->lmesh.NEQ[level];j++)
General_matrix_functions.c:659:          E->temp[m][j] = zeroo;
General_matrix_functions.c:661:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:664:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:665: 	for(i=1;i<=E->lmesh.NNO[level];i++)
General_matrix_functions.c:666:          if(E->NODE[level][m][i] & OFFSIDE)   {
General_matrix_functions.c:668:	    eqn1=E->ID[level][m][i].doff[1];
General_matrix_functions.c:669:	    eqn2=E->ID[level][m][i].doff[2];
General_matrix_functions.c:670:	    eqn3=E->ID[level][m][i].doff[3];
General_matrix_functions.c:671:	    E->temp[m][eqn1] = (F[m][eqn1] - Ad[m][eqn1])*E->BI[level][m][eqn1];
General_matrix_functions.c:672:	    E->temp[m][eqn2] = (F[m][eqn2] - Ad[m][eqn2])*E->BI[level][m][eqn2];
General_matrix_functions.c:673:	    E->temp[m][eqn3] = (F[m][eqn3] - Ad[m][eqn3])*E->BI[level][m][eqn3];
General_matrix_functions.c:674:	    E->temp1[m][eqn1] = Ad[m][eqn1];
General_matrix_functions.c:675:	    E->temp1[m][eqn2] = Ad[m][eqn2];
General_matrix_functions.c:676:	    E->temp1[m][eqn3] = Ad[m][eqn3];
General_matrix_functions.c:679:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:680: 	for(i=1;i<=E->lmesh.NNO[level];i++)     {
General_matrix_functions.c:682:	    eqn1=E->ID[level][m][i].doff[1];
General_matrix_functions.c:683:	    eqn2=E->ID[level][m][i].doff[2];
General_matrix_functions.c:684:	    eqn3=E->ID[level][m][i].doff[3];
General_matrix_functions.c:685:            C=E->Node_map[level][m]+(i-1)*max_eqn;
General_matrix_functions.c:686:	    B1=E->Eqn_k1[level][m]+(i-1)*max_eqn;
General_matrix_functions.c:687:	    B2=E->Eqn_k2[level][m]+(i-1)*max_eqn;
General_matrix_functions.c:688: 	    B3=E->Eqn_k3[level][m]+(i-1)*max_eqn;
General_matrix_functions.c:695:                 UU = E->temp[m][C[j]];
General_matrix_functions.c:701:            if (!(E->NODE[level][m][i]&OFFSIDE))   {
General_matrix_functions.c:702:               E->temp[m][eqn1] = (F[m][eqn1] - Ad[m][eqn1])*E->BI[level][m][eqn1];
General_matrix_functions.c:703:               E->temp[m][eqn2] = (F[m][eqn2] - Ad[m][eqn2])*E->BI[level][m][eqn2];
General_matrix_functions.c:704:               E->temp[m][eqn3] = (F[m][eqn3] - Ad[m][eqn3])*E->BI[level][m][eqn3];
General_matrix_functions.c:709:		    Ad[m][C[j]]  += B1[j]*E->temp[m][eqn1]
General_matrix_functions.c:710:                                 +  B2[j]*E->temp[m][eqn2]
General_matrix_functions.c:711:                                 +  B3[j]*E->temp[m][eqn3];
General_matrix_functions.c:713:	    d0[m][eqn1] += E->temp[m][eqn1];
General_matrix_functions.c:714:	    d0[m][eqn2] += E->temp[m][eqn2];
General_matrix_functions.c:715:	    d0[m][eqn3] += E->temp[m][eqn3];
General_matrix_functions.c:718:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:719: 	for(i=1;i<=E->lmesh.NNO[level];i++)
General_matrix_functions.c:720:          if(E->NODE[level][m][i] & OFFSIDE)   {
General_matrix_functions.c:721:	    eqn1=E->ID[level][m][i].doff[1];
General_matrix_functions.c:722:	    eqn2=E->ID[level][m][i].doff[2];
General_matrix_functions.c:723:	    eqn3=E->ID[level][m][i].doff[3];
General_matrix_functions.c:724:	    Ad[m][eqn1] -= E->temp1[m][eqn1];
General_matrix_functions.c:725:	    Ad[m][eqn2] -= E->temp1[m][eqn2];
General_matrix_functions.c:726:	    Ad[m][eqn3] -= E->temp1[m][eqn3];
General_matrix_functions.c:729:      (E->solver.exchange_id_d)(E, Ad, level);
General_matrix_functions.c:731:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:732: 	for(i=1;i<=E->lmesh.NNO[level];i++)
General_matrix_functions.c:733:          if(E->NODE[level][m][i] & OFFSIDE)   {
General_matrix_functions.c:734:	    eqn1=E->ID[level][m][i].doff[1];
General_matrix_functions.c:735:	    eqn2=E->ID[level][m][i].doff[2];
General_matrix_functions.c:736:	    eqn3=E->ID[level][m][i].doff[3];
General_matrix_functions.c:737:	    Ad[m][eqn1] += E->temp1[m][eqn1];
General_matrix_functions.c:738:	    Ad[m][eqn2] += E->temp1[m][eqn2];
General_matrix_functions.c:739:	    Ad[m][eqn3] += E->temp1[m][eqn3];
General_matrix_functions.c:745:/*     for (m=1;m<=E->sphere.caps_per_proc;m++)
Ggrd_handling.c:104:  if (E->parallel.nprocxy == 12){
Ggrd_handling.c:110:  only_one_layer = ((E->trace.ggrd_layers > 0)?(0):(1));
Ggrd_handling.c:120:  if(E->parallel.me > 0){	
Ggrd_handling.c:122:    mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 
Ggrd_handling.c:123:		      0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:125:  if(ggrd_grdtrack_init_general(FALSE,E->trace.ggrd_file,
Ggrd_handling.c:127:				ggrd_ict,(E->parallel.me==0)?TRUE:FALSE,FALSE,
Ggrd_handling.c:132:  if(E->parallel.me <  E->parallel.nproc-1){
Ggrd_handling.c:135:		      MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:142:  for (j=1;j<=E->sphere.caps_per_proc;j++) {
Ggrd_handling.c:143:    number_of_tracers = E->trace.ntracers[j];
Ggrd_handling.c:145:      rad = E->trace.basicq[j][2][kk]; /* tracer radius */
Ggrd_handling.c:148:      if((only_one_layer && (this_layer == -E->trace.ggrd_layers)) ||
Ggrd_handling.c:149:	 ((!only_one_layer)&&(this_layer <= E->trace.ggrd_layers))){
Ggrd_handling.c:153:	phi =   E->trace.basicq[j][1][kk];
Ggrd_handling.c:154:	theta = E->trace.basicq[j][0][kk];
Ggrd_handling.c:162:	if(!E->control.ggrd_comp_smooth){
Ggrd_handling.c:169:	E->trace.extraq[j][0][kk]= indbl;
Ggrd_handling.c:172:	E->trace.extraq[j][0][kk] = 0.0;
Ggrd_handling.c:180:  if(E->parallel.me == 0)
Ggrd_handling.c:182:      fprintf(stderr,"ggrd tracer init OK for layer %i\n",-E->trace.ggrd_layers);
Ggrd_handling.c:184:      fprintf(stderr,"ggrd tracer init OK for all layers <= %i\n",E->trace.ggrd_layers);
Ggrd_handling.c:212:  noy=E->lmesh.noy;
Ggrd_handling.c:213:  nox=E->lmesh.nox;
Ggrd_handling.c:214:  noz=E->lmesh.noz;
Ggrd_handling.c:217:  if(E->parallel.me == 0)
Ggrd_handling.c:232:  if(E->parallel.me > 0){
Ggrd_handling.c:236:    mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:237:		      0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:240:  if(E->control.ggrd.temp.scale_with_prem){/* initialize PREM */
Ggrd_handling.c:241:    if(prem_read_model(E->control.ggrd.temp.prem.model_filename,
Ggrd_handling.c:242:		       &E->control.ggrd.temp.prem, (E->parallel.me == 0)))
Ggrd_handling.c:248:  E->control.ggrd.temp.d[0].init = FALSE;
Ggrd_handling.c:249:  if(ggrd_grdtrack_init_general(TRUE,E->control.ggrd.temp.gfile,
Ggrd_handling.c:250:				E->control.ggrd.temp.dfile,gmt_string,
Ggrd_handling.c:251:				E->control.ggrd.temp.d,(E->parallel.me == 0),
Ggrd_handling.c:255:  if(E->parallel.me <  E->parallel.nproc-1){
Ggrd_handling.c:257:    mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:260:	    E->parallel.me);
Ggrd_handling.c:267:  if(E->mesh.bottbc == 1){
Ggrd_handling.c:269:    tbot =  E->control.TBCbotval;
Ggrd_handling.c:278:  for(m=1;m <= E->sphere.caps_per_proc;m++)
Ggrd_handling.c:288:	  depth = (1-E->sx[m][3][node])*6371;
Ggrd_handling.c:289:	  if(!ggrd_grdtrack_interpolate_rtp((double)E->sx[m][3][node],
Ggrd_handling.c:290:					    (double)E->sx[m][1][node],
Ggrd_handling.c:291:					    (double)E->sx[m][2][node],
Ggrd_handling.c:292:					    E->control.ggrd.temp.d,&tadd,
Ggrd_handling.c:294:	    fprintf(stderr,"%g %g %g\n",E->sx[m][2][node]*57.29577951308232087,
Ggrd_handling.c:295:		    90-E->sx[m][1][node]*57.29577951308232087,depth);
Ggrd_handling.c:299:	  if(E->control.ggrd_tinit_nl_scale){ /* nonlinear scaling,
Ggrd_handling.c:310:	  if(depth < E->control.ggrd_lower_depth_km){
Ggrd_handling.c:314:	    tmean = (tbot + E->control.TBCtopval)/2.0 +  E->control.ggrd.temp.offset;
Ggrd_handling.c:315:	    loc_scale =  E->control.ggrd.temp.scale;
Ggrd_handling.c:317:	    tmean = (tbot + E->control.TBCtopval)/2.0 +  E->control.ggrd_lower_offset;
Ggrd_handling.c:318:	    loc_scale = E->control.ggrd_lower_scale;
Ggrd_handling.c:320:	  if(E->control.ggrd.temp.scale_with_prem){
Ggrd_handling.c:324:	    prem_get_rho(&rho_prem,(double)E->sx[m][3][node],&E->control.ggrd.temp.prem);
Ggrd_handling.c:333:	    E->T[m][node] = tmean + tadd * loc_scale * rho_prem / E->data.density;
Ggrd_handling.c:336:	    E->T[m][node] = tmean + tadd * loc_scale;
Ggrd_handling.c:339:	  if(E->control.ggrd.temp.limit_trange){
Ggrd_handling.c:341:	    E->T[m][node] = min(max(E->T[m][node], 0.0),1.0);
Ggrd_handling.c:343:	  //fprintf(stderr,"z: %11g T: %11g\n",E->sx[m][3][node],E->T[m][node]);
Ggrd_handling.c:344:	  if(E->control.ggrd.temp.override_tbc){
Ggrd_handling.c:345:	    if((k == 1) && (E->mesh.bottbc == 1)){ /* bottom TBC */
Ggrd_handling.c:346:	      E->sphere.cap[m].TB[1][node] =  E->T[m][node];
Ggrd_handling.c:347:	      E->sphere.cap[m].TB[2][node] =  E->T[m][node];
Ggrd_handling.c:348:	      E->sphere.cap[m].TB[3][node] =  E->T[m][node];
Ggrd_handling.c:349:	      //fprintf(stderr,"z: %11g TBB: %11g\n",E->sx[m][3][node],E->T[m][node]);
Ggrd_handling.c:351:	    if((k == noz) && (E->mesh.toptbc == 1)){ /* top TBC */
Ggrd_handling.c:352:	      E->sphere.cap[m].TB[1][node] =  E->T[m][node];
Ggrd_handling.c:353:	      E->sphere.cap[m].TB[2][node] =  E->T[m][node];
Ggrd_handling.c:354:	      E->sphere.cap[m].TB[3][node] =  E->T[m][node];
Ggrd_handling.c:355:	      //fprintf(stderr,"z: %11g TBT: %11g\n",E->sx[m][3][node],E->T[m][node]);
Ggrd_handling.c:366:  ggrd_grdtrack_free_gstruc(E->control.ggrd.temp.d);
Ggrd_handling.c:379:layer <=  E->control.ggrd.mat_control for  E->control.ggrd.mat_control > 0
Ggrd_handling.c:383:layer ==  -E->control.ggrd.mat_control for  E->control.ggrd.mat_control < 0
Ggrd_handling.c:401:  const int dims=E->mesh.nsd;
Ggrd_handling.c:406:  nox=E->mesh.nox;noy=E->mesh.noy;noz=E->mesh.noz;
Ggrd_handling.c:407:  elx=E->lmesh.elx;elz=E->lmesh.elz;ely=E->lmesh.ely;
Ggrd_handling.c:416:  if(E->control.ggrd_mat_is_code)
Ggrd_handling.c:422:  if(!E->control.ggrd.time_hist.init){
Ggrd_handling.c:426:    ggrd_init_thist_from_file(&E->control.ggrd.time_hist,
Ggrd_handling.c:427:			      E->control.ggrd.time_hist.file,TRUE,(E->parallel.me == 0));
Ggrd_handling.c:428:    E->control.ggrd.time_hist.init = 1;
Ggrd_handling.c:431:  timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Ggrd_handling.c:432:  if(!E->control.ggrd.mat_control_init){
Ggrd_handling.c:445:    if(E->parallel.me > 0)	/* wait for previous processor */
Ggrd_handling.c:446:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:447:			0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:451:    E->control.ggrd.mat = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:455:    if((in = fopen(E->control.ggrd_mat_depth_file,"r"))!=NULL) /* expect 3D setup */
Ggrd_handling.c:456:      E->control.ggrd_mat_is_3d = TRUE;
Ggrd_handling.c:458:      E->control.ggrd_mat_is_3d = FALSE;
Ggrd_handling.c:460:    if(E->parallel.me==0){
Ggrd_handling.c:461:      if(E->control.ggrd.mat_control > 0){
Ggrd_handling.c:463:		E->data.radius_km*E->viscosity.zbase_layer[E->control.ggrd.mat_control-1],
Ggrd_handling.c:464:		(is_geographic)?("geographic"):("Cartesian"),(E->control.ggrd_mat_is_3d)?("3D"):("single layer"));
Ggrd_handling.c:467:		E->data.radius_km*E->viscosity.zbase_layer[-E->control.ggrd.mat_control-1],
Ggrd_handling.c:468:		(is_geographic)?("geographic"):("Cartesian"),(E->control.ggrd_mat_is_3d)?("3D"):("single layer"));
Ggrd_handling.c:471:    for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Ggrd_handling.c:473:	sprintf(tfilename,"%s",E->control.ggrd.mat_file);
Ggrd_handling.c:475:	if(E->control.ggrd_mat_is_3d)
Ggrd_handling.c:476:	  sprintf(tfilename,"%s/%i/weak",E->control.ggrd.mat_file,i+1);
Ggrd_handling.c:478:	  sprintf(tfilename,"%s/%i/weak.grd",E->control.ggrd.mat_file,i+1);
Ggrd_handling.c:480:      if(ggrd_grdtrack_init_general(E->control.ggrd_mat_is_3d,tfilename,E->control.ggrd_mat_depth_file,
Ggrd_handling.c:481:				    gmt_string,(E->control.ggrd.mat+i),
Ggrd_handling.c:482:				    (E->parallel.me == 0),FALSE,
Ggrd_handling.c:486:    if(E->parallel.me <  E->parallel.nproc-1){ /* tell the next proc to go ahead */
Ggrd_handling.c:488:			MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:496:  if(timedep || (!E->control.ggrd.mat_control_init)){
Ggrd_handling.c:498:    if(E->parallel.me == 0)
Ggrd_handling.c:501:      ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Ggrd_handling.c:502:			 E->control.ggrd.time_hist.vstage_transition);
Ggrd_handling.c:513:    for (m=1;m <= E->sphere.caps_per_proc;m++) {
Ggrd_handling.c:515:	if(((E->control.ggrd.mat_control > 0) && (E->mat[m][j] <=  E->control.ggrd.mat_control )) || 
Ggrd_handling.c:516:	   ((E->control.ggrd.mat_control < 0) && (E->mat[m][j] == -E->control.ggrd.mat_control ))){
Ggrd_handling.c:532:		ind = E->ien[m][el].node[inode];
Ggrd_handling.c:533:		xloc[1] += E->x[m][1][ind];xloc[2] += E->x[m][2][ind];xloc[3] += E->x[m][3][ind];
Ggrd_handling.c:540:	      if(E->control.ggrd_mat_is_3d){
Ggrd_handling.c:541:		if(!ggrd_grdtrack_interpolate_rtp((double)rout[0],(double)rout[1],(double)rout[2],(E->control.ggrd.mat+i1),&indbl,
Ggrd_handling.c:549:		if(!ggrd_grdtrack_interpolate_tp((double)rout[1],(double)rout[2],(E->control.ggrd.mat+i1),&indbl,
Ggrd_handling.c:558:		if(E->control.ggrd_mat_is_3d){
Ggrd_handling.c:560:						   (E->control.ggrd.mat+i2),&indbl2,
Ggrd_handling.c:568:						   (E->control.ggrd.mat+i2),&indbl2,
Ggrd_handling.c:580:	      if(E->control.ggrd_mat_limit_prefactor){
Ggrd_handling.c:588:	      E->VIP[m][el] = vip;
Ggrd_handling.c:593:	  if(E->control.ggrd_mat_is_code){
Ggrd_handling.c:597:		E->VIP[m][el] = 0; /* zero code --> unity scale */
Ggrd_handling.c:604:		E->VIP[m][el] = 1.0;
Ggrd_handling.c:611:    if(E->control.ggrd_mat_is_code){
Ggrd_handling.c:616:      if(E->parallel.me==0){
Ggrd_handling.c:617:	for(i=0;i < E->control.ggrd_mat_is_code;i++)
Ggrd_handling.c:619:		  i+1,E->control.ggrd_mat_code_viscosities[i]);
Ggrd_handling.c:623:      for (m=1;m <= E->sphere.caps_per_proc;m++) {
Ggrd_handling.c:628:	      if((int)E->VIP[m][el] < 1){ /* background */
Ggrd_handling.c:629:		E->VIP[m][el] = 1.0;
Ggrd_handling.c:631:		if((((int)E->VIP[m][el]) > E->control.ggrd_mat_is_code)||(((int)E->VIP[m][el]) < 1)){
Ggrd_handling.c:632:		  fprintf(stderr,"%i\n",(int)E->VIP[m][el]);
Ggrd_handling.c:635:		E->VIP[m][el] = E->control.ggrd_mat_code_viscosities[(int)(E->VIP[m][el]-1)];
Ggrd_handling.c:643:  if((!timedep) && (!E->control.ggrd.mat_control_init)){
Ggrd_handling.c:645:    ggrd_grdtrack_free_gstruc(E->control.ggrd.mat);
Ggrd_handling.c:647:  E->control.ggrd.mat_control_init = 1;
Ggrd_handling.c:656:layer <= E->control.ggrd.ray_control
Ggrd_handling.c:677:  const int dims=E->mesh.nsd;
Ggrd_handling.c:680:  nox=E->mesh.nox;noy=E->mesh.noy;noz=E->mesh.noz;
Ggrd_handling.c:681:  elx=E->lmesh.elx;elz=E->lmesh.elz;ely=E->lmesh.ely;
Ggrd_handling.c:684:  lev=E->mesh.levmax;
Ggrd_handling.c:692:  if(!E->control.ggrd.time_hist.init){
Ggrd_handling.c:693:    ggrd_init_thist_from_file(&E->control.ggrd.time_hist,
Ggrd_handling.c:694:			      E->control.ggrd.time_hist.file,TRUE,(E->parallel.me == 0));
Ggrd_handling.c:695:    E->control.ggrd.time_hist.init = 1;
Ggrd_handling.c:697:  timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Ggrd_handling.c:698:  if(!E->control.ggrd.ray_control_init){
Ggrd_handling.c:700:    if(E->parallel.me==0)
Ggrd_handling.c:701:      fprintf(stderr,"ggrd_read_ray_from_file: initializing from %s\n",E->control.ggrd.ray_file);
Ggrd_handling.c:706:    if(E->parallel.me > 0)	/* wait for previous processor */
Ggrd_handling.c:707:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:708:			0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:709:    E->control.ggrd.ray = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:710:    for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Ggrd_handling.c:712:	sprintf(tfilename,"%s",E->control.ggrd.ray_file);
Ggrd_handling.c:714:	sprintf(tfilename,"%s/%i/rayleigh.grd",E->control.ggrd.ray_file,i+1);
Ggrd_handling.c:716:				    gmt_string,(E->control.ggrd.ray+i),
Ggrd_handling.c:717:				    (E->parallel.me == 0),FALSE,
Ggrd_handling.c:721:    if(E->parallel.me <  E->parallel.nproc-1){ /* tell the next proc to go ahead */
Ggrd_handling.c:723:			MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:727:    E->control.surface_rayleigh = (float *)malloc(sizeof(float)*(E->lmesh.nsf+2));
Ggrd_handling.c:728:    if(!E->control.surface_rayleigh)
Ggrd_handling.c:731:  if(timedep || (!E->control.ggrd.ray_control_init)){
Ggrd_handling.c:734:      ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Ggrd_handling.c:735:			 E->control.ggrd.time_hist.vstage_transition);
Ggrd_handling.c:741:    if(E->parallel.me == 0)
Ggrd_handling.c:743:    for (m=1;m <= E->sphere.caps_per_proc;m++) {
Ggrd_handling.c:745:      for (j=1;j <= E->lmesh.nsf;j++)  {
Ggrd_handling.c:746:	node = j * E->lmesh.noz ;
Ggrd_handling.c:747:	rout[1] = (double)E->sx[m][1][node];
Ggrd_handling.c:748:	rout[2] = (double)E->sx[m][2][node];
Ggrd_handling.c:749:	if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.ray+i1),&indbl,
Ggrd_handling.c:755:	//fprintf(stderr,"%i %i %g %g %g\n",j,E->lmesh.nsf,rout[1],rout[2],indbl);
Ggrd_handling.c:758:					   (E->control.ggrd.ray+i2),&indbl2,
Ggrd_handling.c:769:	E->control.surface_rayleigh[j] = vip;
Ggrd_handling.c:773:  if((!timedep) && (!E->control.ggrd.ray_control_init)){			/* forget the grid */
Ggrd_handling.c:774:    ggrd_grdtrack_free_gstruc(E->control.ggrd.ray);
Ggrd_handling.c:776:  E->control.ggrd.ray_control_init = 1;
Ggrd_handling.c:812:  const int dims=E->mesh.nsd;
Ggrd_handling.c:825:  nox = E->lmesh.nox;
Ggrd_handling.c:826:  noz = E->lmesh.noz;
Ggrd_handling.c:827:  noy = E->lmesh.noy;
Ggrd_handling.c:833:  if(E->control.ggrd_allow_mixed_vbcs)
Ggrd_handling.c:838:  if(E->mesh.toplayerbc != 0)
Ggrd_handling.c:844:  top_proc = E->parallel.nprocz-1;
Ggrd_handling.c:848:  if((allow_internal && (E->parallel.me == 0)) || (E->parallel.me == top_proc))
Ggrd_handling.c:853:  switch(E->mesh.topvbc){
Ggrd_handling.c:872:  if(E->control.ggrd_vtop_euler && (!use_vel)){
Ggrd_handling.c:878:	    ((E->mesh.topvbc)?("velocities"):("tractions")),E->control.ggrd_allow_mixed_vbcs);
Ggrd_handling.c:885:    vscale = E->data.scalev * E->data.timedir;
Ggrd_handling.c:886:    if(E->control.ggrd_vtop_euler)
Ggrd_handling.c:887:      vscale *=  E->data.radius_km*1e3/1e6*1e2*M_PI/180.;		/* for deg/Myr -> cm/yr conversion */
Ggrd_handling.c:888:    if(E->parallel.me == 0)
Ggrd_handling.c:894:    vscale =  1e6/(E->data.ref_viscosity*E->data.therm_diff/(E->data.radius_km*E->data.radius_km*1e6));
Ggrd_handling.c:901:  if (allow_internal || (E->parallel.me_loc[3] == top_proc)) { 
Ggrd_handling.c:913:    if(!E->control.ggrd.time_hist.init){/* init times, if available*/
Ggrd_handling.c:914:      ggrd_init_thist_from_file(&E->control.ggrd.time_hist,E->control.ggrd.time_hist.file,
Ggrd_handling.c:915:				TRUE,(E->parallel.me == 0));
Ggrd_handling.c:916:      E->control.ggrd.time_hist.init = 1;
Ggrd_handling.c:918:    timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Ggrd_handling.c:920:    if(!E->control.ggrd.vtop_control_init){
Ggrd_handling.c:942:      E->control.ggrd.svt = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:943:      E->control.ggrd.svp = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:944:      if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:946:	euler = (struct elvc **)malloc(E->control.ggrd.time_hist.nvtimes * sizeof(struct elvc *));
Ggrd_handling.c:947:	max_code = (int *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(int));
Ggrd_handling.c:951:      E->control.ggrd.svt->bandlim = E->control.ggrd.svp->bandlim = 1e6;
Ggrd_handling.c:952:      for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Ggrd_handling.c:960:	  if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:961:	    sprintf(tfilename1,"%s/code.grd",E->control.ggrd.vtop_dir);
Ggrd_handling.c:962:	    sprintf(tfilename2,"%s/rotvec.dat",E->control.ggrd.vtop_dir);
Ggrd_handling.c:964:	    sprintf(tfilename1,"%s/vt.grd",E->control.ggrd.vtop_dir);
Ggrd_handling.c:965:	    sprintf(tfilename2,"%s/vp.grd",E->control.ggrd.vtop_dir);
Ggrd_handling.c:968:	  if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:969:	    sprintf(tfilename1,"%s/%i/code.grd",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:970:	    sprintf(tfilename2,"%s/%i/rotvec.dat",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:972:	    sprintf(tfilename1,"%s/%i/vt.grd",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:973:	    sprintf(tfilename2,"%s/%i/vp.grd",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:976:	if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:982:					gmt_string,(E->control.ggrd.svt+i),
Ggrd_handling.c:1013:					gmt_string,(E->control.ggrd.svt+i),verbose,FALSE,
Ggrd_handling.c:1017:					gmt_string,(E->control.ggrd.svp+i),verbose,FALSE,
Ggrd_handling.c:1024:      if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:1025:	if(E->control.ggrd.time_hist.nvtimes == 1){
Ggrd_handling.c:1028:		   E->control.data_dir,E->parallel.me);
Ggrd_handling.c:1035:		E->control.ggrd.time_hist.nvtimes,E->control.ggrd.svt->fmaxlim[0]);
Ggrd_handling.c:1043:    theta_max = (90.-E->control.ggrd.svt[0].south)*M_PI/180-1e-5;
Ggrd_handling.c:1044:    theta_min = (90.-E->control.ggrd.svt[0].north)*M_PI/180+1e-5;
Ggrd_handling.c:1047:	      E->control.ggrd.svt[0].south,E->control.ggrd.svt[0].north);
Ggrd_handling.c:1049:    if((E->control.ggrd.time_hist.nvtimes > 1)|| (!E->control.ggrd.vtop_control_init)){
Ggrd_handling.c:1063:	  i1 = E->control.ggrd.time_hist.nvtimes - 1;
Ggrd_handling.c:1068:	  ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Ggrd_handling.c:1069:			     E->control.ggrd.time_hist.vstage_transition);
Ggrd_handling.c:1088:      if(E->control.ggrd_allow_mixed_vbcs){
Ggrd_handling.c:1095:	if(E->control.ggrd_vtop_euler)
Ggrd_handling.c:1101:	cutoff = E->control.ggrd.svt->fmaxlim[0] + 1e-5;	  
Ggrd_handling.c:1102:	for(level=E->mesh.gridmax;level >= E->mesh.gridmin;level--){/* multigrid levels */
Ggrd_handling.c:1104:	  noxl = E->lmesh.NOX[level];
Ggrd_handling.c:1105:	  noyl = E->lmesh.NOY[level];
Ggrd_handling.c:1106:	  nozl = E->lmesh.NOZ[level];
Ggrd_handling.c:1109:	  for (m=1;m <= E->sphere.caps_per_proc;m++) {
Ggrd_handling.c:1124:		  rout[1] = E->SX[level][m][1][nodel]; /* theta,phi */
Ggrd_handling.c:1125:		  rout[2] = E->SX[level][m][2][nodel];
Ggrd_handling.c:1148:		  if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i1),
Ggrd_handling.c:1154:		    if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i2),vin2,
Ggrd_handling.c:1172:		    ontop = ((k==nozl) && (E->parallel.me_loc[3]==E->parallel.nprocz-1))?(TRUE):(FALSE);
Ggrd_handling.c:1178:		      E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~VBX);
Ggrd_handling.c:1179:		      E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | SBX;
Ggrd_handling.c:1180:		      E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~VBY);
Ggrd_handling.c:1181:		      E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | SBY;
Ggrd_handling.c:1186:			E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | VBX;
Ggrd_handling.c:1187:			E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~SBX);
Ggrd_handling.c:1188:			E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | VBY;
Ggrd_handling.c:1189:			E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~SBY);
Ggrd_handling.c:1193:			E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~VBX);
Ggrd_handling.c:1194:			E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | SBX;
Ggrd_handling.c:1195:			E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~VBY);
Ggrd_handling.c:1196:			E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | SBY;
Ggrd_handling.c:1205:	fprintf(stderr,"ggrd_read_vtop_from_file: mixed_bc: %i free %i fixed for CPU %i\n",nfree,nfixed,E->parallel.me);
Ggrd_handling.c:1220:      if(!E->control.ggrd_vtop_euler)		/* else, is not defined */
Ggrd_handling.c:1221:	cutoff = E->control.ggrd.svp->fmaxlim[0] * vscale + 1e-5;
Ggrd_handling.c:1226:      for (m=1;m <= E->sphere.caps_per_proc;m++) {
Ggrd_handling.c:1228:	ggrd_vtop_helper_decide_on_internal_nodes(E,allow_internal,E->lmesh.NOZ[E->mesh.gridmax],E->mesh.gridmax,m,verbose,
Ggrd_handling.c:1235:	      rout[1] = E->sx[m][1][nodel]; /* theta,phi coordinates */
Ggrd_handling.c:1236:	      rout[2] = E->sx[m][2][nodel];
Ggrd_handling.c:1261:	      if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svt+i1),
Ggrd_handling.c:1267:	      if(!E->control.ggrd_vtop_euler){
Ggrd_handling.c:1269:		if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i1),
Ggrd_handling.c:1278:		if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svt+i2),vin2,
Ggrd_handling.c:1284:		if(!E->control.ggrd_vtop_euler){
Ggrd_handling.c:1286:		  if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i2),(vin2+1),
Ggrd_handling.c:1306:		if(!E->control.ggrd_vtop_euler){
Ggrd_handling.c:1323:		ontop = ((k==noz) && (E->parallel.me_loc[3]==E->parallel.nprocz-1))?(TRUE):(FALSE);
Ggrd_handling.c:1325:		if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:1348:		  vx[1]=euler[euler_i][code].w[1] * E->x[m][3][nodel] - euler[euler_i][code].w[2] * E->x[m][2][nodel]; /* vx =  */
Ggrd_handling.c:1349:		  vx[2]=euler[euler_i][code].w[2] * E->x[m][1][nodel] - euler[euler_i][code].w[0] * E->x[m][3][nodel]; /* vy =  */
Ggrd_handling.c:1350:		  vx[3]=euler[euler_i][code].w[0] * E->x[m][2][nodel] - euler[euler_i][code].w[1] * E->x[m][1][nodel]; /* vz =  */
Ggrd_handling.c:1360:		  E->sphere.cap[m].VB[1][nodel] = 0;	/* theta */
Ggrd_handling.c:1361:		  E->sphere.cap[m].VB[2][nodel] = 0;	/* phi */
Ggrd_handling.c:1364:		  E->sphere.cap[m].VB[1][nodel] = v[1];	/* theta */
Ggrd_handling.c:1365:		  E->sphere.cap[m].VB[2][nodel] = v[2];	/* phi */
Ggrd_handling.c:1368:		  E->sphere.cap[m].VB[3][nodel] = 0.0; /* r */
Ggrd_handling.c:1375:      if((!timedep)&&(!E->control.ggrd.vtop_control_init)){			/* forget the grids */
Ggrd_handling.c:1376:	ggrd_grdtrack_free_gstruc(E->control.ggrd.svt);
Ggrd_handling.c:1377:	ggrd_grdtrack_free_gstruc(E->control.ggrd.svp);
Ggrd_handling.c:1381:    if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:1386:      for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++) /* unload */
Ggrd_handling.c:1395:  E->control.ggrd.vtop_control_init = TRUE;
Ggrd_handling.c:1412:    if(E->mesh.toplayerbc > 0){
Ggrd_handling.c:1415:	if(E->SX[level][m][3][k] < E->mesh.toplayerbc_r) /* assume regular mesh structure */
Ggrd_handling.c:1423:    }else if(E->mesh.toplayerbc < 0){
Ggrd_handling.c:1425:      if(level == E->mesh.gridmax)
Ggrd_handling.c:1426:	*botnode = nozl + E->mesh.toplayerbc;
Ggrd_handling.c:1428:	*botnode = nozl + (int)((float)E->mesh.toplayerbc / pow(2.,(float)(E->mesh.gridmax-level)));
Ggrd_handling.c:1434:	      E->mesh.toplayerbc,E->mesh.toplayerbc_r);
Ggrd_handling.c:1440:	    allow_internal,*assign,*botnode,*topnode,nozl,E->mesh.toplayerbc_r);
Ggrd_handling.c:1455:  if(!E->control.ggrd.ray_control_init)
Ggrd_handling.c:1457:  if(E->parallel.me == 0)
Ggrd_handling.c:1459:	    E->control.ggrd.ray_control);
Ggrd_handling.c:1464:  for(m=1;m <= E->sphere.caps_per_proc;m++){
Ggrd_handling.c:1465:    for(snode=1;snode <= E->lmesh.nsf;snode++){ /* loop through surface nodes */
Ggrd_handling.c:1466:      if(fabs(E->control.surface_rayleigh[snode]-1.0)>1e-6){
Ggrd_handling.c:1467:	for(i=1;i <= E->lmesh.noz;i++){ /* go through depth layers */
Ggrd_handling.c:1468:	  node = (snode-1)*E->lmesh.noz + i; /* global node number */
Ggrd_handling.c:1469:	  if(layers(E,m,node) <= E->control.ggrd.ray_control){ 
Ggrd_handling.c:1474:	    xloc=1.0 + ((1 - E->sx[m][3][node]) - 
Ggrd_handling.c:1475:			E->viscosity.zbase_layer[E->control.ggrd.ray_control-1])/
Ggrd_handling.c:1476:	      E->viscosity.zbase_layer[E->control.ggrd.ray_control-1];
Ggrd_handling.c:1484:	    bnew = buoy[m][node] * E->control.surface_rayleigh[snode]; /* modified rayleigh */
Ggrd_handling.c:1487:	    /* 	    	    (1 - E->sx[m][3][node])*E->data.radius_km,E->control.ggrd.ray_control, */
Ggrd_handling.c:1488:	    /* 	    	    E->viscosity.zbase_layer[E->control.ggrd.ray_control-1]*E->data.radius_km, */
Ggrd_handling.c:1489:	    /* 	    	    fac,E->control.surface_rayleigh[snode],(fac * bnew + (1-fac)*buoy[m][node]),buoy[m][node]); */
Ggrd_handling.c:1547:  const int dims=E->mesh.nsd;
Ggrd_handling.c:1551:  const int vpts = vpoints[E->mesh.nsd];
Ggrd_handling.c:1554:  nox=E->mesh.nox;noy=E->mesh.noy;noz=E->mesh.noz;
Ggrd_handling.c:1555:  elx=E->lmesh.elx;elz=E->lmesh.elz;ely=E->lmesh.ely;
Ggrd_handling.c:1564:  if(E->viscosity.allow_anisotropic_viscosity == 0)
Ggrd_handling.c:1568:  for(i=E->mesh.gridmin;i <= E->mesh.gridmax;i++){
Ggrd_handling.c:1569:    nel  = E->lmesh.NEL[i];
Ggrd_handling.c:1570:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Ggrd_handling.c:1574:	  E->EVI2[i][j][ind] = 0.0;
Ggrd_handling.c:1575:	  E->EVIn1[i][j][ind] = 1.0; E->EVIn2[i][j][ind] = E->EVIn3[i][j][ind] = 0.0;
Ggrd_handling.c:1576:	  E->avmode[i][j][ind] = (unsigned char)
Ggrd_handling.c:1577:	    E->viscosity.allow_anisotropic_viscosity;
Ggrd_handling.c:1591:  if(E->parallel.me > 0)	/* wait for previous processor */
Ggrd_handling.c:1592:    mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:1593:		      0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:1603:  if(E->parallel.me==0){
Ggrd_handling.c:1604:    if(E->viscosity.anivisc_layer > 0){
Ggrd_handling.c:1606:	      E->data.radius_km*E->viscosity.zbase_layer[E->viscosity.anivisc_layer - 1],
Ggrd_handling.c:1610:	      E->data.radius_km*((E->viscosity.anivisc_layer<-1)?(E->viscosity.zbase_layer[-E->viscosity.anivisc_layer - 2]):(0)),
Ggrd_handling.c:1611:	      E->data.radius_km*E->viscosity.zbase_layer[-E->viscosity.anivisc_layer - 1],
Ggrd_handling.c:1620:  sprintf(tfilename,"%s/vis2.grd",E->viscosity.anisotropic_init_dir);
Ggrd_handling.c:1622:				vis2_grd,(E->parallel.me == 0),FALSE,
Ggrd_handling.c:1626:  sprintf(tfilename,"%s/nr.grd",E->viscosity.anisotropic_init_dir);
Ggrd_handling.c:1628:				nr_grd,(E->parallel.me == 0),FALSE,
Ggrd_handling.c:1632:  sprintf(tfilename,"%s/nt.grd",E->viscosity.anisotropic_init_dir);
Ggrd_handling.c:1634:				ntheta_grd,(E->parallel.me == 0),FALSE,
Ggrd_handling.c:1638:  sprintf(tfilename,"%s/np.grd",E->viscosity.anisotropic_init_dir);
Ggrd_handling.c:1640:				nphi_grd,(E->parallel.me == 0),FALSE,
Ggrd_handling.c:1645:  if(E->parallel.me <  E->parallel.nproc-1){ /* tell the next proc to go ahead */
Ggrd_handling.c:1647:		      MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:1657:  for (m=1;m <= E->sphere.caps_per_proc;m++) {
Ggrd_handling.c:1659:      if(((E->viscosity.anivisc_layer > 0)&&
Ggrd_handling.c:1660:	  (E->mat[m][j] <=   E->viscosity.anivisc_layer))||
Ggrd_handling.c:1661:	 ((E->viscosity.anivisc_layer < 0)&&
Ggrd_handling.c:1662:	  (E->mat[m][j] ==  -E->viscosity.anivisc_layer))){
Ggrd_handling.c:1673:	      ind = E->ien[m][el].node[inode];
Ggrd_handling.c:1674:	      xloc[1] += E->x[m][1][ind];
Ggrd_handling.c:1675:	      xloc[2] += E->x[m][2][ind];
Ggrd_handling.c:1676:	      xloc[3] += E->x[m][3][ind];
Ggrd_handling.c:1720:	      E->EVI2[E->mesh.gridmax][m][ind]  =   vis2;
Ggrd_handling.c:1721:	      E->EVIn1[E->mesh.gridmax][m][ind]  = cvec[0];
Ggrd_handling.c:1722:	      E->EVIn2[E->mesh.gridmax][m][ind]  = cvec[1];
Ggrd_handling.c:1723:	      E->EVIn3[E->mesh.gridmax][m][ind]  = cvec[2];
Global_operations.c:56:    const int dims = E->mesh.nsd;
Global_operations.c:58:    noy = E->lmesh.noy;
Global_operations.c:59:    noz = E->lmesh.noz;
Global_operations.c:60:    nox = E->lmesh.nox;
Global_operations.c:64:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:80:    H = (double *)malloc( (E->lmesh.noz+1)*sizeof(double));
Global_operations.c:90:  const int dims = E->mesh.nsd;
Global_operations.c:98:  sizeofH = (2*E->lmesh.noz+2)*sizeof(double);
Global_operations.c:103:  noz = E->lmesh.noz;
Global_operations.c:104:  noy = E->lmesh.noy;
Global_operations.c:105:  elz = E->lmesh.elz;
Global_operations.c:106:  elx = E->lmesh.elx;
Global_operations.c:107:  ely = E->lmesh.ely;
Global_operations.c:115:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:121:          lnode[1] = E->ien[m][el].node[1];
Global_operations.c:122:          lnode[2] = E->ien[m][el].node[2];
Global_operations.c:123:          lnode[3] = E->ien[m][el].node[3];
Global_operations.c:124:          lnode[4] = E->ien[m][el].node[4];
Global_operations.c:126:          for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:127:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:128:              temp[i] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:134:            lnode[1] = E->ien[m][el].node[5];
Global_operations.c:135:            lnode[2] = E->ien[m][el].node[6];
Global_operations.c:136:            lnode[3] = E->ien[m][el].node[7];
Global_operations.c:137:            lnode[4] = E->ien[m][el].node[8];
Global_operations.c:139:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:140:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:141:                temp[i+1] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:150:  MPI_Allreduce(temp,Have,noz2+1,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:156: /* if (E->parallel.me==0)
Global_operations.c:158:      fprintf(stderr,"area %d %d %g\n",E->parallel.me,i,Have[i+noz]);
Global_operations.c:170:  const int dims = E->mesh.nsd;
Global_operations.c:178:  sizeofH = (2*E->lmesh.noz+2)*sizeof(float);
Global_operations.c:183:  noz = E->lmesh.noz;
Global_operations.c:184:  noy = E->lmesh.noy;
Global_operations.c:185:  elz = E->lmesh.elz;
Global_operations.c:186:  elx = E->lmesh.elx;
Global_operations.c:187:  ely = E->lmesh.ely;
Global_operations.c:195:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:201:          lnode[1] = E->ien[m][el].node[1];
Global_operations.c:202:          lnode[2] = E->ien[m][el].node[2];
Global_operations.c:203:          lnode[3] = E->ien[m][el].node[3];
Global_operations.c:204:          lnode[4] = E->ien[m][el].node[4];
Global_operations.c:206:          for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:207:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:208:              temp[i] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:214:            lnode[1] = E->ien[m][el].node[5];
Global_operations.c:215:            lnode[2] = E->ien[m][el].node[6];
Global_operations.c:216:            lnode[3] = E->ien[m][el].node[7];
Global_operations.c:217:            lnode[4] = E->ien[m][el].node[8];
Global_operations.c:219:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:220:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:221:                temp[i+1] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:230:  MPI_Allreduce(temp,Have,noz2+1,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:236: /* if (E->parallel.me==0)
Global_operations.c:238:      fprintf(stderr,"area %d %d %g\n",E->parallel.me,i,Have[i+noz]);
Global_operations.c:263:  sizeofH = (2*E->lmesh.elz+2)*sizeof(double);
Global_operations.c:268:  noz = E->lmesh.noz;
Global_operations.c:269:  noy = E->lmesh.noy;
Global_operations.c:270:  elz = E->lmesh.elz;
Global_operations.c:271:  elx = E->lmesh.elx;
Global_operations.c:272:  ely = E->lmesh.ely;
Global_operations.c:282:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:289:          temp[i] += X[m][el]*E->ECO[E->mesh.levmax][m][el].area;
Global_operations.c:290:          temp[i+elz] += E->ECO[E->mesh.levmax][m][el].area;
Global_operations.c:301:  MPI_Allreduce(temp,Have,elz2+1,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:324:    const int vpts = vpoints[E->mesh.nsd];
Global_operations.c:325:    const int ends = enodes[E->mesh.nsd];
Global_operations.c:330:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:331:       for (el=1;el<=E->lmesh.nel;el++)  {
Global_operations.c:335:		n = E->ien[m][el].node[i];
Global_operations.c:336:		volume1 += E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Global_operations.c:337:		integral1 += Z[m][n] * E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Global_operations.c:343:    MPI_Allreduce(&volume1  ,&volume  ,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:344:    MPI_Allreduce(&integral1,&integral,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:368:    const int vpts = vpoints[E->mesh.nsd];
Global_operations.c:369:    const int ends = enodes[E->mesh.nsd];
Global_operations.c:374:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:375:       for (el=1;el<=E->lmesh.nel;el++)  {
Global_operations.c:379:                n = E->ien[m][el].node[i];
Global_operations.c:380:                volume1 += E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Global_operations.c:381:                integral1 += Z[m][n] * E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Global_operations.c:387:    MPI_Allreduce(&volume1  ,&volume  ,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:388:    MPI_Allreduce(&integral1,&integral,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:403: MPI_Allreduce(&Tmax,&ttmax,1,MPI_FLOAT,MPI_MAX,E->parallel.horizontal_comm);
Global_operations.c:418: MPI_Allreduce(data,temp,total,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:440: temp = (float *) malloc((E->sphere.hindice*2)*sizeof(float));
Global_operations.c:441: sphcs = (float *) malloc((E->sphere.hindice*2)*sizeof(float));
Global_operations.c:444: jumpp = E->sphere.hindice;
Global_operations.c:445: total = E->sphere.hindice*2;
Global_operations.c:446: for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c:452: MPI_Allreduce(sphcs,temp,total,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:455: for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c:478:  neq=E->lmesh.NEQ[lev];
Global_operations.c:483:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:484:    neq=E->lmesh.NEQ[lev];
Global_operations.c:489:    for (i=1;i<=E->parallel.Skip_neq[lev][m];i++)
Global_operations.c:490:       temp1 += A[m][E->parallel.Skip_id[lev][m][i]]*B[m][E->parallel.Skip_id[lev][m][i]];
Global_operations.c:496:  MPI_Allreduce(&temp, &prod,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:514:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:515:    neq=E->lmesh.NEQ[lev];
Global_operations.c:521:    for (i=1;i<=E->parallel.Skip_neq[lev][m];i++)
Global_operations.c:522:      if ((E->parallel.Skip_id[lev][m][i]+1)%3==0)
Global_operations.c:523:        temp1 += A[m][E->parallel.Skip_id[lev][m][i]]*A[m][E->parallel.Skip_id[lev][m][i]];
Global_operations.c:529:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:546:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:547:    neq=E->lmesh.NEQ[lev];
Global_operations.c:552:    for (i=1;i<=E->parallel.Skip_neq[lev][m];i++)
Global_operations.c:553:       temp1 += A[m][E->parallel.Skip_id[lev][m][i]]*B[m][E->parallel.Skip_id[lev][m][i]];
Global_operations.c:559:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:574:  npno=E->lmesh.NPNO[lev];
Global_operations.c:578:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:579:    npno=E->lmesh.NPNO[lev];
Global_operations.c:584:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:599:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Global_operations.c:600:        for (i=1; i<=E->lmesh.nno; i++) {
Global_operations.c:601:            eqn1 = E->id[m][i].doff[1];
Global_operations.c:602:            eqn2 = E->id[m][i].doff[2];
Global_operations.c:603:            eqn3 = E->id[m][i].doff[3];
Global_operations.c:607:                     V[m][eqn3] * V[m][eqn3]) * E->NMass[m][i];
Global_operations.c:610:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Global_operations.c:612:    return (prod/E->mesh.volume);
Global_operations.c:624:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Global_operations.c:625:        for (i=1; i<=E->lmesh.npno; i++) {
Global_operations.c:627:            temp += P[m][i] * P[m][i] * E->eco[m][i].area;
Global_operations.c:630:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Global_operations.c:632:    return (prod/E->mesh.volume);
Global_operations.c:644:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Global_operations.c:645:        for (i=1; i<=E->lmesh.npno; i++) {
Global_operations.c:647:            temp += A[m][i] * A[m][i] / E->eco[m][i].area;
Global_operations.c:653:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Global_operations.c:655:    return (prod/E->mesh.volume);
Global_operations.c:668:  nno=E->lmesh.NNO[lev];
Global_operations.c:672:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:673:    nno=E->lmesh.NNO[lev];
Global_operations.c:675:    if (!(E->NODE[lev][m][i] & SKIP))
Global_operations.c:679:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:696:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:697:    nno=E->lmesh.NNO[lev];
Global_operations.c:699:      if (!(E->NODE[lev][m][i] & SKIP))
Global_operations.c:703:  MPI_Allreduce(&temp, &prod,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:714:  MPI_Allreduce(&a, &temp,1,MPI_FLOAT,MPI_MIN,E->parallel.world);
Global_operations.c:723:  MPI_Allreduce(&a, &temp,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Global_operations.c:733:  MPI_Allreduce(&a, &temp,1,MPI_FLOAT,MPI_MAX,E->parallel.world);
Global_operations.c:745:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:746:    for(i=1;i<=E->lmesh.nno;i++)
Global_operations.c:762:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:763:    for(i=1;i<=E->lmesh.nno;i++)
Global_operations.c:778: const int dims = E->mesh.nsd;
Global_operations.c:780: const int nel=E->lmesh.nel;
Global_operations.c:784:for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:786:   /*if (E->mat[m][e]==1)*/
Global_operations.c:789:	 node = E->IEN[lev][m][e].node[a];
Global_operations.c:790:         dtemp += dU[m][ E->ID[lev][m][node].doff[i] ]*
Global_operations.c:791:                  dU[m][ E->ID[lev][m][node].doff[i] ];
Global_operations.c:792:         temp += U[m][ E->ID[lev][m][node].doff[i] ]*
Global_operations.c:793:                 U[m][ E->ID[lev][m][node].doff[i] ];
Global_operations.c:797:  MPI_Allreduce(&dtemp, &temp2,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:798:  MPI_Allreduce(&temp, &temp1,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:814:    if (E->parallel.nprocz > 1)  {
Global_operations.c:815:	total = E->sphere.hindice*2;
Global_operations.c:820:	jumpp = E->sphere.hindice;
Global_operations.c:821:	for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c:828:		      E->parallel.vertical_comm);
Global_operations.c:831:	for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c:854:    if(E->parallel.nprocz == 1) return;
Global_operations.c:856:    jumpp = E->sphere.hindice;
Global_operations.c:857:    total = E->sphere.hindice*2;
Global_operations.c:860:    if (E->parallel.me_loc[3] == root) {
Global_operations.c:862:        for (j=0; j<E->sphere.hindice; j++)   {
Global_operations.c:868:    MPI_Bcast(temp, total, MPI_FLOAT, root, E->parallel.vertical_comm);
Global_operations.c:870:    if (E->parallel.me_loc[3] != root) {
Global_operations.c:872:        for (j=0; j<E->sphere.hindice; j++)   {
Global_operations.c:899:    const int lev = E->mesh.levmax;
Global_operations.c:900:    const int nno = E->lmesh.nno;
Global_operations.c:910:    if(E->control.remove_angular_momentum) {
Global_operations.c:912:        for (i=1;i<=E->lmesh.elz;i++)
Global_operations.c:914:                0.5*(E->refstate.rho[i] + E->refstate.rho[i+1])*
Global_operations.c:915:                (pow(E->sx[1][3][i+1],5.0) - pow(E->sx[1][3][i],5.0));
Global_operations.c:918:                      MPI_SUM, E->parallel.vertical_comm);
Global_operations.c:922:            (pow(E->sphere.ro,5.0) - pow(E->sphere.ri,5.0));
Global_operations.c:931:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
Global_operations.c:932:      for (e=1;e<=E->lmesh.nel;e++) {
Global_operations.c:934:	t = theta_g(E->eco[m][e].centre[1],E);
Global_operations.c:936:	t = E->eco[m][e].centre[1];
Global_operations.c:938:	f = E->eco[m][e].centre[2];
Global_operations.c:939:	r = E->eco[m][e].centre[3];
Global_operations.c:951:	    vx[j] += VV[1][i]*E->N.ppt[GNPINDEX(i,j)]; 
Global_operations.c:952:	    vy[j] += VV[2][i]*E->N.ppt[GNPINDEX(i,j)]; 
Global_operations.c:959:        if(E->control.remove_angular_momentum) {
Global_operations.c:960:            int nz = (e-1) % E->lmesh.elz + 1;
Global_operations.c:961:            rho = 0.5 * (E->refstate.rho[nz] + E->refstate.rho[nz+1]);
Global_operations.c:965:	exyz[1] += (wx*cos_t*cos_f - wy*sin_f) * E->eco[m][e].area * rho;
Global_operations.c:966:	exyz[2] += (wx*cos_t*sin_f + wy*cos_f) * E->eco[m][e].area * rho;
Global_operations.c:967:	exyz[3] -= (wx*sin_t                 ) * E->eco[m][e].area * rho;
Global_operations.c:971:    MPI_Allreduce(exyz,fxyz,4,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:981:    if (E->parallel.me==0) {
Global_operations.c:982:        if(E->control.remove_angular_momentum) {
Global_operations.c:983:            fprintf(E->fp,"Angular momentum: rot=%e tr=%e fr=%e\n",rot,tr*180/M_PI,fr*180/M_PI);
Global_operations.c:986:            fprintf(E->fp,"Rigid rotation: rot=%e tr=%e fr=%e\n",rot,tr*180/M_PI,fr*180/M_PI);
Global_operations.c:994:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:997:	vx[0] = fxyz[2]* E->x[m][3][node] - fxyz[3]*E->x[m][2][node];
Global_operations.c:998:	vx[1] = fxyz[3]* E->x[m][1][node] - fxyz[1]*E->x[m][3][node];
Global_operations.c:999:	vx[2] = fxyz[1]* E->x[m][2][node] - fxyz[2]*E->x[m][1][node];
Global_operations.c:1004:	E->sphere.cap[m].V[1][node] -= v_theta;
Global_operations.c:1005:	E->sphere.cap[m].V[2][node] -= v_phi;
Global_operations.c:1011:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:1013:	frd = fr - E->sx[m][2][node];
Global_operations.c:1014:	v_theta = E->sx[m][3][node] * sin_t * sin(frd);
Global_operations.c:1015:	v_phi =   E->sx[m][3][node] * 
Global_operations.c:1016:	  (  E->SinCos[lev][m][0][node] * cos_t - E->SinCos[lev][m][2][node]  * sin_t * cos(frd) );
Global_operations.c:1018:	E->sphere.cap[m].V[1][node] -= v_theta;
Global_operations.c:1019:	E->sphere.cap[m].V[2][node] -= v_phi;
Initial_temperature.c:58:  int m = E->parallel.me;
Initial_temperature.c:59:  int noz = E->lmesh.noz;
Initial_temperature.c:65:  input_int("tic_method", &(E->convection.tic_method), "0,0,2", m);
Initial_temperature.c:70:    E->convection.tic_method = 4; /*  */
Initial_temperature.c:71:    E->control.ggrd.use_temp = 1;
Initial_temperature.c:86:     (E->control.mantle_temp).
Initial_temperature.c:107:      E->convection.number_of_perturbations = n;
Initial_temperature.c:109:      if (! input_float_vector("perturbmag", n, E->convection.perturb_mag, m) ) {
Initial_temperature.c:113:      if (! input_int_vector("perturbm", n, E->convection.perturb_mm, m) ) {
Initial_temperature.c:117:      if (! input_int_vector("perturbl", n, E->convection.perturb_ll, m) ) {
Initial_temperature.c:121:      if (! input_int_vector("perturblayer", n, E->convection.load_depth, m) ) {
Initial_temperature.c:127:      E->convection.number_of_perturbations = 1;
Initial_temperature.c:128:      E->convection.perturb_mag[0] = 1;
Initial_temperature.c:129:      E->convection.perturb_mm[0] = 2;
Initial_temperature.c:130:      E->convection.perturb_ll[0] = 2;
Initial_temperature.c:131:      E->convection.load_depth[0] = (noz+1)/2;
Initial_temperature.c:134:    input_float("half_space_age", &(E->convection.half_space_age), "40.0,1e-3,nomax", m);
Initial_temperature.c:135:    input_float("mantle_temp",&(E->control.mantle_temp),"1.0",m);
Initial_temperature.c:138:    switch(E->convection.tic_method){
Initial_temperature.c:140:      if( ! input_float_vector("blob_center", 3, E->convection.blob_center, m)) {
Initial_temperature.c:141:	assert( E->sphere.caps == 12 || E->sphere.caps == 1 );
Initial_temperature.c:142:	if(E->sphere.caps == 12) { /* Full version: just quit here */
Initial_temperature.c:146:	else if(E->sphere.caps == 1) { /* Regional version: put the blob at the center */
Initial_temperature.c:148:	  E->convection.blob_center[0] = 0.5*(E->control.theta_min+E->control.theta_max);
Initial_temperature.c:149:	  E->convection.blob_center[1] = 0.5*(E->control.fi_min+E->control.fi_max);
Initial_temperature.c:150:	  E->convection.blob_center[2] = 0.5*(E->sphere.ri+E->sphere.ro);
Initial_temperature.c:153:      input_float("blob_radius", &(E->convection.blob_radius), "0.063,0.0,1.0", m);
Initial_temperature.c:154:      input_float("blob_dT", &(E->convection.blob_dT), "0.18,nomin,nomax", m);
Initial_temperature.c:155:      input_boolean("blob_bc_persist",&(E->convection.blob_bc_persist),"off",m);
Initial_temperature.c:168:		    &(E->control.ggrd.temp.scale_with_prem),"off",E->parallel.me);
Initial_temperature.c:171:		    &(E->control.ggrd.temp.limit_trange),"on",E->parallel.me);
Initial_temperature.c:174:		   &(E->control.ggrd.temp.scale),"1.0",E->parallel.me); /* scale */
Initial_temperature.c:177:		   &(E->control.ggrd.temp.offset),"0.0",E->parallel.me); /* offset */
Initial_temperature.c:181:      input_float("ggrd_lower_depth_km",&(E->control.ggrd_lower_depth_km),"7000",
Initial_temperature.c:182:		  E->parallel.me); /* depth, in km, below which
Initial_temperature.c:184:      input_float("ggrd_lower_scale",&(E->control.ggrd_lower_scale),"1.0",E->parallel.me);
Initial_temperature.c:185:      input_float("ggrd_lower_offset",&(E->control.ggrd_lower_offset),"1.0",E->parallel.me);
Initial_temperature.c:189:		   E->control.ggrd.temp.gfile,"",E->parallel.me); /* grids */
Initial_temperature.c:191:		   E->control.ggrd.temp.dfile,"",E->parallel.me); /* depth.dat layers of grids*/
Initial_temperature.c:194:		    &(E->control.ggrd.temp.override_tbc),"off",E->parallel.me);
Initial_temperature.c:196:		   E->control.ggrd.temp.prem.model_filename,"hc/prem/prem.dat", 
Initial_temperature.c:197:		   E->parallel.me); /* PREM model filename */
Initial_temperature.c:200:      input_boolean("ggrd_tinit_nl_scale",&(E->control.ggrd_tinit_nl_scale),"off",E->parallel.me);
Initial_temperature.c:219:  if (E->convection.tic_method == -1) {
Initial_temperature.c:222:      if(strcmp(E->output.format, "ascii-gz") == 0)
Initial_temperature.c:228:  else if (E->control.lith_age)
Initial_temperature.c:236:  if (E->control.verbose)
Initial_temperature.c:247:  fprintf(E->fp_out,"output_temperature\n");
Initial_temperature.c:248:  for(m=1;m<=E->sphere.caps_per_proc;m++)        {
Initial_temperature.c:249:    fprintf(E->fp_out,"for cap %d\n",E->sphere.capid[m]);
Initial_temperature.c:250:    for (j=1;j<=E->lmesh.nno;j++)
Initial_temperature.c:251:      fprintf(E->fp_out,"X = %.6e Z = %.6e Y = %.6e T[%06d] = %.6e \n",E->sx[m][1][j],E->sx[m][2][j],E->sx[m][3][j],j,E->T[m][j]);
Initial_temperature.c:253:  fflush(E->fp_out);
Initial_temperature.c:270:  ii = E->monitor.solution_cycles_init;
Initial_temperature.c:271:  sprintf(output_file,"%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,ii);
Initial_temperature.c:274:    fprintf(E->fp,"(Initial_temperature.c #1) Cannot open %s\n",output_file);
Initial_temperature.c:278:  if (E->parallel.me==0)
Initial_temperature.c:279:    fprintf(E->fp,"Reading %s for initial temperature\n",output_file);
Initial_temperature.c:284:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Initial_temperature.c:287:    for(i=1;i<=E->lmesh.nno;i++)  {
Initial_temperature.c:295:      E->T[m][i] = max(0.0,min(g,1.0));
Initial_temperature.c:312:    nox = E->lmesh.nox;
Initial_temperature.c:313:    noy = E->lmesh.noy;
Initial_temperature.c:314:    noz = E->lmesh.noz;
Initial_temperature.c:316:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:321:                    r1 = E->sx[m][3][node];
Initial_temperature.c:322:                    E->T[m][node] = E->control.TBCbotval - (E->control.TBCtopval + E->control.TBCbotval)*(r1 - E->sphere.ri)/(E->sphere.ro - E->sphere.ri);
Initial_temperature.c:335:    nox = E->lmesh.nox;
Initial_temperature.c:336:    noy = E->lmesh.noy;
Initial_temperature.c:337:    noz = E->lmesh.noz;
Initial_temperature.c:339:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:344:                    r1 = E->sx[m][3][node];
Initial_temperature.c:345:                    E->T[m][node] = (E->control.TBCtopval*E->sphere.ro
Initial_temperature.c:346:                                     - E->control.TBCbotval*E->sphere.ri)
Initial_temperature.c:347:                        / (E->sphere.ro - E->sphere.ri)
Initial_temperature.c:348:                        + (E->control.TBCbotval - E->control.TBCtopval)
Initial_temperature.c:349:                        * E->sphere.ro * E->sphere.ri / r1
Initial_temperature.c:350:                        / (E->sphere.ro - E->sphere.ri);
Initial_temperature.c:361:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:362:        for(i=1; i<=E->lmesh.nno; i++)
Initial_temperature.c:363:            E->T[m][i] = mantle_temp;
Initial_temperature.c:375:    nox = E->lmesh.nox;
Initial_temperature.c:376:    noy = E->lmesh.noy;
Initial_temperature.c:377:    noz = E->lmesh.noz;
Initial_temperature.c:379:    dT = (mantle_temp - E->control.TBCtopval);
Initial_temperature.c:380:    tmp = 0.5 / sqrt(age_in_myrs / E->data.scalet);
Initial_temperature.c:383:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:388:                    r1 = E->sx[m][3][node];
Initial_temperature.c:389:                    E->T[m][node] -= dT * erfc(tmp * (E->sphere.ro - r1));
Initial_temperature.c:402:    nox = E->lmesh.nox;
Initial_temperature.c:403:    noy = E->lmesh.noy;
Initial_temperature.c:404:    noz = E->lmesh.noz;
Initial_temperature.c:406:    dT = (E->control.TBCbotval - mantle_temp);
Initial_temperature.c:407:    tmp = 0.5 / sqrt(age_in_myrs / E->data.scalet);
Initial_temperature.c:409:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:414:                    r1 = E->sx[m][3][node];
Initial_temperature.c:415:                    E->T[m][node] += dT * erfc(tmp * (r1 - E->sphere.ri));
Initial_temperature.c:434:    nox = E->lmesh.nox;
Initial_temperature.c:435:    noy = E->lmesh.noy;
Initial_temperature.c:436:    noz = E->lmesh.noz;
Initial_temperature.c:437:    gnoz = E->mesh.noz;
Initial_temperature.c:439:    for (p=0; p<E->convection.number_of_perturbations; p++) {
Initial_temperature.c:440:        ll = E->convection.perturb_ll[p];
Initial_temperature.c:441:        mm = E->convection.perturb_mm[p];
Initial_temperature.c:442:        kk = E->convection.load_depth[p];
Initial_temperature.c:443:        con = E->convection.perturb_mag[p];
Initial_temperature.c:447:        k = kk - E->lmesh.nzs + 1; /* convert global nz to local nz */
Initial_temperature.c:449:        if (E->parallel.me_loc[1] == 0 && E->parallel.me_loc[2] == 0
Initial_temperature.c:450:            && E->sphere.capid[1] == 1 )
Initial_temperature.c:453:        if(E->sphere.caps == 1) {
Initial_temperature.c:456:            tlen = M_PI / (E->control.theta_max - E->control.theta_min);
Initial_temperature.c:457:            flen = M_PI / (E->control.fi_max - E->control.fi_min);
Initial_temperature.c:459:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:463:                        t1 = (E->sx[m][1][node] - E->control.theta_min) * tlen;
Initial_temperature.c:464:                        f1 = (E->sx[m][2][node] - E->control.fi_min) * flen;
Initial_temperature.c:466:                        E->T[m][node] += con * cos(ll*t1) * cos(mm*f1);
Initial_temperature.c:472:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:476:                        t1 = E->sx[m][1][node];
Initial_temperature.c:477:                        f1 = E->sx[m][2][node];
Initial_temperature.c:479:                        E->T[m][node] += con * modified_plgndr_a(ll,mm,t1) * cos(mm*f1);
Initial_temperature.c:500:    nox = E->lmesh.nox;
Initial_temperature.c:501:    noy = E->lmesh.noy;
Initial_temperature.c:502:    noz = E->lmesh.noz;
Initial_temperature.c:503:    gnoz = E->mesh.noz;
Initial_temperature.c:505:    rlen = M_PI / (E->sphere.ro - E->sphere.ri);
Initial_temperature.c:507:    for (p=0; p<E->convection.number_of_perturbations; p++) {
Initial_temperature.c:508:        ll = E->convection.perturb_ll[p];
Initial_temperature.c:509:        mm = E->convection.perturb_mm[p];
Initial_temperature.c:510:        con = E->convection.perturb_mag[p];
Initial_temperature.c:512:        if (E->parallel.me_loc[1] == 0 && E->parallel.me_loc[2] == 0
Initial_temperature.c:513:            && E->sphere.capid[1] == 1 )
Initial_temperature.c:516:        if(E->sphere.caps == 1) {
Initial_temperature.c:519:            tlen = M_PI / (E->control.theta_max - E->control.theta_min);
Initial_temperature.c:520:            flen = M_PI / (E->control.fi_max - E->control.fi_min);
Initial_temperature.c:522:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:527:                            t1 = (E->sx[m][1][node] - E->control.theta_min) * tlen;
Initial_temperature.c:528:                            f1 = (E->sx[m][2][node] - E->control.fi_min) * flen;
Initial_temperature.c:529:                            r1 = E->sx[m][3][node];
Initial_temperature.c:531:                            E->T[m][node] += con * cos(ll*t1) * cos(mm*f1)
Initial_temperature.c:532:                                * sin((r1-E->sphere.ri) * rlen);
Initial_temperature.c:538:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:543:                            t1 = E->sx[m][1][node];
Initial_temperature.c:544:                            f1 = E->sx[m][2][node];
Initial_temperature.c:545:                            r1 = E->sx[m][3][node];
Initial_temperature.c:547:                            E->T[m][node] += con * modified_plgndr_a(ll,mm,t1)
Initial_temperature.c:549:                                * sin((r1-E->sphere.ri) * rlen);
Initial_temperature.c:568:    noy = E->lmesh.noy;
Initial_temperature.c:569:    nox = E->lmesh.nox;
Initial_temperature.c:570:    noz = E->lmesh.noz;
Initial_temperature.c:572:    rout = E->sphere.ro;
Initial_temperature.c:573:    rin = E->sphere.ri;
Initial_temperature.c:576:    theta_center = E->convection.blob_center[0];
Initial_temperature.c:577:    fi_center    = E->convection.blob_center[1];
Initial_temperature.c:578:    r_center     = E->convection.blob_center[2];
Initial_temperature.c:579:    radius       = E->convection.blob_radius;
Initial_temperature.c:580:    amp          = E->convection.blob_dT;
Initial_temperature.c:582:    if(E->parallel.me == 0)
Initial_temperature.c:589:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:594:		    dx[1] = E->x[m][1][node] - x_center[1];
Initial_temperature.c:595:		    dx[2] = E->x[m][2][node] - x_center[2];
Initial_temperature.c:596:		    dx[3] = E->x[m][3][node] - x_center[3];
Initial_temperature.c:600:		      E->T[m][node] += amp * exp(-1.0*distance/radius);
Initial_temperature.c:602:		      if(E->convection.blob_bc_persist){
Initial_temperature.c:603:			r1 = E->sx[m][3][node];
Initial_temperature.c:606:			  E->sphere.cap[m].TB[1][node]=E->T[m][node];
Initial_temperature.c:607:			  E->sphere.cap[m].TB[2][node]=E->T[m][node];
Initial_temperature.c:608:			  E->sphere.cap[m].TB[3][node]=E->T[m][node];
Initial_temperature.c:621:    switch (E->convection.tic_method){
Initial_temperature.c:632:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:638:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:640:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:664:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:666:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:674:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:676:        add_bottom_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:684:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:686:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:687:        add_bottom_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:696:        if((E->parallel.nprocz % 2) == 0) {
Initial_temperature.c:697:            if(E->parallel.me==0)
Initial_temperature.c:699:                        E->convection.tic_method);
Initial_temperature.c:711:            E->convection.number_of_perturbations = 1;
Initial_temperature.c:713:            mid = (E->mesh.noz+1) / 2;
Initial_temperature.c:714:            E->convection.load_depth[0] = mid;
Initial_temperature.c:716:            k = mid - E->lmesh.nzs + 1; /* convert to local nz */
Initial_temperature.c:717:            E->convection.perturb_mag[0] = 0;
Initial_temperature.c:718:            if ( (k > 1) && (k < E->lmesh.noz) ) {
Initial_temperature.c:720:                E->convection.perturb_mag[0] = 2 / (E->sx[1][3][k+1] - E->sx[1][3][k-1]);
Initial_temperature.c:730:                E->convection.tic_method);
Initial_temperature.c:736:        fprintf(stderr,"Invalid value: 'tic_method=%d'\n", E->convection.tic_method);
Instructions.c:92:  //chatty = ((E->parallel.me == 0)&&(E->control.verbose))?(1):(0);
Instructions.c:93:  chatty = E->parallel.me == 0;
Instructions.c:95:    E->monitor.cpu_time_at_last_cycle =
Instructions.c:96:        E->monitor.cpu_time_at_start = CPU_time0();
Instructions.c:99:    (E->problem_derived_values)(E);   /* call this before global_derived_  */
Instructions.c:102:    (E->solver.parallel_processor_setup)(E);   /* get # of proc in x,y,z */
Instructions.c:103:    (E->solver.parallel_domain_decomp0)(E);  /* get local nel, nno, elx, nox et al */
Instructions.c:106:    (E->problem_allocate_vars)(E);
Instructions.c:107:    (E->solver_allocate_vars)(E);
Instructions.c:112:    (E->solver.construct_boundary)(E);
Instructions.c:113:    (E->solver.parallel_domain_boundary_nodes)(E);
Instructions.c:117:    (E->solver.node_locations)(E);
Instructions.c:130:    if(E->output.write_q_files)
Instructions.c:133:      E->output.fpqt = E->output.fpqb = NULL;
Instructions.c:138:    if(E->control.lith_age)
Instructions.c:141:    (E->problem_boundary_conds)(E);
Instructions.c:151:    (E->solver.parallel_communication_routs_v)(E);
Instructions.c:154:    if(E->control.use_cbf_topo){
Instructions.c:155:      (E->solver.parallel_communication_routs_s)(E); 
Instructions.c:168:    if(E->control.inv_gruneisen != 0)
Instructions.c:184:    if(E->control.tracer) {
Instructions.c:186:	(E->problem_tracer_setup)(E);
Instructions.c:194:    if(E->control.ggrd.ray_control)
Instructions.c:233:    (E->next_buoyancy_field_init)(E);
Instructions.c:244:    if(E->control.mat_control)
Instructions.c:260:    if (E->control.tracer==1) {
Instructions.c:263:        if (E->composition.on)
Instructions.c:267:    (E->problem_initial_fields)(E);   /* temperature/chemistry/melting etc */
Instructions.c:281:  int m=E->parallel.me,i;
Instructions.c:287:  input_string("Problem",E->control.PROBLEM_TYPE,"convection",m);
Instructions.c:289:  if ( strcmp(E->control.PROBLEM_TYPE,"convection") == 0)
Instructions.c:291:  else if ( strcmp(E->control.PROBLEM_TYPE,"convection-chemical") == 0)
Instructions.c:294:    fprintf(E->fp,"Unable to determine problem type, assuming convection ... \n");
Instructions.c:298:  input_string("Geometry",E->control.GEOMETRY,"sphere",m);
Instructions.c:299:  if ( strcmp(E->control.GEOMETRY,"sphere") == 0)
Instructions.c:300:      (E->solver.set_3dsphere_defaults)(E);
Instructions.c:302:    fprintf(E->fp,"Unable to determine geometry, assuming sphere 3d ... \n");
Instructions.c:303:    (E->solver.set_3dsphere_defaults)(E);
Instructions.c:306:  input_string("Solver",E->control.SOLVER_TYPE,"cgrad",m);
Instructions.c:307:  if ( strcmp(E->control.SOLVER_TYPE,"cgrad") == 0)
Instructions.c:309:  else if ( strcmp(E->control.SOLVER_TYPE,"multigrid") == 0)
Instructions.c:312:    if (E->parallel.me==0) fprintf(stderr,"Unable to determine how to solve, specify Solver=VALID_OPTION \n");
Instructions.c:321:  input_string("datadir",E->control.data_dir,".",m);
Instructions.c:322:  input_string("datafile",E->control.data_prefix,"initialize",m);
Instructions.c:323:  input_string("datadir_old",E->control.data_dir_old,".",m);
Instructions.c:324:  input_string("datafile_old",E->control.data_prefix_old,"initialize",m);
Instructions.c:326:  input_int("nproc_surf",&(E->parallel.nprocxy),"1",m);
Instructions.c:327:  input_int("nprocx",&(E->parallel.nprocx),"1",m);
Instructions.c:328:  input_int("nprocy",&(E->parallel.nprocy),"1",m);
Instructions.c:329:  input_int("nprocz",&(E->parallel.nprocz),"1",m);
Instructions.c:331:  if (E->control.CONJ_GRAD) {
Instructions.c:332:      input_int("nodex",&(E->mesh.nox),"essential",m);
Instructions.c:333:      input_int("nodez",&(E->mesh.noz),"essential",m);
Instructions.c:334:      input_int("nodey",&(E->mesh.noy),"essential",m);
Instructions.c:336:      E->mesh.mgunitx = (E->mesh.nox - 1) / E->parallel.nprocx;
Instructions.c:337:      E->mesh.mgunity = (E->mesh.noy - 1) / E->parallel.nprocy;
Instructions.c:338:      E->mesh.mgunitz = (E->mesh.noz - 1) / E->parallel.nprocz;
Instructions.c:339:      E->mesh.levels = 1;
Instructions.c:342:      input_int("mgunitx",&(E->mesh.mgunitx),"1",m);
Instructions.c:343:      input_int("mgunitz",&(E->mesh.mgunitz),"1",m);
Instructions.c:344:      input_int("mgunity",&(E->mesh.mgunity),"1",m);
Instructions.c:346:      input_int("levels",&(E->mesh.levels),"1",m);
Instructions.c:348:      levmax = E->mesh.levels - 1;
Instructions.c:349:      E->mesh.nox = E->mesh.mgunitx * (int) pow(2.0,levmax) * E->parallel.nprocx + 1;
Instructions.c:350:      E->mesh.noy = E->mesh.mgunity * (int) pow(2.0,levmax) * E->parallel.nprocy + 1;
Instructions.c:351:      E->mesh.noz = E->mesh.mgunitz * (int) pow(2.0,levmax) * E->parallel.nprocz + 1;
Instructions.c:354:  input_double("radius_outer",&(E->sphere.ro),"1",m);
Instructions.c:355:  input_double("radius_inner",&(E->sphere.ri),"0.55",m);
Instructions.c:357:  if(E->sphere.caps == 1) {
Instructions.c:358:      input_double("theta_min",&(E->control.theta_min),"essential",m);
Instructions.c:359:      input_double("theta_max",&(E->control.theta_max),"essential",m);
Instructions.c:360:      input_double("fi_min",&(E->control.fi_min),"essential",m);
Instructions.c:361:      input_double("fi_max",&(E->control.fi_max),"essential",m);
Instructions.c:364:  input_int("coor",&(E->control.coor),"0",m);
Instructions.c:365:  if(E->control.coor == 2){
Instructions.c:370:    E->control.coor_refine[0] = 0.10; /* bottom 10% */
Instructions.c:371:    E->control.coor_refine[1] = 0.15; /* get 15% of the nodes */
Instructions.c:372:    E->control.coor_refine[2] = 0.10; /* top 10% */
Instructions.c:373:    E->control.coor_refine[3] = 0.20; /* get 20% of the nodes */
Instructions.c:374:    input_float_vector("coor_refine",4,E->control.coor_refine,m);
Instructions.c:375:  }else if(E->control.coor == 3){
Instructions.c:385:    input_int("r_grid_layers", &(E->control.rlayers), "1",m);
Instructions.c:386:    if(E->control.rlayers > 20)
Instructions.c:389:    input_float_vector("rr", E->control.rlayers, (E->control.rrlayer),m);
Instructions.c:391:    input_int_vector("nr", E->control.rlayers, (E->control.nrlayer),m);
Instructions.c:394:  input_string("coor_file",E->control.coor_file,"",m);
Instructions.c:397:  input_boolean("node_assemble",&(E->control.NASSEMBLE),"off",m);
Instructions.c:400:  input_boolean("verbose",&(E->control.verbose),"off",m);
Instructions.c:401:  input_boolean("see_convergence",&(E->control.print_convergence),"off",m);
Instructions.c:403:  input_boolean("stokes_flow_only",&(E->control.stokes),"off",m);
Instructions.c:405:  //input_boolean("remove_hor_buoy_avg",&(E->control.remove_hor_buoy_avg),"on",m);
Instructions.c:409:  input_boolean("restart",&(E->control.restart),"off",m);
Instructions.c:410:  input_int("post_p",&(E->control.post_p),"0",m);
Instructions.c:411:  input_int("solution_cycles_init",&(E->monitor.solution_cycles_init),"0",m);
Instructions.c:415:  input_int("num_mat",&(E->viscosity.num_mat),"1",m); /* number of layers, moved
Instructions.c:417:  if(E->viscosity.num_mat > CITCOM_MAX_VISC_LAYER)
Instructions.c:422:  input_float("z_cmb",&(E->viscosity.zcmb),"0.45",m); /* 0.45063569 */
Instructions.c:423:  input_float("z_lmantle",&(E->viscosity.zlm),"0.103594412180191",m); /*0.10359441  */
Instructions.c:424:  input_float("z_410",&(E->viscosity.z410),"0.0643541045361796",m); /* 0.06434, more like it */
Instructions.c:425:  input_float("z_lith",&(E->viscosity.zlith),"0.0156961230576048",m); /* 0.0157, more like it */
Instructions.c:430:  E->viscosity.zbase_layer[0] = E->viscosity.zbase_layer[1] = -999;
Instructions.c:431:  input_float_vector("z_layer",E->viscosity.num_mat,(E->viscosity.zbase_layer),m);
Instructions.c:436:  input_float("start_age",&(E->control.start_age),"0.0",m);
Instructions.c:437:  input_int("reset_startage",&(E->control.reset_startage),"0",m);
Instructions.c:438:  input_int("zero_elapsed_time",&(E->control.zero_elapsed_time),"0",m);
Instructions.c:440:  input_int("output_ll_max",&(E->output.llmax),"1",m);
Instructions.c:442:  input_int("topvbc",&(E->mesh.topvbc),"0",m);
Instructions.c:443:  input_int("botvbc",&(E->mesh.botvbc),"0",m);
Instructions.c:451:  input_int("toplayerbc",&(E->mesh.toplayerbc),"0",m); /* > 0: apply surface boundary condition
Instructions.c:456:  input_float("toplayerbc_r",&(E->mesh.toplayerbc_r),"0.984303876942",m); /* minimum r to apply BC to, 
Instructions.c:462:  input_float("topvbxval",&(E->control.VBXtopval),"0.0",m);
Instructions.c:463:  input_float("botvbxval",&(E->control.VBXbotval),"0.0",m);
Instructions.c:464:  input_float("topvbyval",&(E->control.VBYtopval),"0.0",m);
Instructions.c:465:  input_float("botvbyval",&(E->control.VBYbotval),"0.0",m);
Instructions.c:468:  input_float("T_interior_max_for_exit",&(E->monitor.T_interior_max_for_exit),"1.5",m);
Instructions.c:470:  input_int("pseudo_free_surf",&(E->control.pseudo_free_surf),"0",m);
Instructions.c:472:  input_int("toptbc",&(E->mesh.toptbc),"1",m);
Instructions.c:473:  input_int("bottbc",&(E->mesh.bottbc),"1",m);
Instructions.c:474:  input_float("toptbcval",&(E->control.TBCtopval),"0.0",m);
Instructions.c:475:  input_float("bottbcval",&(E->control.TBCbotval),"1.0",m);
Instructions.c:477:  input_boolean("side_sbcs",&(E->control.side_sbcs),"off",m);
Instructions.c:479:  input_int("file_vbcs",&(E->control.vbcs_file),"0",m);
Instructions.c:480:  input_string("vel_bound_file",E->control.velocity_boundary_file,"",m);
Instructions.c:482:  input_int("file_tbcs",&(E->control.tbcs_file),"0",m);
Instructions.c:483:  input_string("temp_bound_file",E->control.temperature_boundary_file,"",m);
Instructions.c:485:  input_int("reference_state",&(E->refstate.choice),"1",m);
Instructions.c:486:  if(E->refstate.choice == 0) {
Instructions.c:487:      input_string("refstate_file",E->refstate.filename,"refstate.dat",m);
Instructions.c:490:  input_int("mineral_physics_model",&(E->control.mineral_physics_model),"1",m);
Instructions.c:492:  input_int("mat_control",&(E->control.mat_control),"0",m);
Instructions.c:493:  input_string("mat_file",E->control.mat_file,"",m);
Instructions.c:496:  input_boolean("precise_strain_rate",&(E->control.precise_strain_rate),"off",m);
Instructions.c:513:     read in time-constant prefactors from weak.grd netcdf file that apply to top two E->mat layers
Instructions.c:543:  ggrd_init_master(&E->control.ggrd);
Instructions.c:547:	       E->control.ggrd.time_hist.file,"",m); 
Instructions.c:548:  /* if > 0, will use top  E->control.ggrd.mat_control layers and assign a prefactor for the viscosity */
Instructions.c:550:  input_int("ggrd_mat_control",&(E->control.ggrd.mat_control),"0",m); 
Instructions.c:551:  input_boolean("ggrd_mat_limit_prefactor",&(E->control.ggrd_mat_limit_prefactor),"on",m); /* limit prefactor to with 1e+/-5 */
Instructions.c:552:  input_int("ggrd_mat_is_code",&(E->control.ggrd_mat_is_code),"0",m); /* the viscosity grids are
Instructions.c:559:  if(E->control.ggrd_mat_is_code){
Instructions.c:561:    E->control.ggrd_mat_code_viscosities = (float *)malloc(sizeof(float)*E->control.ggrd_mat_is_code);
Instructions.c:562:    for(i=0;i < E->control.ggrd_mat_is_code;i++)
Instructions.c:563:      E->control.ggrd_mat_code_viscosities[i] = 1;
Instructions.c:565:		       E->control.ggrd_mat_is_code,(E->control.ggrd_mat_code_viscosities),m);
Instructions.c:567:  input_string("ggrd_mat_file",E->control.ggrd.mat_file,"",m); /* file to read prefactors from */
Instructions.c:569:	       E->control.ggrd_mat_depth_file,"_i_do_not_exist_",m); 
Instructions.c:570:  if(E->control.ggrd.mat_control != 0) /* this will override mat_control setting */
Instructions.c:571:    E->control.mat_control = 1;
Instructions.c:578:	    &(E->control.ggrd.ray_control),"0",m); 
Instructions.c:580:	       E->control.ggrd.ray_file,"",m); /* file to read prefactors from */
Instructions.c:592:  input_int("ggrd_vtop_control",&(E->control.ggrd.vtop_control),"0",m); 
Instructions.c:593:  input_string("ggrd_vtop_dir",E->control.ggrd.vtop_dir,"",m); /* file to read prefactors from */
Instructions.c:601:  from E->control.ggrd.vtop_dir/rotvec.dat
Instructions.c:603:  and location codes from E->control.ggrd.vtop_dir/code.grd
Instructions.c:610:  input_boolean("ggrd_vtop_euler",&(E->control.ggrd_vtop_euler),"off",m);
Instructions.c:611:  if(E->control.ggrd_vtop_euler)
Instructions.c:612:    E->control.ggrd.vtop_control = 1;
Instructions.c:614:  if(E->control.ggrd.vtop_control) /* this will override mat_control setting */
Instructions.c:615:    E->control.vbcs_file = 1;
Instructions.c:621:  input_boolean("allow_mixed_vbcs",&(E->control.ggrd_allow_mixed_vbcs),"off",m);
Instructions.c:626:  input_boolean("ggrd_comp_smooth",&(E->control.ggrd_comp_smooth),"off",m);
Instructions.c:631:  input_boolean("aug_lagr",&(E->control.augmented_Lagr),"off",m);
Instructions.c:632:  input_double("aug_number",&(E->control.augmented),"0.0",m);
Instructions.c:634:  input_boolean("remove_rigid_rotation",&(E->control.remove_rigid_rotation),"on",m);
Instructions.c:635:  input_boolean("inner_remove_rigid_rotation",&(E->control.inner_remove_rigid_rotation),"off",m);
Instructions.c:636:  input_boolean("remove_angular_momentum",&(E->control.remove_angular_momentum),"on",m);
Instructions.c:638:  input_boolean("self_gravitation",&(E->control.self_gravitation),"off",m);
Instructions.c:639:  input_boolean("use_cbf_topo",&(E->control.use_cbf_topo),"off",m); /* make default on later XXX TWB */
Instructions.c:642:  input_int("storage_spacing",&(E->control.record_every),"10",m);
Instructions.c:643:  input_int("checkpointFrequency",&(E->control.checkpoint_frequency),"100",m);
Instructions.c:644:  input_int("cpu_limits_in_seconds",&(E->control.record_all_until),"5",m);
Instructions.c:645:  input_int("write_q_files",&(E->output.write_q_files),"0",m);/* write additional
Instructions.c:647:  if(E->output.write_q_files){	/* make sure those get written at
Instructions.c:649:    E->output.write_q_files = min(E->output.write_q_files,E->control.record_every);
Instructions.c:653:  input_boolean("precond",&(E->control.precondition),"off",m);
Instructions.c:655:  input_int("mg_cycle",&(E->control.mg_cycle),"2,0,nomax",m);
Instructions.c:656:  input_int("down_heavy",&(E->control.down_heavy),"1,0,nomax",m);
Instructions.c:657:  input_int("up_heavy",&(E->control.up_heavy),"1,0,nomax",m);
Instructions.c:658:  input_double("accuracy",&(E->control.accuracy),"1.0e-4,0.0,1.0",m);
Instructions.c:659:  input_double("inner_accuracy_scale",&(E->control.inner_accuracy_scale),"1.0,0.000001,1.0",m);
Instructions.c:661:  input_boolean("force_iteration",&(E->control.force_iteration),"off",m);
Instructions.c:663:  input_boolean("check_continuity_convergence",&(E->control.check_continuity_convergence),"on",m);
Instructions.c:664:  input_boolean("check_pressure_convergence",&(E->control.check_pressure_convergence),"on",m);
Instructions.c:669:    E->control.check_continuity_convergence = 0;
Instructions.c:670:    E->control.check_pressure_convergence = 0;
Instructions.c:673:  input_int("vhighstep",&(E->control.v_steps_high),"1,0,nomax",m);
Instructions.c:674:  input_int("vlowstep",&(E->control.v_steps_low),"250,0,nomax",m);
Instructions.c:675:  input_int("max_mg_cycles",&(E->control.max_mg_cycles),"50,0,nomax",m);
Instructions.c:676:  input_int("piterations",&(E->control.p_iterations),"100,0,nomax",m);
Instructions.c:678:  input_float("rayleigh",&(E->control.Atemp),"essential",m);
Instructions.c:680:  input_float("dissipation_number",&(E->control.disptn_number),"0.0",m);
Instructions.c:684:      E->control.inv_gruneisen = 1/tmp;
Instructions.c:686:      E->control.inv_gruneisen = 0;
Instructions.c:688:  if(E->control.inv_gruneisen != 0) {
Instructions.c:690:      input_string("uzawa",E->control.uzawa,"cg",m);
Instructions.c:691:      if(strcmp(E->control.uzawa, "cg") == 0) {
Instructions.c:693:          input_int("compress_iter_maxstep",&(E->control.compress_iter_maxstep),"100",m);
Instructions.c:695:      else if(strcmp(E->control.uzawa, "bicg") == 0) {
Instructions.c:701:  input_float("surfaceT",&(E->control.surface_temp),"0.1",m);
Instructions.c:702:  /*input_float("adiabaticT0",&(E->control.adiabaticT0),"0.4",m);*/
Instructions.c:703:  input_float("Q0",&(E->control.Q0),"0.0",m);
Instructions.c:707:  input_float("gravacc",&(E->data.grav_acc),"9.81",m);
Instructions.c:708:  input_float("thermexp",&(E->data.therm_exp),"3.0e-5",m);
Instructions.c:709:  input_float("cp",&(E->data.Cp),"1200.0",m);
Instructions.c:710:  input_float("thermdiff",&(E->data.therm_diff),"1.0e-6",m);
Instructions.c:711:  input_float("density",&(E->data.density),"3340.0",m);
Instructions.c:712:  input_float("density_above",&(E->data.density_above),"1030.0",m);
Instructions.c:713:  input_float("density_below",&(E->data.density_below),"6600.0",m);
Instructions.c:714:  input_float("refvisc",&(E->data.ref_viscosity),"1.0e21",m);
Instructions.c:727:  E->data.ellipticity = ell_tmp;
Instructions.c:728:  if(fabs(E->data.ellipticity) > 5e-7){
Instructions.c:731:    E->data.ra = pow((1.-E->data.ellipticity),-1./3.); /* non dim long axis */
Instructions.c:732:    E->data.rc = 1./(E->data.ra * E->data.ra); /* non dim short axis */
Instructions.c:733:    E->data.efac = (1.-E->data.ellipticity)*(1.-E->data.ellipticity);
Instructions.c:734:    if(E->parallel.me == 0){
Instructions.c:736:	      E->data.ellipticity,E->data.ra,E->data.rc);
Instructions.c:738:    E->data.use_ellipse = 1;
Instructions.c:740:    E->data.ra = E->data.rc = E->data.efac=1.0;
Instructions.c:741:    E->data.use_ellipse = 0;
Instructions.c:747:  input_double("rotation_m",&E->data.rotm,"0.0",m);
Instructions.c:748:  if(fabs(E->data.rotm) > 5e-7){
Instructions.c:750:    E->data.j2 = 2./3.*E->data.ellipticity*(1.-E->data.ellipticity/2.)-
Instructions.c:751:      E->data.rotm/3.*(1.-3./2.*E->data.rotm-2./7.*E->data.ellipticity);
Instructions.c:753:    E->data.ge = 1/(E->data.ra*E->data.ra)*(1+3./2.*E->data.j2-E->data.rotm);
Instructions.c:754:    if(E->parallel.me==0)
Instructions.c:756:	      E->data.rotm,E->data.j2,E->data.ge);
Instructions.c:757:    E->data.use_rotation_g = 1;
Instructions.c:759:    E->data.use_rotation_g = 0;
Instructions.c:767:  E->data.radius_km = tmp / 1e3;
Instructions.c:769:  E->data.therm_cond = E->data.therm_diff * E->data.density * E->data.Cp;
Instructions.c:771:  E->data.ref_temperature = E->control.Atemp * E->data.therm_diff
Instructions.c:772:    * E->data.ref_viscosity
Instructions.c:773:    / (E->data.density * E->data.grav_acc * E->data.therm_exp)
Instructions.c:774:    / (E->data.radius_km * E->data.radius_km * E->data.radius_km * 1e9);
Instructions.c:787:  (E->problem_settings)(E);
Instructions.c:797:    if (E->control.CONJ_GRAD) {
Instructions.c:799:        if(E->mesh.levels != 1)
Instructions.c:804:        if(E->mesh.levels < 2)
Instructions.c:806:        if(E->mesh.levels > MAX_LEVELS)
Instructions.c:812:    if(E->sphere.caps == 12 &&
Instructions.c:813:       (E->control.remove_angular_momentum || E->control.remove_rigid_rotation) &&
Instructions.c:814:       (E->mesh.topvbc || E->mesh.botvbc || E->control.side_sbcs)) {
Instructions.c:815:      if(E->parallel.me == 0)
Instructions.c:820:    if((fabs(E->viscosity.zbase_layer[0]+999) < 1e-5) &&
Instructions.c:821:       (fabs(E->viscosity.zbase_layer[1]+999) < 1e-5)) {
Instructions.c:823:        if(E->viscosity.num_mat != 4)
Instructions.c:826:        E->viscosity.zbase_layer[0] = E->viscosity.zlith;
Instructions.c:827:        E->viscosity.zbase_layer[1] = E->viscosity.z410;
Instructions.c:828:        E->viscosity.zbase_layer[2] = E->viscosity.zlm;
Instructions.c:829:        E->viscosity.zbase_layer[3] = E->viscosity.zcmb; /* the lowest layers is never checked, really 
Instructions.c:835:    if (strcmp(E->output.vtk_format, "binary") == 0) {
Instructions.c:838:        if(E->parallel.me == 0) {
Instructions.c:854:   E->mesh.levmax = E->mesh.levels-1;
Instructions.c:855:   E->mesh.gridmax = E->mesh.levmax;
Instructions.c:857:   E->mesh.elx = E->mesh.nox-1;
Instructions.c:858:   E->mesh.ely = E->mesh.noy-1;
Instructions.c:859:   E->mesh.elz = E->mesh.noz-1;
Instructions.c:861:   if(E->sphere.caps == 1) {
Instructions.c:863:       E->mesh.nno = E->sphere.caps * E->mesh.nox * E->mesh.noy * E->mesh.noz;
Instructions.c:869:       E->mesh.nno = E->sphere.caps * (E->mesh.nox-1) * (E->mesh.noy-1) * E->mesh.noz
Instructions.c:870:           + 2*E->mesh.noz;
Instructions.c:873:   E->mesh.nel = E->sphere.caps*E->mesh.elx*E->mesh.elz*E->mesh.ely;
Instructions.c:875:   E->mesh.nnov = E->mesh.nno;
Instructions.c:879:   E->mesh.neq = E->mesh.nnov*E->mesh.nsd;
Instructions.c:881:   E->mesh.npno = E->mesh.nel;
Instructions.c:882:   E->mesh.nsf = E->mesh.nox*E->mesh.noy;
Instructions.c:884:   for(i=E->mesh.levmax;i>=E->mesh.levmin;i--) {
Instructions.c:885:      nox = E->mesh.mgunitx * (int) pow(2.0,(double)i)*E->parallel.nprocx + 1;
Instructions.c:886:      noy = E->mesh.mgunity * (int) pow(2.0,(double)i)*E->parallel.nprocy + 1;
Instructions.c:887:      noz = E->mesh.mgunitz * (int) pow(2.0,(double)i)*E->parallel.nprocz + 1;
Instructions.c:889:      E->mesh.ELX[i] = nox-1;
Instructions.c:890:      E->mesh.ELY[i] = noy-1;
Instructions.c:891:      E->mesh.ELZ[i] = noz-1;
Instructions.c:892:      if(E->sphere.caps == 1) {
Instructions.c:893:          E->mesh.NNO[i] = nox * noz * noy;
Instructions.c:896:          E->mesh.NNO[i] = E->sphere.caps * (nox-1) * (noy-1) * noz + 2 * noz;
Instructions.c:898:      E->mesh.NEL[i] = E->sphere.caps * (nox-1) * (noz-1) * (noy-1);
Instructions.c:899:      E->mesh.NPNO[i] = E->mesh.NEL[i] ;
Instructions.c:900:      E->mesh.NOX[i] = nox;
Instructions.c:901:      E->mesh.NOZ[i] = noz;
Instructions.c:902:      E->mesh.NOY[i] = noy;
Instructions.c:904:      E->mesh.NNOV[i] = E->mesh.NNO[i];
Instructions.c:905:      E->mesh.NEQ[i] = E->mesh.nsd * E->mesh.NNOV[i] ;
Instructions.c:913:    E->data.scalet = (E->data.radius_km*1e3*E->data.radius_km*1e3/E->data.therm_diff)/(1.e6*365.25*24*3600);
Instructions.c:915:    E->data.scalev = (E->data.radius_km*1e3/E->data.therm_diff)/(100*365.25*24*3600);
Instructions.c:916:    E->data.timedir = E->control.Atemp / fabs(E->control.Atemp);
Instructions.c:919:    if(E->control.print_convergence && E->parallel.me==0) {
Instructions.c:921:                E->mesh.nox, E->mesh.noz, E->mesh.noy, E->mesh.nno, E->mesh.nel);
Instructions.c:922:	fprintf(E->fp,"Problem has %i x %i x %i nodes per cap, %i nodes and %i elements in total\n",
Instructions.c:923:                E->mesh.nox, E->mesh.noz, E->mesh.noy, E->mesh.nno, E->mesh.nel);
Instructions.c:945: for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:947:  npno = E->lmesh.npno;
Instructions.c:948:  nel  = E->lmesh.nel;
Instructions.c:949:  nno  = E->lmesh.nno;
Instructions.c:950:  nsf  = E->lmesh.nsf;
Instructions.c:951:  noz  = E->lmesh.noz;
Instructions.c:952:  nox  = E->lmesh.nox;
Instructions.c:953:  noy  = E->lmesh.noy;
Instructions.c:954:  elx  = E->lmesh.elx;
Instructions.c:955:  ely  = E->lmesh.ely;
Instructions.c:957:  E->P[j]        = (double *) malloc((npno+1)*sizeof(double));
Instructions.c:958:  E->T[j]        = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:959:  E->NP[j]       = (float *) malloc((nno+1)*sizeof(float));
Instructions.c:960:  E->buoyancy[j] = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:962:  E->gstress[j] = (float *) malloc((6*nno+1)*sizeof(float));
Instructions.c:964:  //E->stress[j]   = (float *) malloc((12*nsf+1)*sizeof(float));
Instructions.c:966:  for(i=1;i<=E->mesh.nsd;i++)
Instructions.c:967:      E->sphere.cap[j].TB[i] = (float *)  malloc((nno+1)*sizeof(float));
Instructions.c:969:  E->slice.tpg[j]      = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:970:  E->slice.tpgb[j]     = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:971:  E->slice.divg[j]     = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:972:  E->slice.vort[j]     = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:973:  E->slice.shflux[j]    = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:974:  E->slice.bhflux[j]    = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:975:  /*  if(E->mesh.topvbc==2 && E->control.pseudo_free_surf) */
Instructions.c:976:  E->slice.freesurf[j]    = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:978:  E->mat[j] = (int *) malloc((nel+2)*sizeof(int));
Instructions.c:979:  E->VIP[j] = (float *) malloc((nel+2)*sizeof(float));
Instructions.c:981:  E->heating_adi[j]    = (double *) malloc((nel+1)*sizeof(double));
Instructions.c:982:  E->heating_visc[j]   = (double *) malloc((nel+1)*sizeof(double));
Instructions.c:983:  E->heating_latent[j] = (double *) malloc((nel+1)*sizeof(double));
Instructions.c:986:  E->TMass[j] = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:989:  E->NMass[j] = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:994:  E->sien[j]         = (struct SIEN *) malloc((nxyz+2)*sizeof(struct SIEN));
Instructions.c:995:  E->surf_element[j] = (int *) malloc((nxyz+2)*sizeof(int));
Instructions.c:996:  E->surf_node[j]    = (int *) malloc((nsf+2)*sizeof(int));
Instructions.c:1001:  E->rho      = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:1004:  E->Have.T         = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Instructions.c:1005:  E->Have.V[1]      = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Instructions.c:1006:  E->Have.V[2]      = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Instructions.c:1007:  E->Have.vis      = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Instructions.c:1009:  E->sphere.gr = (double *)malloc((E->mesh.noz+1)*sizeof(double));
Instructions.c:1011: for(i=E->mesh.levmin;i<=E->mesh.levmax;i++) {
Instructions.c:1012:  E->sphere.R[i] = (double *)  malloc((E->lmesh.NOZ[i]+1)*sizeof(double));
Instructions.c:1013:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:1014:    nno  = E->lmesh.NNO[i];
Instructions.c:1015:    npno = E->lmesh.NPNO[i];
Instructions.c:1016:    nel  = E->lmesh.NEL[i];
Instructions.c:1017:    nox = E->lmesh.NOX[i];
Instructions.c:1018:    noz = E->lmesh.NOZ[i];
Instructions.c:1019:    noy = E->lmesh.NOY[i];
Instructions.c:1020:    elx = E->lmesh.ELX[i];
Instructions.c:1021:    ely = E->lmesh.ELY[i];
Instructions.c:1022:    snel=E->lmesh.SNEL[i];
Instructions.c:1024:    for(d=1;d<=E->mesh.nsd;d++)   {
Instructions.c:1025:      E->X[i][j][d]  = (double *)  malloc((nno+1)*sizeof(double));
Instructions.c:1026:      E->SX[i][j][d]  = (double *)  malloc((nno+1)*sizeof(double));
Instructions.c:1030:      E->SinCos[i][j][d]  = (double *)  malloc((nno+1)*sizeof(double));
Instructions.c:1032:    E->IEN[i][j] = (struct IEN *)   malloc((nel+2)*sizeof(struct IEN));
Instructions.c:1033:    E->EL[i][j]  = (struct SUBEL *) malloc((nel+2)*sizeof(struct SUBEL));
Instructions.c:1034:    E->sphere.area1[i][j] = (double *) malloc((snel+1)*sizeof(double));
Instructions.c:1036:      E->sphere.angle1[i][j][k] = (double *) malloc((snel+1)*sizeof(double));
Instructions.c:1038:    E->GNX[i][j] = (struct Shape_function_dx *)malloc((nel+1)*sizeof(struct Shape_function_dx));
Instructions.c:1039:    E->GDA[i][j] = (struct Shape_function_dA *)malloc((nel+1)*sizeof(struct Shape_function_dA));
Instructions.c:1041:    E->MASS[i][j]     = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:1042:    E->ECO[i][j] = (struct COORD *) malloc((nno+2)*sizeof(struct COORD));
Instructions.c:1044:    E->TWW[i][j] = (struct FNODE *)   malloc((nel+2)*sizeof(struct FNODE));
Instructions.c:1046:    for(d=1;d<=E->mesh.nsd;d++)
Instructions.c:1047:      for(l=1;l<=E->lmesh.NNO[i];l++)  {
Instructions.c:1048:        E->SX[i][j][d][l] = 0.0;
Instructions.c:1049:        E->X[i][j][d][l] = 0.0;
Instructions.c:1055: for(i=0;i<=E->output.llmax;i++)
Instructions.c:1056:  E->sphere.hindex[i] = (int *) malloc((E->output.llmax+3)
Instructions.c:1060: for(i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)
Instructions.c:1061:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:1063:    nno  = E->lmesh.NNO[i];
Instructions.c:1064:    npno = E->lmesh.NPNO[i];
Instructions.c:1065:    nel  = E->lmesh.NEL[i];
Instructions.c:1066:    nox = E->lmesh.NOX[i];
Instructions.c:1067:    noz = E->lmesh.NOZ[i];
Instructions.c:1068:    noy = E->lmesh.NOY[i];
Instructions.c:1069:    elx = E->lmesh.ELX[i];
Instructions.c:1070:    ely = E->lmesh.ELY[i];
Instructions.c:1073:    E->CC[i][j] =(struct CC *)  malloc((1)*sizeof(struct CC));
Instructions.c:1074:    E->CCX[i][j]=(struct CCX *)  malloc((1)*sizeof(struct CCX));
Instructions.c:1076:    E->elt_del[i][j] = (struct EG *) malloc((nel+1)*sizeof(struct EG));
Instructions.c:1078:    if(E->control.inv_gruneisen != 0)
Instructions.c:1079:        E->elt_c[i][j] = (struct EC *) malloc((nel+1)*sizeof(struct EC));
Instructions.c:1081:    E->EVI[i][j] = (float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:1082:    E->BPI[i][j] = (double *) malloc((npno+1)*sizeof(double));
Instructions.c:1084:    E->ID[i][j]  = (struct ID *)    malloc((nno+1)*sizeof(struct ID));
Instructions.c:1085:    E->VI[i][j]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:1086:    E->NODE[i][j] = (unsigned int *)malloc((nno+1)*sizeof(unsigned int));
Instructions.c:1094:    E->parallel.EXCHANGE_sNODE[i][j] = (struct PASS *) malloc((nozl+2)*sizeof(struct PASS));
Instructions.c:1095:    E->parallel.NODE[i][j]   = (struct BOUND *) malloc((nxyz+2)*sizeof(struct BOUND));
Instructions.c:1096:    E->parallel.EXCHANGE_NODE[i][j]= (struct PASS *) malloc((nxyz+2)*sizeof(struct PASS));
Instructions.c:1097:    E->parallel.EXCHANGE_ID[i][j] = (struct PASS *) malloc((nxyz*E->mesh.nsd+3)*sizeof(struct PASS));
Instructions.c:1099:    for(l=1;l<=E->lmesh.NNO[i];l++)  {
Instructions.c:1100:      E->NODE[i][j][l] = (INTX | INTY | INTZ);  /* and any others ... */
Instructions.c:1101:      E->VI[i][j][l] = 1.0;
Instructions.c:1108: if(E->viscosity.allow_anisotropic_viscosity){ /* any anisotropic
Instructions.c:1110:   for(i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)
Instructions.c:1111:     for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:1112:       nel  = E->lmesh.NEL[i];
Instructions.c:1113:       nno  = E->lmesh.NNO[i];
Instructions.c:1114:       E->EVI2[i][j] = (float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:1115:       E->avmode[i][j] = (unsigned char *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(unsigned char));
Instructions.c:1116:       E->EVIn1[i][j] = (float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:1117:       E->EVIn2[i][j] = (float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:1118:       E->EVIn3[i][j] = (float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:1120:       E->VI2[i][j]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:1121:       E->VIn1[i][j]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:1122:       E->VIn2[i][j]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:1123:       E->VIn3[i][j]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:1124:       if((!(E->EVI2[i][j]))||(!(E->VI2[i][j]))||
Instructions.c:1125:	  (!(E->EVIn1[i][j]))||(!(E->EVIn2[i][j]))||(!(E->EVIn3[i][j]))||
Instructions.c:1126:	  (!(E->VIn1[i][j]))||(!(E->VIn2[i][j]))||(!(E->VIn3[i][j]))){
Instructions.c:1128:		 E->parallel.me);
Instructions.c:1132:   E->viscosity.anisotropic_viscosity_init = FALSE;
Instructions.c:1136: for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:1138:  for(k=1;k<=E->mesh.nsd;k++)
Instructions.c:1139:    for(i=1;i<=E->lmesh.nno;i++)
Instructions.c:1140:      E->sphere.cap[j].TB[k][i] = 0.0;
Instructions.c:1142:  for(i=1;i<=E->lmesh.nno;i++)
Instructions.c:1143:     E->T[j][i] = 0.0;
Instructions.c:1145:  for(i=1;i<=E->lmesh.nel;i++)   {
Instructions.c:1146:      E->mat[j][i]=1;
Instructions.c:1147:      E->VIP[j][i]=1.0;
Instructions.c:1149:      E->heating_adi[j][i] = 0;
Instructions.c:1150:      E->heating_visc[j][i] = 0;
Instructions.c:1151:      E->heating_latent[j][i] = 1.0;
Instructions.c:1154:  for(i=1;i<=E->lmesh.npno;i++)
Instructions.c:1155:      E->P[j][i] = 0.0;
Instructions.c:1163:  if (strcmp(E->output.format, "hdf5") == 0)
Instructions.c:1177:    E->monitor.incompressibility = 0;
Instructions.c:1178:    E->monitor.fdotf = 0;
Instructions.c:1179:    E->monitor.vdotv = 0;
Instructions.c:1180:    E->monitor.pdotp = 0;
Instructions.c:1184:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Instructions.c:1185:    E->lmesh.nnov = E->lmesh.nno;
Instructions.c:1186:    E->lmesh.neq = E->lmesh.nnov * E->mesh.nsd;
Instructions.c:1188:    E->temp[j] = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Instructions.c:1189:    E->temp1[j] = (double *) malloc(E->lmesh.neq*sizeof(double));
Instructions.c:1190:    E->F[j] = (double *) malloc(E->lmesh.neq*sizeof(double));
Instructions.c:1191:    E->U[j] = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Instructions.c:1192:    E->u1[j] = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Instructions.c:1195:    for(i=1;i<=E->mesh.nsd;i++) {
Instructions.c:1196:      E->sphere.cap[j].V[i] = (float *) malloc((E->lmesh.nnov+1)*sizeof(float));
Instructions.c:1197:      E->sphere.cap[j].VB[i] = (float *)malloc((E->lmesh.nnov+1)*sizeof(float));
Instructions.c:1198:      E->sphere.cap[j].Vprev[i] = (float *) malloc((E->lmesh.nnov+1)*sizeof(float));
Instructions.c:1201:    for(i=0;i<E->lmesh.neq;i++)
Instructions.c:1202:      E->U[j][i] = E->temp[j][i] = E->temp1[j][i] = 0.0;
Instructions.c:1205:    for(k=1;k<=E->mesh.nsd;k++)
Instructions.c:1206:      for(i=1;i<=E->lmesh.nnov;i++)
Instructions.c:1207:        E->sphere.cap[j].VB[k][i] = 0.0;
Instructions.c:1211:  for(l=E->mesh.gridmin;l<=E->mesh.gridmax;l++)
Instructions.c:1212:    for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Instructions.c:1213:      E->lmesh.NEQ[l] = E->lmesh.NNOV[l] * E->mesh.nsd;
Instructions.c:1215:      E->BI[l][j] = (double *) malloc((E->lmesh.NEQ[l])*sizeof(double));
Instructions.c:1216:      k = (E->lmesh.NOX[l]*E->lmesh.NOZ[l]+E->lmesh.NOX[l]*E->lmesh.NOY[l]+
Instructions.c:1217:          E->lmesh.NOY[l]*E->lmesh.NOZ[l])*6;
Instructions.c:1218:      E->zero_resid[l][j] = (int *) malloc((k+2)*sizeof(int));
Instructions.c:1219:      E->parallel.Skip_id[l][j] = (int *) malloc((k+2)*sizeof(int));
Instructions.c:1221:      for(i=0;i<E->lmesh.NEQ[l];i++) {
Instructions.c:1222:         E->BI[l][j][i]=0.0;
Instructions.c:1239:  E->control.v_steps_low = 10;
Instructions.c:1240:  E->control.v_steps_upper = 1;
Instructions.c:1241:  E->control.accuracy = 1.0e-4;
Instructions.c:1242:  E->control.verbose=0; /* debugging/profiles */
Instructions.c:1246:    E->control.stokes=0;
Instructions.c:1247:    E->control.restart=0;
Instructions.c:1248:    E->control.CONVECTION = 0;
Instructions.c:1249:    E->control.CART2D = 0;
Instructions.c:1250:    E->control.CART3D = 0;
Instructions.c:1251:    E->control.CART2pt5D = 0;
Instructions.c:1252:    E->control.AXI = 0;
Instructions.c:1253:    E->control.CONJ_GRAD = 0;
Instructions.c:1254:    E->control.NMULTIGRID = 0;
Instructions.c:1255:    E->control.augmented_Lagr = 0;
Instructions.c:1256:    E->control.augmented = 0.0;
Instructions.c:1258:    E->trace.fpt = NULL;
Instructions.c:1259:    E->control.tracer = 0;
Instructions.c:1260:    E->composition.on = 0;
Instructions.c:1262:  E->parallel.nprocx=1; E->parallel.nprocz=1; E->parallel.nprocy=1;
Instructions.c:1264:  E->mesh.levmax=0;
Instructions.c:1265:  E->mesh.levmin=0;
Instructions.c:1266:  E->mesh.gridmax=0;
Instructions.c:1267:  E->mesh.gridmin=0;
Instructions.c:1268:  E->mesh.noz = 1;    E->mesh.nzs = 1;  E->lmesh.noz = 1;    E->lmesh.nzs = 1;
Instructions.c:1269:  E->mesh.noy = 1;    E->mesh.nys = 1;  E->lmesh.noy = 1;    E->lmesh.nys = 1;
Instructions.c:1270:  E->mesh.nox = 1;    E->mesh.nxs = 1;  E->lmesh.nox = 1;    E->lmesh.nxs = 1;
Instructions.c:1272:  E->sphere.ro = 1.0;
Instructions.c:1273:  E->sphere.ri = 0.5;
Instructions.c:1275:  E->control.precondition = 0;  /* for larger visc contrasts turn this back on  */
Instructions.c:1277:  E->mesh.toptbc = 1; /* fixed t */
Instructions.c:1278:  E->mesh.bottbc = 1;
Instructions.c:1279:  E->mesh.topvbc = 0; /* stress */
Instructions.c:1280:  E->mesh.botvbc = 0;
Instructions.c:1281:  E->control.VBXtopval=0.0;
Instructions.c:1282:  E->control.VBYtopval=0.0;
Instructions.c:1283:  E->control.VBXbotval=0.0;
Instructions.c:1284:  E->control.VBYbotval=0.0;
Instructions.c:1286:  E->data.radius_km = 6370.0; /* Earth, whole mantle defaults */
Instructions.c:1287:  E->data.grav_acc = 9.81;
Instructions.c:1288:  E->data.therm_diff = 1.0e-6;
Instructions.c:1289:  E->data.therm_exp = 3.e-5;
Instructions.c:1290:  E->data.density = 3300.0;
Instructions.c:1291:  E->data.ref_viscosity=1.e21;
Instructions.c:1292:  E->data.density_above = 1000.0;    /* sea water */
Instructions.c:1293:  E->data.density_below = 6600.0;    /* sea water */
Instructions.c:1295:  E->data.Cp = 1200.0;
Instructions.c:1296:  E->data.therm_cond = 3.168;
Instructions.c:1297:  E->data.res_density = 3300.0;  /* density when X = ... */
Instructions.c:1298:  E->data.res_density_X = 0.3;
Instructions.c:1299:  E->data.melt_density = 2800.0;
Instructions.c:1300:  E->data.permeability = 3.0e-10;
Instructions.c:1301:  E->data.gas_const = 8.3;
Instructions.c:1302:  E->data.surf_heat_flux = 4.4e-2;
Instructions.c:1304:  E->data.grav_const = 6.6742e-11;
Instructions.c:1306:  E->data.youngs_mod = 1.0e11;
Instructions.c:1307:  E->data.Te = 0.0;
Instructions.c:1308:  E->data.T_sol0 = 1373.0;      /* Dave's values 1991 (for the earth) */
Instructions.c:1309:  E->data.Tsurf = 273.0;
Instructions.c:1310:  E->data.dTsol_dz = 3.4e-3 ;
Instructions.c:1311:  E->data.dTsol_dF = 440.0;
Instructions.c:1312:  E->data.dT_dz = 0.48e-3;
Instructions.c:1313:  E->data.delta_S = 250.0;
Instructions.c:1314:  E->data.ref_temperature = 2 * 1350.0; /* fixed temperature ... delta T */
Instructions.c:1318:    sprintf(E->control.data_prefix,"citcom.tmp.%d",getpid());
Instructions.c:1320:    E->control.NASSEMBLE = 0;
Instructions.c:1322:    E->monitor.elapsed_time=0.0;
Instructions.c:1324:    E->control.record_all_until = 10000000;
Instructions.c:1338:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:1339:    for(i=1;i<=E->lmesh.nno;i++)    {
Instructions.c:1340:      if ((E->node[j][i] & VBX) && (E->node[j][i] & SBX))
Instructions.c:1342:      if ((E->node[j][i] & VBZ) && (E->node[j][i] & SBZ))
Instructions.c:1344:      if ((E->node[j][i] & VBY) && (E->node[j][i] & SBY))
Instructions.c:1346:      if ((E->node[j][i] & TBX) && (E->node[j][i] & FBX))
Instructions.c:1348:      if ((E->node[j][i] & TBZ) && (E->node[j][i] & FBZ))
Instructions.c:1350:      if ((E->node[j][i] & TBY) && (E->node[j][i] & FBY))
Instructions.c:1355:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Instructions.c:1356:    for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:1357:      for(i=1;i<=E->lmesh.NNO[lev];i++)        {
Instructions.c:1358:        if ((E->NODE[lev][j][i] & VBX) && (E->NODE[lev][j][i]  & SBX))
Instructions.c:1360:        if ((E->NODE[lev][j][i] & VBZ) && (E->NODE[lev][j][i]  & SBZ))
Instructions.c:1362:        if ((E->NODE[lev][j][i] & VBY) && (E->NODE[lev][j][i]  & SBY))
Instructions.c:1381:  E->eco[j] = E->ECO[E->mesh.levmax][j];
Instructions.c:1382:  E->ien[j] = E->IEN[E->mesh.levmax][j];
Instructions.c:1383:  E->id[j] = E->ID[E->mesh.levmax][j];
Instructions.c:1384:  E->Vi[j] = E->VI[E->mesh.levmax][j];
Instructions.c:1385:  E->EVi[j] = E->EVI[E->mesh.levmax][j];
Instructions.c:1386:  E->node[j] = E->NODE[E->mesh.levmax][j];
Instructions.c:1387:  E->cc[j] = E->CC[E->mesh.levmax][j];
Instructions.c:1388:  E->ccx[j] = E->CCX[E->mesh.levmax][j];
Instructions.c:1389:  E->Mass[j] = E->MASS[E->mesh.levmax][j];
Instructions.c:1390:  E->gDA[j] = E->GDA[E->mesh.levmax][j];
Instructions.c:1391:  E->gNX[j] = E->GNX[E->mesh.levmax][j];
Instructions.c:1393:  for (i=1;i<=E->mesh.nsd;i++)    {
Instructions.c:1394:    E->x[j][i] = E->X[E->mesh.levmax][j][i];
Instructions.c:1395:    E->sx[j][i] = E->SX[E->mesh.levmax][j][i];
Instructions.c:1403:{ if(E->control.verbose && E->parallel.me==0)
Instructions.c:1413:{ if(E->control.verbose && E->fp)
Instructions.c:1414:    { fprintf(E->fp,"%s\n",string);
Instructions.c:1415:      fflush(E->fp);
Instructions.c:1455:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Instructions.c:1456:    for(i=1;i<=E->lmesh.npno;i++)
Instructions.c:1457:      E->P[m][i]=0.0;
Instructions.c:1468:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Instructions.c:1469:    for(i=1;i<=E->lmesh.nnov;i++)   {
Instructions.c:1470:        E->sphere.cap[m].V[1][i]=0.0;
Instructions.c:1471:        E->sphere.cap[m].V[2][i]=0.0;
Instructions.c:1472:        E->sphere.cap[m].V[3][i]=0.0;
Instructions.c:1484:  E->fp = NULL;
Instructions.c:1485:  if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1486:    sprintf(logfile,"%s/log", E->control.data_dir);
Instructions.c:1488:    sprintf(logfile,"%s.log", E->control.data_file);
Instructions.c:1490:  if (E->control.restart || E->control.post_p)
Instructions.c:1492:      E->fp = output_open(logfile, "a");
Instructions.c:1494:      E->fp = output_open(logfile, "w");
Instructions.c:1504:  E->fptime = NULL;
Instructions.c:1505:  if (E->parallel.me == 0) {
Instructions.c:1506:  if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1507:    sprintf(timeoutput,"%s/time", E->control.data_dir);
Instructions.c:1509:    sprintf(timeoutput,"%s.time", E->control.data_file);
Instructions.c:1511:  if (E->control.restart || E->control.post_p)
Instructions.c:1513:      E->fptime = output_open(timeoutput, "a");
Instructions.c:1515:      E->fptime = output_open(timeoutput, "w");
Instructions.c:1526:  E->fp_out = NULL;
Instructions.c:1527:  if (E->control.verbose) {
Instructions.c:1528:  if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1529:    sprintf(output_file,"%s/info.%d", E->control.data_dir, E->parallel.me);
Instructions.c:1531:    sprintf(output_file,"%s.info.%d", E->control.data_file, E->parallel.me);
Instructions.c:1532:  E->fp_out = output_open(output_file, "w");
Instructions.c:1544:  if((E->parallel.me_loc[3] == E->parallel.nprocz-1) &&
Instructions.c:1545:     (E->parallel.me==E->parallel.nprocz-1)){
Instructions.c:1547:    if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1548:      sprintf(output_file,"%s/qt.dat", E->control.data_dir);
Instructions.c:1550:      sprintf(output_file,"%s.qt.dat", E->control.data_file);
Instructions.c:1551:    if(E->control.restart)
Instructions.c:1552:      E->output.fpqt = output_open(output_file, "a"); /* append for restart */
Instructions.c:1554:      E->output.fpqt = output_open(output_file, "w");
Instructions.c:1556:    E->output.fpqt = NULL;
Instructions.c:1558:  if (E->parallel.me_loc[3] == 0)    {
Instructions.c:1560:    if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1561:      sprintf(output_file,"%s/qb.dat", E->control.data_dir);
Instructions.c:1563:      sprintf(output_file,"%s.qb.dat", E->control.data_file);
Instructions.c:1564:    if(E->control.restart)
Instructions.c:1565:      E->output.fpqb = output_open(output_file, "a"); /* append */
Instructions.c:1567:      E->output.fpqb = output_open(output_file, "w");
Instructions.c:1569:    E->output.fpqb = NULL;
Instructions.c:1584:    len = strlen(E->output.optional);
Instructions.c:1587:    next = E->output.optional;
Instructions.c:1589:    E->output.connectivity = 0;
Instructions.c:1590:    E->output.stress = 0;
Instructions.c:1591:    E->output.pressure = 0;
Instructions.c:1592:    E->output.surf = 0;
Instructions.c:1593:    E->output.botm = 0;
Instructions.c:1594:    E->output.geoid = 0;
Instructions.c:1595:    E->output.horiz_avg = 0;
Instructions.c:1596:    E->output.seismic = 0;
Instructions.c:1597:    E->output.coord_bin = 0;
Instructions.c:1598:    E->output.tracer = 0;
Instructions.c:1599:    E->output.comp_el = 0;
Instructions.c:1600:    E->output.comp_nd = 0;
Instructions.c:1601:    E->output.heating = 0;
Instructions.c:1621:            E->output.connectivity = 1;
Instructions.c:1623:            E->output.stress = 1;
Instructions.c:1625:            E->output.pressure = 1;
Instructions.c:1627:            E->output.surf = 1;
Instructions.c:1629:            E->output.botm = 1;
Instructions.c:1631:	    if (E->parallel.nprocxy != 12) {
Instructions.c:1637:		E->output.geoid  = 1;
Instructions.c:1640:            E->output.horiz_avg = 1;
Instructions.c:1642:            E->output.seismic = E->output.coord_bin = 1;
Instructions.c:1646:            if(E->parallel.me==0) {
Instructions.c:1647:                fprintf(stderr, "Total temperature contrast = %f K\n", E->data.ref_temperature);
Instructions.c:1648:                fprintf(E->fp, "Total temperature contrast = %f K\n", E->data.ref_temperature);
Instructions.c:1652:            E->output.tracer = 1;
Instructions.c:1654:            E->output.comp_el = 1;
Instructions.c:1656:            E->output.comp_nd = 1;
Instructions.c:1658:            E->output.heating = 1;
Instructions.c:1660:            if(E->parallel.me == 0)
Instructions.c:1668:/* check whether E->control.data_file contains a path seperator */
Instructions.c:1673:  found = strchr(E->control.data_prefix, '/');
Instructions.c:1675:      fprintf(stderr, "error in input parameter: datafile='%s' contains '/'\n", E->control.data_file);
Instructions.c:1679:  if (E->control.restart || E->control.post_p ||
Instructions.c:1680:      (E->convection.tic_method == -1) ||
Instructions.c:1681:      (E->control.tracer && (E->trace.ic_method == 2))) {
Instructions.c:1682:      found = strchr(E->control.data_prefix_old, '/');
Instructions.c:1684:	  fprintf(stderr, "error in input parameter: datafile_old='%s' contains '/'\n", E->control.data_file);
Instructions.c:1742:	sprintf(tmp, "%d", E->parallel.me);
Instructions.c:1778:    expand_datadir(E, E->control.data_dir);
Instructions.c:1779:    mkdatadir(E->control.data_dir);
Instructions.c:1780:    snprintf(E->control.data_file, 200, "%s/%s", E->control.data_dir,
Instructions.c:1781:	     E->control.data_prefix);
Instructions.c:1783:    if (E->control.restart || E->control.post_p ||
Instructions.c:1784:        (E->convection.tic_method == -1) ||
Instructions.c:1785:        (E->control.tracer && (E->trace.ic_method == 2))) {
Instructions.c:1786:	expand_datadir(E, E->control.data_dir_old);
Instructions.c:1787:	snprintf(E->control.old_P_file, 200, "%s/%s", E->control.data_dir_old,
Instructions.c:1788:		 E->control.data_prefix_old);
Instructions.c:1795:    if (strcmp(E->output.format, "ascii") == 0) {
Instructions.c:1796:        E->problem_output = output;
Instructions.c:1798:    else if (strcmp(E->output.format, "hdf5") == 0)
Instructions.c:1799:        E->problem_output = h5output;
Instructions.c:1800:    else if (strcmp(E->output.format, "vtk") == 0)
Instructions.c:1801:        E->problem_output = vtk_output;
Instructions.c:1803:    else if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1804:        E->problem_output = gzdir_output;
Instructions.c:1807:        if (E->parallel.me == 0) {
Instructions.c:1809:            fprintf(E->fp, "wrong output_format, must be  'ascii', 'hdf5' 'ascii-gz', or 'vtk'\n");
Instructions.c:1816:        if (E->parallel.me == 0) {
Instructions.c:1818:            fprintf(E->fp, "wrong output_format, must be 'ascii', 'hdf5', or 'vtk' (USE_GZDIR undefined)\n");
Instructions.c:1832:  if (E->fp)
Instructions.c:1833:    fclose(E->fp);
Instructions.c:1834:  if (E->fptime)
Instructions.c:1835:    fclose(E->fptime);
Instructions.c:1836:  if (E->fp_out)
Instructions.c:1837:    fclose(E->fp_out);
Instructions.c:1838:  if (E->trace.fpt)
Instructions.c:1839:    fclose(E->trace.fpt);
Instructions.c:1840:  if(E->output.fpqt)
Instructions.c:1841:    fclose(E->output.fpqt);
Instructions.c:1842:  if(E->output.fpqb)
Instructions.c:1843:    fclose(E->output.fpqb);
Instructions.c:1849:  if((E->output.gzdir.vtk_io != 0) &&
Instructions.c:1850:     (strcmp(E->output.format, "ascii-gz") == 0)){
Instructions.c:1851:    if((E->output.gzdir.vtk_io == 3)||(E->parallel.me == 0)){
Instructions.c:1855:      if(E->parallel.me == 0){
Instructions.c:1857:	if(E->output.gzdir.vtk_fp)
Instructions.c:1858:	  fclose(E->output.gzdir.vtk_fp);
Instructions.c:1893:  if(E->parallel.me == 0) {
Instructions.c:1894:    sprintf(filename, "pid%09d", E->control.PID);
Instructions.c:1899:    fprintf(fp, "minstep=%d\n", E->advection.min_timesteps);
Instructions.c:1900:    fprintf(fp, "maxstep=%d\n", E->advection.max_timesteps);
Instructions.c:1901:    fprintf(fp, "maxtotstep=%d\n", E->advection.max_total_timesteps);
Instructions.c:1902:    fprintf(fp, "cpu_limits_in_seconds=%d\n", E->control.record_all_until);
Instructions.c:1907:    fprintf(fp, "storage_spacing=%d\n", E->control.record_every);
Instructions.c:1908:    fprintf(fp, "checkpointFrequency=%d\n", E->control.checkpoint_frequency);
Instructions.c:1913:    fprintf(fp, "datadir=%s\n", E->control.data_dir);
Instructions.c:1914:    fprintf(fp, "datafile=%s\n", E->control.data_prefix);
Instructions.c:1915:    fprintf(fp, "datadir_old=%s\n", E->control.data_dir_old);
Instructions.c:1916:    fprintf(fp, "datafile_old=%s\n", E->control.data_prefix_old);
Instructions.c:1917:    fprintf(fp, "rayleigh=%g\n", E->control.Atemp);
Instructions.c:1918:    fprintf(fp, "dissipation_number=%g\n", E->control.disptn_number);
Instructions.c:1919:    if(E->control.inv_gruneisen != 0)
Instructions.c:1920:      tmp = 1.0/E->control.inv_gruneisen;
Instructions.c:1922:    fprintf(fp, "surfaceT=%g\n", E->control.surface_temp);
Instructions.c:1923:    fprintf(fp, "Q0=%g\n", E->control.Q0);
Instructions.c:1924:    fprintf(fp, "stokes_flow_only=%d\n", E->control.stokes);
Instructions.c:1925:    fprintf(fp, "verbose=%d\n", E->control.verbose);
Instructions.c:1926:    fprintf(fp, "see_convergence=%d\n", E->control.print_convergence);
Instructions.c:1931:    fprintf(fp, "nproc_surf=%d\n", E->parallel.nprocxy);
Instructions.c:1932:    fprintf(fp, "nprocx=%d\n", E->parallel.nprocx);
Instructions.c:1933:    fprintf(fp, "nprocy=%d\n", E->parallel.nprocy);
Instructions.c:1934:    fprintf(fp, "nprocz=%d\n", E->parallel.nprocz);
Instructions.c:1935:    fprintf(fp, "coor=%d\n", E->control.coor);
Instructions.c:1936:    fprintf(fp, "coor_file=%s\n", E->control.coor_file);
Instructions.c:1939:      fprintf(fp, "%g,", E->control.coor_refine[i]);
Instructions.c:1940:    fprintf(fp, "%g\n", E->control.coor_refine[3]);
Instructions.c:1941:    fprintf(fp, "nodex=%d\n", E->mesh.nox);
Instructions.c:1942:    fprintf(fp, "nodey=%d\n", E->mesh.noy);
Instructions.c:1943:    fprintf(fp, "nodez=%d\n", E->mesh.noz);
Instructions.c:1944:    fprintf(fp, "levels=%d\n", E->mesh.levels);
Instructions.c:1945:    fprintf(fp, "mgunitx=%d\n", E->mesh.mgunitx);
Instructions.c:1946:    fprintf(fp, "mgunity=%d\n", E->mesh.mgunity);
Instructions.c:1947:    fprintf(fp, "mgunitz=%d\n", E->mesh.mgunitz);
Instructions.c:1948:    fprintf(fp, "radius_outer=%g\n", E->sphere.ro);
Instructions.c:1949:    fprintf(fp, "radius_inner=%g\n", E->sphere.ri);
Instructions.c:1950:    fprintf(fp, "theta_min=%g\n", E->control.theta_min);
Instructions.c:1951:    fprintf(fp, "theta_max=%g\n", E->control.theta_max);
Instructions.c:1952:    fprintf(fp, "fi_min=%g\n", E->control.fi_min);
Instructions.c:1953:    fprintf(fp, "fi_max=%g\n", E->control.fi_max);
Instructions.c:1954:    fprintf(fp, "r_grid_layers=%d\n", E->control.rlayers);
Instructions.c:1956:    if(E->control.rlayers > 0)
Instructions.c:1958:      for(i=0; i<E->control.rlayers-1;i++)
Instructions.c:1959:	fprintf(fp, "%g,", E->control.rrlayer[i]);
Instructions.c:1960:      fprintf(fp, "%g\n", E->control.rrlayer[E->control.rlayers-1]);
Instructions.c:1967:    if(E->control.rlayers > 0)
Instructions.c:1969:      for(i=0; i<E->control.rlayers-1;i++)
Instructions.c:1970:        fprintf(fp, "%d,", E->control.nrlayer[i]);
Instructions.c:1971:      fprintf(fp, "%d\n", E->control.nrlayer[E->control.rlayers-1]);
Instructions.c:1980:    fprintf(fp, "ADV=%d\n", E->advection.ADVECTION);
Instructions.c:1981:    fprintf(fp, "filter_temp=%d\n", E->advection.filter_temperature);
Instructions.c:1982:    fprintf(fp, "monitor_max_T=%d\n", E->advection.monitor_max_T);
Instructions.c:1983:    fprintf(fp, "finetunedt=%f\n", E->advection.fine_tune_dt);
Instructions.c:1984:    fprintf(fp, "fixed_timestep=%f\n", E->advection.fixed_timestep);
Instructions.c:1985:    fprintf(fp, "adv_gamma=%f\n", E->advection.gamma);
Instructions.c:1986:    fprintf(fp, "adv_sub_iterations=%d\n", E->advection.temp_iterations);
Instructions.c:1987:    fprintf(fp, "inputdiffusivity=%f\n", E->control.inputdiff);
Instructions.c:1991:    fprintf(fp, "Solver=%s\n", E->control.SOLVER_TYPE); 
Instructions.c:1992:    fprintf(fp, "node_assemble=%d\n", E->control.NASSEMBLE);
Instructions.c:1993:    fprintf(fp, "precond=%d\n", E->control.precondition);
Instructions.c:1994:    fprintf(fp, "accuracy=%g\n", E->control.accuracy);
Instructions.c:1995:    fprintf(fp, "uzawa=%s\n", E->control.uzawa);
Instructions.c:1996:    fprintf(fp, "compress_iter_maxstep=%d\n", E->control.compress_iter_maxstep);
Instructions.c:1997:    fprintf(fp, "mg_cycle=%d\n", E->control.mg_cycle);
Instructions.c:1998:    fprintf(fp, "down_heavy=%d\n", E->control.down_heavy);
Instructions.c:1999:    fprintf(fp, "up_heavy=%d\n", E->control.up_heavy);
Instructions.c:2000:    fprintf(fp, "vlowstep=%d\n", E->control.v_steps_low);
Instructions.c:2001:    fprintf(fp, "vhighstep=%d\n", E->control.v_steps_high);
Instructions.c:2002:    fprintf(fp, "max_mg_cycles=%d\n", E->control.max_mg_cycles);
Instructions.c:2003:    fprintf(fp, "piterations=%d\n", E->control.p_iterations);
Instructions.c:2004:    fprintf(fp, "aug_lagr=%d\n", E->control.augmented_Lagr);
Instructions.c:2005:    fprintf(fp, "aug_number=%g\n", E->control.augmented);
Instructions.c:2006:    fprintf(fp, "remove_rigid_rotation=%d\n", E->control.remove_rigid_rotation);
Instructions.c:2008:                E->control.remove_angular_momentum);
Instructions.c:2010:                E->control.inner_accuracy_scale);
Instructions.c:2012:                E->control.check_continuity_convergence);
Instructions.c:2014:                E->control.check_pressure_convergence);
Instructions.c:2016:                E->control.inner_remove_rigid_rotation);
Instructions.c:2020:    fprintf(fp, "side_sbcs=%d\n", E->control.side_sbcs);
Instructions.c:2021:    fprintf(fp, "pseudo_free_surf=%d\n", E->control.pseudo_free_surf);
Instructions.c:2022:    fprintf(fp, "topvbc=%d\n", E->mesh.topvbc);
Instructions.c:2023:    fprintf(fp, "topvbxval=%g\n", E->control.VBXtopval);
Instructions.c:2024:    fprintf(fp, "topvbyval=%g\n", E->control.VBYtopval);
Instructions.c:2025:    fprintf(fp, "botvbc=%d\n", E->mesh.botvbc);
Instructions.c:2026:    fprintf(fp, "botvbxval=%g\n", E->control.VBXbotval);
Instructions.c:2027:    fprintf(fp, "botvbyval=%g\n", E->control.VBYbotval);
Instructions.c:2028:    fprintf(fp, "toptbc=%d\n", E->mesh.toptbc);
Instructions.c:2029:    fprintf(fp, "toptbcval=%g\n", E->control.TBCtopval);
Instructions.c:2030:    fprintf(fp, "bottbc=%d\n", E->mesh.bottbc);
Instructions.c:2031:    fprintf(fp, "bottbcval=%g\n", E->control.TBCbotval);
Instructions.c:2032:    fprintf(fp, "temperature_bound_adj=%d\n", E->control.temperature_bound_adj);
Instructions.c:2033:    fprintf(fp, "depth_bound_adj=%g\n", E->control.depth_bound_adj);
Instructions.c:2034:    fprintf(fp, "width_bound_adj=%g\n", E->control.width_bound_adj);
Instructions.c:2038:    fprintf(fp, "radius=%g\n", E->data.radius_km*1000.0);
Instructions.c:2039:    fprintf(fp, "density=%g\n", E->data.density);
Instructions.c:2040:    fprintf(fp, "thermdiff=%g\n", E->data.therm_diff);
Instructions.c:2041:    fprintf(fp, "gravacc=%g\n", E->data.grav_acc);
Instructions.c:2042:    fprintf(fp, "thermexp=%g\n", E->data.therm_exp);
Instructions.c:2043:    fprintf(fp, "refvisc=%g\n", E->data.ref_viscosity);
Instructions.c:2044:    fprintf(fp, "cp=%g\n", E->data.Cp);
Instructions.c:2045:    fprintf(fp, "density_above=%g\n", E->data.density_above);
Instructions.c:2046:    fprintf(fp, "density_below=%g\n", E->data.density_below);
Instructions.c:2047:    fprintf(fp, "z_lith=%g\n", E->viscosity.zlith);
Instructions.c:2048:    fprintf(fp, "z_410=%g\n", E->viscosity.z410);
Instructions.c:2049:    fprintf(fp, "z_lmantle=%g\n", E->viscosity.zlm);
Instructions.c:2050:    fprintf(fp, "z_cmb=%g\n", E->viscosity.zcmb);
Instructions.c:2054:    fprintf(fp, "restart=%d\n", E->control.restart);
Instructions.c:2055:    fprintf(fp, "post_p=%d\n", E->control.post_p);
Instructions.c:2056:    fprintf(fp, "solution_cycles_init=%d\n", E->monitor.solution_cycles_init);
Instructions.c:2057:    fprintf(fp, "zero_elapsed_time=%d\n", E->control.zero_elapsed_time);
Instructions.c:2058:    fprintf(fp, "tic_method=%d\n", E->convection.tic_method);
Instructions.c:2059:    fprintf(fp, "num_perturbations=%d\n", E->convection.number_of_perturbations);
Instructions.c:2060:    if(E->convection.number_of_perturbations > 1)
Instructions.c:2063:      for(i=0; i<E->convection.number_of_perturbations-1; i++)
Instructions.c:2064:	fprintf(fp, "%d,", E->convection.perturb_ll[i]);
Instructions.c:2065:      fprintf(fp, "%d\n", E->convection.perturb_ll[E->convection.number_of_perturbations-1]);
Instructions.c:2067:      for(i=0; i<E->convection.number_of_perturbations-1; i++)
Instructions.c:2068:	fprintf(fp, "%d,", E->convection.perturb_mm[i]);
Instructions.c:2069:      fprintf(fp, "%d\n", E->convection.perturb_mm[E->convection.number_of_perturbations-1]);
Instructions.c:2071:      for(i=0; i<E->convection.number_of_perturbations-1; i++)
Instructions.c:2072:	fprintf(fp, "%d,", E->convection.load_depth[i]);
Instructions.c:2073:      fprintf(fp, "%d\n", E->convection.load_depth[E->convection.number_of_perturbations-1]);
Instructions.c:2075:      for(i=0; i<E->convection.number_of_perturbations-1; i++)
Instructions.c:2076:	fprintf(fp, "%g,", E->convection.perturb_mag[i]);
Instructions.c:2077:      fprintf(fp, "%g\n", E->convection.perturb_mag[E->convection.number_of_perturbations-1]);
Instructions.c:2081:      fprintf(fp, "perturbl=%d\n", E->convection.perturb_ll[0]);
Instructions.c:2082:      fprintf(fp, "perturbm=%d\n", E->convection.perturb_mm[0]);
Instructions.c:2083:      fprintf(fp, "perturblayer=%d\n", E->convection.load_depth[0]);
Instructions.c:2084:      fprintf(fp, "perturbmag=%g\n", E->convection.perturb_mag[0]);
Instructions.c:2086:    fprintf(fp, "half_space_age=%g\n", E->convection.half_space_age);
Instructions.c:2087:    fprintf(fp, "mantle_temp=%g\n", E->control.mantle_temp);
Instructions.c:2089:	    E->convection.blob_center[0],
Instructions.c:2090:	    E->convection.blob_center[1],
Instructions.c:2091:	    E->convection.blob_center[2]);
Instructions.c:2092:    fprintf(fp, "blob_radius=%g\n", E->convection.blob_radius);
Instructions.c:2093:    fprintf(fp, "blob_dT=%g\n", E->convection.blob_dT);
Instructions.c:2094:    fprintf(fp, "blob_bc_persist=%d\n", E->convection.blob_bc_persist);
Instructions.c:2098:    fprintf(fp, "output_format=%s\n", E->output.format);
Instructions.c:2099:    fprintf(fp, "output_optional=%s\n", E->output.optional);
Instructions.c:2100:    fprintf(fp, "output_ll_max=%d\n", E->output.llmax);
Instructions.c:2101:    fprintf(fp, "self_gravitation=%d\n", E->control.self_gravitation);
Instructions.c:2102:    fprintf(fp, "use_cbf_topo=%d\n", E->control.use_cbf_topo);
Instructions.c:2103:    fprintf(fp, "cb_block_size=%d\n", E->output.cb_block_size);
Instructions.c:2104:    fprintf(fp, "cb_buffer_size=%d\n", E->output.cb_buffer_size);
Instructions.c:2105:    fprintf(fp, "sieve_buf_size=%d\n", E->output.sieve_buf_size);
Instructions.c:2106:    fprintf(fp, "output_alignment=%d\n", E->output.alignment);
Instructions.c:2107:    fprintf(fp, "output_alignment_threshold=%d\n", E->output.alignment_threshold);
Instructions.c:2108:    fprintf(fp, "cache_mdc_nelmts=%d\n", E->output.cache_mdc_nelmts);
Instructions.c:2109:    fprintf(fp, "cache_rdcc_nelmts=%d\n", E->output.cache_rdcc_nelmts);
Instructions.c:2110:    fprintf(fp, "cache_rdcc_nbytes=%d\n", E->output.cache_rdcc_nbytes);
Instructions.c:2111:    fprintf(fp, "write_q_files=%d\n", E->output.write_q_files);
Instructions.c:2112:    fprintf(fp, "vtk_format=%s\n", E->output.vtk_format);
Instructions.c:2113:    fprintf(fp, "gzdir_vtkio=%d\n", E->output.gzdir.vtk_io);
Instructions.c:2114:    fprintf(fp, "gzdir_rnr=%d\n", E->output.gzdir.rnr);
Instructions.c:2118:    fprintf(fp, "reference_state=%d\n", E->refstate.choice);
Instructions.c:2119:    fprintf(fp, "refstate_file=%s\n", E->refstate.filename);
Instructions.c:2120:    fprintf(fp, "mineral_physics_model=%d\n", E->control.mineral_physics_model);
Instructions.c:2121:    fprintf(fp, "file_vbcs=%d\n", E->control.vbcs_file);
Instructions.c:2122:    fprintf(fp, "vel_bound_file=%s\n", E->control.velocity_boundary_file);
Instructions.c:2123:    fprintf(fp, "mat_control=%d\n", E->control.mat_control);
Instructions.c:2124:    fprintf(fp, "mat_file=%s\n", E->control.mat_file);
Instructions.c:2125:    fprintf(fp, "lith_age=%d\n", E->control.lith_age);
Instructions.c:2126:    fprintf(fp, "lith_age_file=%s\n", E->control.lith_age_file);
Instructions.c:2127:    fprintf(fp, "lith_age_time=%d\n", E->control.lith_age_time);
Instructions.c:2128:    fprintf(fp, "lith_age_depth=%g\n", E->control.lith_age_depth);
Instructions.c:2129:    fprintf(fp, "start_age=%g\n", E->control.start_age);
Instructions.c:2130:    fprintf(fp, "reset_startage=%d\n", E->control.reset_startage);
Instructions.c:2131:    fprintf(fp, "file_tbcs=%d\n", E->control.tbcs_file);
Instructions.c:2132:    fprintf(fp, "temp_bound_file=%s\n", E->control.temperature_boundary_file);
Instructions.c:2136:    fprintf(fp, "Ra_410=%g\n", E->control.Ra_410);
Instructions.c:2137:    fprintf(fp, "clapeyron410=%g\n", E->control.clapeyron410);
Instructions.c:2138:    fprintf(fp, "transT410=%g\n", E->control.transT410);
Instructions.c:2140:    if(E->control.inv_width410 != 0.0)
Instructions.c:2141:        tmp = 1.0/E->control.inv_width410;
Instructions.c:2143:    fprintf(fp, "Ra_670=%g\n", E->control.Ra_670);
Instructions.c:2144:    fprintf(fp, "clapeyron670=%g\n", E->control.clapeyron670);
Instructions.c:2145:    fprintf(fp, "transT670=%g\n", E->control.transT670);
Instructions.c:2147:    if(E->control.inv_width670 != 0.0)
Instructions.c:2148:        tmp = 1.0/E->control.inv_width670;
Instructions.c:2150:    fprintf(fp, "Ra_cmb=%g\n", E->control.Ra_cmb);
Instructions.c:2151:    fprintf(fp, "clapeyroncmb=%g\n", E->control.clapeyroncmb);
Instructions.c:2152:    fprintf(fp, "transTcmb=%g\n", E->control.transTcmb);
Instructions.c:2154:    if(E->control.inv_widthcmb != 0.0)
Instructions.c:2155:        tmp = 1.0/E->control.inv_widthcmb;
Instructions.c:2160:    fprintf(fp, "tracer=%d\n", E->control.tracer);
Instructions.c:2161:    fprintf(fp, "tracer_ic_method=%d\n", E->trace.ic_method);
Instructions.c:2162:    fprintf(fp, "tracers_per_element=%d\n", E->trace.itperel);
Instructions.c:2163:    fprintf(fp, "tracer_file=%s\n", E->trace.tracer_file);
Instructions.c:2164:    fprintf(fp, "tracer_flavors=%d\n", E->trace.nflavors);
Instructions.c:2165:    fprintf(fp, "ic_method_for_flavors=%d\n", E->trace.ic_method_for_flavors);
Instructions.c:2167:    if(E->trace.nflavors > 0)
Instructions.c:2169:      for(i=0; i<E->trace.nflavors-1;i++)
Instructions.c:2170:        fprintf(fp, "%g,", E->trace.z_interface[i]);
Instructions.c:2171:      fprintf(fp, "%g\n", E->trace.z_interface[E->trace.nflavors-1]);
Instructions.c:2177:    fprintf(fp, "itracer_warnings=%d\n", E->trace.itracer_warnings);
Instructions.c:2178:    fprintf(fp, "regular_grid_deltheta=%g\n", E->trace.deltheta[0]);
Instructions.c:2179:    fprintf(fp, "regular_grid_delphi=%g\n", E->trace.delphi[0]);
Instructions.c:2180:    fprintf(fp, "chemical_buoyancy=%d\n", E->composition.ichemical_buoyancy);
Instructions.c:2181:    fprintf(fp, "buoy_type=%d\n", E->composition.ibuoy_type);
Instructions.c:2183:    if(E->composition.ncomp > 0)
Instructions.c:2185:      for(i=0; i<E->composition.ncomp-1;i++)
Instructions.c:2186:        fprintf(fp, "%g,", E->composition.buoyancy_ratio[i]);
Instructions.c:2187:      fprintf(fp, "%g\n", E->composition.buoyancy_ratio[E->composition.ncomp-1]);
Instructions.c:2193:    fprintf(fp, "tracer_enriched=%d\n", E->control.tracer_enriched);
Instructions.c:2194:    fprintf(fp, "Q0_enriched=%g\n", E->control.Q0ER);
Instructions.c:2198:    fprintf(fp, "Viscosity=%s\n", E->viscosity.STRUCTURE);
Instructions.c:2199:    fprintf(fp, "visc_smooth_method=%d\n", E->viscosity.smooth_cycles);
Instructions.c:2200:    fprintf(fp, "VISC_UPDATE=%d\n", E->viscosity.update_allowed);
Instructions.c:2201:    fprintf(fp, "num_mat=%d\n", E->viscosity.num_mat);
Instructions.c:2203:    if(E->viscosity.num_mat > 0)
Instructions.c:2205:      for(i=0; i<E->viscosity.num_mat-1;i++)
Instructions.c:2206:        fprintf(fp, "%g,", E->viscosity.N0[i]);
Instructions.c:2207:      fprintf(fp, "%g\n", E->viscosity.N0[E->viscosity.num_mat-1]);
Instructions.c:2213:    fprintf(fp, "TDEPV=%d\n", E->viscosity.TDEPV);
Instructions.c:2214:    fprintf(fp, "rheol=%d\n", E->viscosity.RHEOL);
Instructions.c:2216:    if(E->viscosity.num_mat > 0)
Instructions.c:2218:      for(i=0; i<E->viscosity.num_mat-1;i++)
Instructions.c:2219:        fprintf(fp, "%g,", E->viscosity.E[i]);
Instructions.c:2220:      fprintf(fp, "%g\n", E->viscosity.E[E->viscosity.num_mat-1]);
Instructions.c:2227:    if(E->viscosity.num_mat > 0)
Instructions.c:2229:      for(i=0; i<E->viscosity.num_mat-1;i++)
Instructions.c:2230:        fprintf(fp, "%g,", E->viscosity.T[i]);
Instructions.c:2231:      fprintf(fp, "%g\n", E->viscosity.T[E->viscosity.num_mat-1]);
Instructions.c:2238:    if(E->viscosity.num_mat > 0)
Instructions.c:2240:      for(i=0; i<E->viscosity.num_mat-1;i++)
Instructions.c:2241:        fprintf(fp, "%g,", E->viscosity.Z[i]);
Instructions.c:2242:      fprintf(fp, "%g\n", E->viscosity.Z[E->viscosity.num_mat-1]);
Instructions.c:2248:    fprintf(fp, "SDEPV=%d\n", E->viscosity.SDEPV);
Instructions.c:2250:    if(E->viscosity.num_mat > 0)
Instructions.c:2252:      for(i=0; i<E->viscosity.num_mat-1;i++)
Instructions.c:2253:        fprintf(fp, "%g,", (E->viscosity.SDEPV == 0 ? 
Instructions.c:2254:			    1.0 : E->viscosity.sdepv_expt[i]));
Instructions.c:2255:      fprintf(fp, "%g\n", (E->viscosity.SDEPV == 0 ?
Instructions.c:2256:			   1.0 : E->viscosity.sdepv_expt[E->viscosity.num_mat-1]));
Instructions.c:2262:    fprintf(fp, "sdepv_misfit=%g\n", E->viscosity.sdepv_misfit);
Instructions.c:2263:    fprintf(fp, "PDEPV=%d\n", E->viscosity.PDEPV);
Instructions.c:2265:    if(E->viscosity.num_mat > 0)
Instructions.c:2267:      for(i=0; i<E->viscosity.num_mat-1;i++)
Instructions.c:2268:        fprintf(fp, "%g,", (E->viscosity.PDEPV == 0 ?
Instructions.c:2269:			    1e20 : E->viscosity.pdepv_a[i]));
Instructions.c:2270:      fprintf(fp, "%g\n", (E->viscosity.PDEPV == 0 ?
Instructions.c:2271:			   1e20 : E->viscosity.pdepv_a[E->viscosity.num_mat-1]));
Instructions.c:2278:    if(E->viscosity.num_mat > 0)
Instructions.c:2280:      for(i=0; i<E->viscosity.num_mat-1;i++)
Instructions.c:2281:        fprintf(fp, "%g,", (E->viscosity.PDEPV == 0 ?
Instructions.c:2282:			    0.0 : E->viscosity.pdepv_b[i]));
Instructions.c:2283:      fprintf(fp, "%g\n", (E->viscosity.PDEPV == 0 ?
Instructions.c:2284:			   0.0 : E->viscosity.pdepv_b[E->viscosity.num_mat-1]));
Instructions.c:2291:    if(E->viscosity.num_mat > 0)
Instructions.c:2293:      for(i=0; i<E->viscosity.num_mat-1;i++)
Instructions.c:2294:        fprintf(fp, "%g,", (E->viscosity.PDEPV == 0 ?
Instructions.c:2295:			    1e20 : E->viscosity.pdepv_y[i]));
Instructions.c:2296:      fprintf(fp, "%g\n", (E->viscosity.PDEPV == 0 ?
Instructions.c:2297:			   1e20 : E->viscosity.pdepv_y[E->viscosity.num_mat-1]));
Instructions.c:2303:    fprintf(fp, "pdepv_eff=%d\n", E->viscosity.pdepv_eff);
Instructions.c:2304:    fprintf(fp, "pdepv_offset=%g\n", E->viscosity.pdepv_offset);
Instructions.c:2305:    fprintf(fp, "CDEPV=%d\n", E->viscosity.CDEPV);
Instructions.c:2307:    if(E->trace.nflavors > 0)
Instructions.c:2309:      for(i=0; i<E->trace.nflavors-1;i++)
Instructions.c:2310:        fprintf(fp, "%g,", E->viscosity.cdepv_ff[i]);
Instructions.c:2311:      fprintf(fp, "%g\n", E->viscosity.cdepv_ff[E->trace.nflavors-1]);
Instructions.c:2317:    fprintf(fp, "low_visc_channel=%d\n", E->viscosity.channel);
Instructions.c:2318:    fprintf(fp, "low_visc_wedge=%d\n", E->viscosity.wedge);
Instructions.c:2319:    fprintf(fp, "lv_min_radius=%g\n", E->viscosity.lv_min_radius);
Instructions.c:2320:    fprintf(fp, "lv_max_radius=%g\n", E->viscosity.lv_max_radius);
Instructions.c:2321:    fprintf(fp, "lv_channel_thickness=%g\n", E->viscosity.lv_channel_thickness);
Instructions.c:2322:    fprintf(fp, "lv_reduction=%g\n", E->viscosity.lv_reduction);
Instructions.c:2323:    fprintf(fp, "VMIN=%d\n", E->viscosity.MIN);
Instructions.c:2324:    fprintf(fp, "visc_min=%g\n", E->viscosity.min_value);
Instructions.c:2325:    fprintf(fp, "VMAX=%d\n", E->viscosity.MAX);
Instructions.c:2326:    fprintf(fp, "visc_max=%g\n", E->viscosity.max_value);
Instructions.c:2328:    if(E->viscosity.num_mat > 0)
Instructions.c:2330:      for(i=0; i<E->viscosity.num_mat-1;i++)
Instructions.c:2331:        fprintf(fp, "%g,", E->viscosity.zbase_layer[i]);
Instructions.c:2332:      fprintf(fp, "%g\n", E->viscosity.zbase_layer[E->viscosity.num_mat-1]);
Instructions.c:2338:    fprintf(fp, "visc_layer_control=%d\n", E->viscosity.layer_control);
Instructions.c:2339:    fprintf(fp, "visc_layer_file=%s\n", E->viscosity.layer_file);
Lith_age.c:44:  int m = E->parallel.me;
Lith_age.c:46:  E->control.lith_age = 0;
Lith_age.c:47:  E->control.lith_age_time = 0;
Lith_age.c:48:  E->control.temperature_bound_adj = 0;
Lith_age.c:50:  input_int("lith_age",&(E->control.lith_age),"0",m);
Lith_age.c:52:  input_int("ggrd_age_control",&(E->control.ggrd.age_control),"0",m); /* if > 0, will use top  E->control.ggrd.mat_control layers and assign a prefactor for the viscosity */
Lith_age.c:53:  if(E->control.ggrd.age_control){
Lith_age.c:54:    E->control.lith_age = 1;	
Lith_age.c:58:  if (E->control.lith_age) {
Lith_age.c:59:    input_int("lith_age_time",&(E->control.lith_age_time),"0",m);
Lith_age.c:60:    input_string("lith_age_file",E->control.lith_age_file,"",m);
Lith_age.c:61:    input_float("lith_age_depth",&(E->control.lith_age_depth),"0.0471",m);
Lith_age.c:63:    input_int("temperature_bound_adj",&(E->control.temperature_bound_adj),"0",m);
Lith_age.c:64:    if (E->control.temperature_bound_adj) {
Lith_age.c:65:      input_float("depth_bound_adj",&(E->control.depth_bound_adj),"0.1570",m);
Lith_age.c:66:      input_float("width_bound_adj",&(E->control.width_bound_adj),"0.08727",m);
Lith_age.c:80:  gnox=E->mesh.nox;
Lith_age.c:81:  gnoy=E->mesh.noy;
Lith_age.c:83:  if (E->parallel.me == 0 ) fprintf(stderr,"INSIDE lith_age_init\n");
Lith_age.c:84:  E->age_t=(float*) malloc((gnox*gnoy+1)*sizeof(float));
Lith_age.c:86:  if(E->control.lith_age_time==1)   {
Lith_age.c:88:    E->control.lith_age_old_cycles = E->monitor.solution_cycles;
Lith_age.c:90:    (E->solver.lith_age_read_files)(E,output);
Lith_age.c:95:    sprintf(output_file,"%s",E->control.lith_age_file);
Lith_age.c:98:      fprintf(E->fp,"(Boundary_conditions #1) Can't open %s\n",output_file);
Lith_age.c:104:	if(fscanf(fp1,"%f",&(E->age_t[node])) != 1) {
Lith_age.c:108:	E->age_t[node]=E->age_t[node]*E->data.scalet;
Lith_age.c:111:  } /* end E->control.lith_age_time == false */
Lith_age.c:123:  noy=E->lmesh.noy;
Lith_age.c:124:  nox=E->lmesh.nox;
Lith_age.c:125:  noz=E->lmesh.noz;
Lith_age.c:127:  gnox=E->mesh.nox;
Lith_age.c:128:  gnoy=E->mesh.noy;
Lith_age.c:129:  gnoz=E->mesh.noz;
Lith_age.c:131:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Lith_age.c:135:	  nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Lith_age.c:137:	  r1=E->sx[m][3][node];
Lith_age.c:138:	  E->T[m][node] = E->control.mantle_temp;
Lith_age.c:139:	  if( r1 >= E->sphere.ro-E->control.lith_age_depth )
Lith_age.c:141:	      temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:142:	      E->T[m][node] = E->control.mantle_temp * erf(temp);
Lith_age.c:162:  noy = E->lmesh.noy;
Lith_age.c:163:  nox = E->lmesh.nox;
Lith_age.c:164:  noz = E->lmesh.noz;
Lith_age.c:165:  rout = E->sphere.ro;
Lith_age.c:166:  rin = E->sphere.ri;
Lith_age.c:168:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Lith_age.c:173:	  r1=E->sx[m][3][node];
Lith_age.c:176:	    E->sphere.cap[m].TB[1][node]=E->T[m][node];
Lith_age.c:177:	    E->sphere.cap[m].TB[2][node]=E->T[m][node];
Lith_age.c:178:	    E->sphere.cap[m].TB[3][node]=E->T[m][node];
Lith_age.c:191:  nno=E->lmesh.nno;
Lith_age.c:198:  if (E->control.temperature_bound_adj) {
Lith_age.c:199:    ttt2=E->control.theta_min + E->control.width_bound_adj;
Lith_age.c:200:    ttt3=E->control.theta_max - E->control.width_bound_adj;
Lith_age.c:201:    fff2=E->control.fi_min + E->control.width_bound_adj;
Lith_age.c:202:    fff3=E->control.fi_max - E->control.width_bound_adj;
Lith_age.c:204:    if(lv==E->mesh.gridmax)
Lith_age.c:205:      for(j=1;j<=E->sphere.caps_per_proc;j++)
Lith_age.c:206:	for(node=1;node<=E->lmesh.nno;node++)  {
Lith_age.c:207:	  if( ((E->sx[j][1][node]<=ttt2) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) || ((E->sx[j][1][node]>=ttt3) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Lith_age.c:210:	      E->node[j][node]=E->node[j][node] | TBX;
Lith_age.c:211:	      E->node[j][node]=E->node[j][node] & (~FBX);
Lith_age.c:212:	      E->node[j][node]=E->node[j][node] | TBY;
Lith_age.c:213:	      E->node[j][node]=E->node[j][node] & (~FBY);
Lith_age.c:214:	      E->node[j][node]=E->node[j][node] | TBZ;
Lith_age.c:215:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Lith_age.c:218:	  if( ((E->sx[j][2][node]<=fff2) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Lith_age.c:221:	      E->node[j][node]=E->node[j][node] | TBX;
Lith_age.c:222:	      E->node[j][node]=E->node[j][node] & (~FBX);
Lith_age.c:223:	      E->node[j][node]=E->node[j][node] | TBY;
Lith_age.c:224:	      E->node[j][node]=E->node[j][node] & (~FBY);
Lith_age.c:225:	      E->node[j][node]=E->node[j][node] | TBZ;
Lith_age.c:226:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Lith_age.c:229:	  if( ((E->sx[j][2][node]>=fff3) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Lith_age.c:232:	      E->node[j][node]=E->node[j][node] | TBX;
Lith_age.c:233:	      E->node[j][node]=E->node[j][node] & (~FBX);
Lith_age.c:234:	      E->node[j][node]=E->node[j][node] | TBY;
Lith_age.c:235:	      E->node[j][node]=E->node[j][node] & (~FBY);
Lith_age.c:236:	      E->node[j][node]=E->node[j][node] | TBZ;
Lith_age.c:237:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Lith_age.c:241:  } /* end E->control.temperature_bound_adj */
Lith_age.c:243:  if (E->control.lith_age_time) {
Lith_age.c:244:    if(lv==E->mesh.gridmax)
Lith_age.c:245:      for(j=1;j<=E->sphere.caps_per_proc;j++)
Lith_age.c:246:	for(node=1;node<=E->lmesh.nno;node++)  {
Lith_age.c:247:	  if(E->sx[j][3][node]>=E->sphere.ro-E->control.lith_age_depth)
Lith_age.c:249:	      E->node[j][node]=E->node[j][node] | TBX;
Lith_age.c:250:	      E->node[j][node]=E->node[j][node] & (~FBX);
Lith_age.c:251:	      E->node[j][node]=E->node[j][node] | TBY;
Lith_age.c:252:	      E->node[j][node]=E->node[j][node] & (~FBY);
Lith_age.c:253:	      E->node[j][node]=E->node[j][node] | TBZ;
Lith_age.c:254:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Lith_age.c:258:  } /* end E->control.lith_age_time */
Lith_age.c:279:  gnox=E->mesh.nox;
Lith_age.c:280:  gnoy=E->mesh.noy;
Lith_age.c:281:  gnoz=E->mesh.noz;
Lith_age.c:282:  nox=E->lmesh.nox;
Lith_age.c:283:  noy=E->lmesh.noy;
Lith_age.c:284:  noz=E->lmesh.noz;
Lith_age.c:286:  if(E->control.lith_age_time==1)   {
Lith_age.c:288:    if (E->control.lith_age_old_cycles != E->monitor.solution_cycles) {
Lith_age.c:291:      E->control.lith_age_old_cycles = E->monitor.solution_cycles;
Lith_age.c:293:    if (E->parallel.me == 0) fprintf(stderr,"INSIDE lith_age_conform_tbc\n");
Lith_age.c:294:    (E->solver.lith_age_read_files)(E,output);
Lith_age.c:298:  if(E->monitor.solution_cycles>1 && E->control.temperature_bound_adj) {
Lith_age.c:299:    ttt2=E->control.theta_min + E->control.width_bound_adj;
Lith_age.c:300:    ttt3=E->control.theta_max - E->control.width_bound_adj;
Lith_age.c:301:    fff2=E->control.fi_min + E->control.width_bound_adj;
Lith_age.c:302:    fff3=E->control.fi_max - E->control.width_bound_adj;
Lith_age.c:304:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Lith_age.c:308:	    nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Lith_age.c:310:	    t1=E->sx[m][1][node];
Lith_age.c:311:	    f1=E->sx[m][2][node];
Lith_age.c:312:	    r1=E->sx[m][3][node];
Lith_age.c:314:	    if(fabs(r1-E->sphere.ro)>=e_4 && fabs(r1-E->sphere.ri)>=e_4)  { /* if NOT right on the boundary */
Lith_age.c:315:	      if( ((E->sx[m][1][node]<=ttt2) && (E->sx[m][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) || ((E->sx[m][1][node]>=ttt3) && (E->sx[m][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) ) {
Lith_age.c:317:		temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:318:		t0 = E->control.mantle_temp * erf(temp);
Lith_age.c:321:		E->sphere.cap[m].TB[1][node]=t0;
Lith_age.c:322:		E->sphere.cap[m].TB[2][node]=t0;
Lith_age.c:323:		E->sphere.cap[m].TB[3][node]=t0;
Lith_age.c:326:	      if( ((E->sx[m][2][node]<=fff2) || (E->sx[m][2][node]>=fff3)) && (E->sx[m][3][node]>=E->sphere.ro-E->control.depth_bound_adj) ) {
Lith_age.c:331:		temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:332:		t0 = E->control.mantle_temp * erf(temp);
Lith_age.c:334:		E->sphere.cap[m].TB[1][node]=t0;
Lith_age.c:335:		E->sphere.cap[m].TB[2][node]=t0;
Lith_age.c:336:		E->sphere.cap[m].TB[3][node]=t0;
Lith_age.c:348:  if(E->monitor.solution_cycles>0 && E->control.lith_age_time)   {
Lith_age.c:349:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Lith_age.c:353:	    nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Lith_age.c:355:	    t1=E->sx[m][1][node];
Lith_age.c:356:	    f1=E->sx[m][2][node];
Lith_age.c:357:	    r1=E->sx[m][3][node];
Lith_age.c:359:	    if(fabs(r1-E->sphere.ro)>=e_4 && fabs(r1-E->sphere.ri)>=e_4)  { /* if NOT right on the boundary */
Lith_age.c:360:	      if(  E->sx[m][3][node]>=E->sphere.ro-E->control.lith_age_depth ) {
Lith_age.c:363:                depth=E->sphere.ro - E->sx[m][3][node];
Lith_age.c:366:		temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:367:		t0 = E->control.mantle_temp * erf(temp);
Lith_age.c:369:		E->sphere.cap[m].TB[1][node]=t0;
Lith_age.c:370:		E->sphere.cap[m].TB[2][node]=t0;
Lith_age.c:371:		E->sphere.cap[m].TB[3][node]=t0;
Lith_age.c:387:  nno=E->lmesh.nno;
Lith_age.c:388:  gnox=E->mesh.nox;
Lith_age.c:389:  gnoy=E->mesh.noy;
Lith_age.c:390:  gnoz=E->mesh.noz;
Lith_age.c:391:  nox=E->lmesh.nox;
Lith_age.c:392:  noy=E->lmesh.noy;
Lith_age.c:393:  noz=E->lmesh.noz;
Lith_age.c:395:  for(j=1;j<=E->sphere.caps_per_proc;j++)
Lith_age.c:396:    for(node=1;node<=E->lmesh.nno;node++)  {
Lith_age.c:398:        type = (E->node[j][node] & (TBX | TBZ | TBY));
Lith_age.c:404:            assimilate_new_temp = E->sphere.cap[j].TB[1][node];
Lith_age.c:407:            assimilate_new_temp = E->sphere.cap[j].TB[3][node];
Lith_age.c:410:            assimilate_new_temp = E->sphere.cap[j].TB[2][node];
Lith_age.c:413:            assimilate_new_temp = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[3][node]);
Lith_age.c:416:            assimilate_new_temp = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node]);
Lith_age.c:419:            assimilate_new_temp = 0.5 * (E->sphere.cap[j].TB[3][node] + E->sphere.cap[j].TB[2][node]);
Lith_age.c:422:            assimilate_new_temp = 0.3333333 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node] + E->sphere.cap[j].TB[3][node]);
Lith_age.c:426:        depth = E->sphere.ro - E->sx[j][3][node];
Lith_age.c:432:            if(depth <= E->control.lith_age_depth) {
Lith_age.c:434:                daf = 0.5*depth/E->control.lith_age_depth;
Lith_age.c:435:                E->T[j][node] = daf*E->T[j][node] + (1.0-daf)*assimilate_new_temp;
Lith_age.c:438:                E->T[j][node] = assimilate_new_temp;
Material_properties.c:48:    int noz = E->lmesh.noz;
Material_properties.c:49:    int nno = E->lmesh.nno;
Material_properties.c:50:    int nel = E->lmesh.nel;
Material_properties.c:53:    E->refstate.rho = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:56:    E->refstate.gravity = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:59:    E->refstate.thermal_expansivity = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:62:    E->refstate.heat_capacity = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:65:    /*E->refstate.thermal_conductivity = (double *) malloc((noz+1)*sizeof(double));*/
Material_properties.c:68:    /*E->refstate.Tadi = (double *) malloc((noz+1)*sizeof(double));*/
Material_properties.c:81:    switch(E->refstate.choice) {
Material_properties.c:95:        if (E->parallel.me) {
Material_properties.c:97:            fprintf(E->fp, "Unknown option for reference state\n");
Material_properties.c:98:            fflush(E->fp);
Material_properties.c:103:    if(E->parallel.me == 0) {
Material_properties.c:106:    if(E->parallel.me < E->parallel.nprocz)
Material_properties.c:107:        for(i=1; i<=E->lmesh.noz; i++) {
Material_properties.c:109:                    i+E->lmesh.nzs-1, E->sx[1][3][i], 1-E->sx[1][3][i],
Material_properties.c:110:                    E->refstate.rho[i],layers_r(E,E->sx[1][3][i]));
Material_properties.c:124:    fp = fopen(E->refstate.filename, "r");
Material_properties.c:127:                E->refstate.filename);
Material_properties.c:132:    for(i=1; i<E->lmesh.nzs; i++) {
Material_properties.c:136:    for(i=1; i<=E->lmesh.noz; i++) {
Material_properties.c:139:                  &(E->refstate.rho[i]),
Material_properties.c:140:                  &(E->refstate.gravity[i]),
Material_properties.c:141:                  &(E->refstate.thermal_expansivity[i]),
Material_properties.c:142:                  &(E->refstate.heat_capacity[i]),
Material_properties.c:146:            fprintf(stderr,"Error while reading file '%s'\n", E->refstate.filename);
Material_properties.c:152:                E->refstate.rho[i],
Material_properties.c:153:                E->refstate.gravity[i],
Material_properties.c:154:                E->refstate.thermal_expansivity[i],
Material_properties.c:155:                E->refstate.heat_capacity[i]);
Material_properties.c:169:    beta = E->control.disptn_number * E->control.inv_gruneisen;
Material_properties.c:171:    for(i=1; i<=E->lmesh.noz; i++) {
Material_properties.c:172:	r = E->sx[1][3][i];
Material_properties.c:174:	E->refstate.rho[i] = exp(beta*z);
Material_properties.c:175:	E->refstate.gravity[i] = 1;
Material_properties.c:176:	E->refstate.thermal_expansivity[i] = 1;
Material_properties.c:177:	E->refstate.heat_capacity[i] = 1;
Material_properties.c:178:	/*E->refstate.thermal_conductivity[i] = 1;*/
Material_properties.c:179:	/*E->refstate.Tadi[i] = (E->control.adiabaticT0 + E->control.surface_temp) * exp(E->control.disptn_number * z) - E->control.surface_temp;*/
Material_properties.c:209:    const double beta = E->control.disptn_number * E->control.inv_gruneisen;
Material_properties.c:212:    const int gnoz = E->mesh.noz;
Material_properties.c:232:    r = E->sphere.gr;
Material_properties.c:251:    if(E->parallel.me == 0) {
Material_properties.c:259:    for(i=1, j=E->lmesh.nzs; i<=E->lmesh.noz; i++, j++) {
Material_properties.c:261:	E->refstate.rho[i] = rho[j];
Material_properties.c:262:	E->refstate.gravity[i] = 1;
Material_properties.c:263:	E->refstate.heat_capacity[i] = 1;
Material_properties.c:266:	E->refstate.thermal_expansivity[i] = rho[j] / ks;
Material_properties.c:268:	/*E->refstate.thermal_conductivity[i] = 1;*/
Material_properties.c:269:	/*E->refstate.Tadi[i] = (E->control.adiabaticT0 + E->control.surface_temp) * exp(E->control.disptn_number * z) - E->control.surface_temp;*/
Mineral_physics_models.c:174:    if(!E->output.horiz_avg)
Mineral_physics_models.c:179:    rhor = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:180:    vpr = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:181:    vsr = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:182:    depthkm = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:184:    for(nz=1; nz<=E->lmesh.noz; nz++) {
Mineral_physics_models.c:185:        get_prem(E->sx[m][3][nz], &vpr[nz], &vsr[nz], &rhor[nz]);
Mineral_physics_models.c:186:        depthkm[nz] = (1.0 - E->sx[m][3][nz]) * E->data.radius_km;
Mineral_physics_models.c:191:    for(i=0; i<E->lmesh.nno; i++) {
Mineral_physics_models.c:192:        nz = (i % E->lmesh.noz) + 1;
Mineral_physics_models.c:196:        dT = (E->T[m][i+1] - E->Have.T[nz]) * E->data.ref_temperature;
Mineral_physics_models.c:198:        drho = -dT * E->refstate.thermal_expansivity[nz] * E->data.therm_exp;
Mineral_physics_models.c:203:        if(E->control.tracer && E->composition.on && E->composition.ichemical_buoyancy)
Mineral_physics_models.c:204:            for(j=0; j<E->composition.ncomp; j++) {
Mineral_physics_models.c:205:                dC = E->composition.comp_node[m][j][i+1] - E->Have.C[j][nz];
Mineral_physics_models.c:207:                drho += dC * E->composition.buoyancy_ratio[j]
Mineral_physics_models.c:208:                    * E->data.ref_temperature * E->data.therm_exp / E->refstate.rho[nz];
Mineral_physics_models.c:239:    switch(E->control.mineral_physics_model) {
Mineral_physics_models.c:244:                E->control.mineral_physics_model);
Mineral_physics_models.c:252:                E->control.mineral_physics_model);
Mineral_physics_models.c:260:                E->control.mineral_physics_model);
Mineral_physics_models.c:283:                E->control.mineral_physics_model);
Mineral_physics_models.c:290:                E->control.mineral_physics_model);
Nodal_mesh.c:43:    const int nno = E->lmesh.nno;
Nodal_mesh.c:45:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Nodal_mesh.c:47:            E->sphere.cap[m].V[1][node] = E->U[m][E->id[m][node].doff[1]];
Nodal_mesh.c:48:            E->sphere.cap[m].V[2][node] = E->U[m][E->id[m][node].doff[2]];
Nodal_mesh.c:49:            E->sphere.cap[m].V[3][node] = E->U[m][E->id[m][node].doff[3]];
Nodal_mesh.c:50:            if (E->node[m][node] & VBX)
Nodal_mesh.c:51:                E->sphere.cap[m].V[1][node] = E->sphere.cap[m].VB[1][node];
Nodal_mesh.c:52:            if (E->node[m][node] & VBY)
Nodal_mesh.c:53:                E->sphere.cap[m].V[2][node] = E->sphere.cap[m].VB[2][node];
Nodal_mesh.c:54:            if (E->node[m][node] & VBZ)
Nodal_mesh.c:55:                E->sphere.cap[m].V[3][node] = E->sphere.cap[m].VB[3][node];
Nodal_mesh.c:66:    const int nno = E->lmesh.nno;
Nodal_mesh.c:68:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Nodal_mesh.c:70:	E->U[m][E->id[m][node].doff[1]] =  E->sphere.cap[m].V[1][node];
Nodal_mesh.c:71:	E->U[m][E->id[m][node].doff[2]] =  E->sphere.cap[m].V[2][node];
Nodal_mesh.c:72:	E->U[m][E->id[m][node].doff[3]] =  E->sphere.cap[m].V[3][node];
Nodal_mesh.c:83:    const int nno = E->lmesh.nno;
Nodal_mesh.c:87:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Nodal_mesh.c:89:            E->sphere.cap[m].Vprev[1][node] = E->sphere.cap[m].V[1][node];
Nodal_mesh.c:90:            E->sphere.cap[m].Vprev[2][node] = E->sphere.cap[m].V[2][node];
Nodal_mesh.c:91:            E->sphere.cap[m].Vprev[3][node] = E->sphere.cap[m].V[3][node];
Nodal_mesh.c:93:            E->sphere.cap[m].V[1][node] = E->U[m][E->id[m][node].doff[1]];
Nodal_mesh.c:94:            E->sphere.cap[m].V[2][node] = E->U[m][E->id[m][node].doff[2]];
Nodal_mesh.c:95:            E->sphere.cap[m].V[3][node] = E->U[m][E->id[m][node].doff[3]];
Nodal_mesh.c:96:            if (E->node[m][node] & VBX)
Nodal_mesh.c:97:                E->sphere.cap[m].V[1][node] = E->sphere.cap[m].VB[1][node];
Nodal_mesh.c:98:            if (E->node[m][node] & VBY)
Nodal_mesh.c:99:                E->sphere.cap[m].V[2][node] = E->sphere.cap[m].VB[2][node];
Nodal_mesh.c:100:            if (E->node[m][node] & VBZ)
Nodal_mesh.c:101:                E->sphere.cap[m].V[3][node] = E->sphere.cap[m].VB[3][node];
Nodal_mesh.c:103:            sum_dV += (E->sphere.cap[m].V[1][node] - E->sphere.cap[m].Vprev[1][node])*(E->sphere.cap[m].V[1][node] - E->sphere.cap[m].Vprev[1][node])
Nodal_mesh.c:104:                + (E->sphere.cap[m].V[2][node] - E->sphere.cap[m].Vprev[2][node])*(E->sphere.cap[m].V[2][node] - E->sphere.cap[m].Vprev[2][node])
Nodal_mesh.c:105:                + (E->sphere.cap[m].V[3][node] - E->sphere.cap[m].Vprev[3][node])*(E->sphere.cap[m].V[3][node] - E->sphere.cap[m].Vprev[3][node]);
Nodal_mesh.c:106:            sum_V += E->sphere.cap[m].V[1][node]*E->sphere.cap[m].V[1][node]
Nodal_mesh.c:107:                + E->sphere.cap[m].V[2][node]*E->sphere.cap[m].V[2][node]
Nodal_mesh.c:108:                + E->sphere.cap[m].V[3][node]*E->sphere.cap[m].V[3][node];
Nodal_mesh.c:111:        MPI_Allreduce(&rel_error,&global_max_error,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Nodal_mesh.c:112:        if(global_max_error <= tol_error) E->monitor.stop_topo_loop = 1;
Nodal_mesh.c:113:        if(E->parallel.me==0)
Nodal_mesh.c:114:            fprintf(stderr,"global_max_error=%e stop_topo_loop=%d\n",global_max_error,E->monitor.stop_topo_loop);
Nodal_mesh.c:129:    const int ends=enodes[E->mesh.nsd];
Nodal_mesh.c:130:    const int lev=E->mesh.levmax;
Nodal_mesh.c:134:            node = E->ien[m][el].node[a];
Nodal_mesh.c:135:            VV[1][a] = E->sphere.cap[m].V[1][node];
Nodal_mesh.c:136:            VV[2][a] = E->sphere.cap[m].V[2][node];
Nodal_mesh.c:137:            VV[3][a] = E->sphere.cap[m].V[3][node];
Nodal_mesh.c:141:            node = E->ien[m][el].node[a];
Nodal_mesh.c:143:            sint = E->SinCos[lev][m][0][node]; 
Nodal_mesh.c:144:            sinf = E->SinCos[lev][m][1][node];
Nodal_mesh.c:145:            cost = E->SinCos[lev][m][2][node];
Nodal_mesh.c:146:            cosf = E->SinCos[lev][m][3][node];
Nodal_mesh.c:148:            VV[1][a] = E->sphere.cap[m].V[1][node]*cost*cosf
Nodal_mesh.c:149:                - E->sphere.cap[m].V[2][node]*sinf
Nodal_mesh.c:150:                + E->sphere.cap[m].V[3][node]*sint*cosf;
Nodal_mesh.c:151:            VV[2][a] = E->sphere.cap[m].V[1][node]*cost*sinf
Nodal_mesh.c:152:                + E->sphere.cap[m].V[2][node]*cosf
Nodal_mesh.c:153:                + E->sphere.cap[m].V[3][node]*sint*sinf;
Nodal_mesh.c:154:            VV[3][a] = -E->sphere.cap[m].V[1][node]*sint
Nodal_mesh.c:155:                + E->sphere.cap[m].V[3][node]*cost;
Nodal_mesh.c:170:    const int dims=E->mesh.nsd;
Nodal_mesh.c:171:    const int ends=enodes[E->mesh.nsd];
Nodal_mesh.c:172:    const int nno=E->lmesh.nno;
Nodal_mesh.c:173:    const int lev=E->mesh.levmax;
Nodal_mesh.c:177:            node = E->ien[m][el].node[a];
Nodal_mesh.c:178:            VV[1][a] = E->sphere.cap[m].V[1][node];
Nodal_mesh.c:179:            VV[2][a] = E->sphere.cap[m].V[2][node];
Nodal_mesh.c:180:            VV[3][a] = E->sphere.cap[m].V[3][node];
Nodal_mesh.c:184:            node = E->ien[m][el].node[a];
Nodal_mesh.c:186:            sint = E->SinCos[lev][m][0][node];
Nodal_mesh.c:187:            sinf = E->SinCos[lev][m][1][node];
Nodal_mesh.c:188:            cost = E->SinCos[lev][m][2][node];
Nodal_mesh.c:189:            cosf = E->SinCos[lev][m][3][node];
Nodal_mesh.c:191:            VV[1][a] = E->sphere.cap[m].V[1][node]*cost*cosf
Nodal_mesh.c:192:                - E->sphere.cap[m].V[2][node]*sinf
Nodal_mesh.c:193:                + E->sphere.cap[m].V[3][node]*sint*cosf;
Nodal_mesh.c:194:            VV[2][a] = E->sphere.cap[m].V[1][node]*cost*sinf
Nodal_mesh.c:195:                + E->sphere.cap[m].V[2][node]*cosf
Nodal_mesh.c:196:                + E->sphere.cap[m].V[3][node]*sint*sinf;
Nodal_mesh.c:197:            VV[3][a] = -E->sphere.cap[m].V[1][node]*sint
Nodal_mesh.c:198:                + E->sphere.cap[m].V[3][node]*cost;
Nodal_mesh.c:213:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:214:    for(node=1;node<=E->lmesh.NNO[lev];node++)
Nodal_mesh.c:217:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:218:    for(element=1;element<=E->lmesh.NEL[lev];element++)
Nodal_mesh.c:219:       for(j=1;j<=enodes[E->mesh.nsd];j++)  {
Nodal_mesh.c:220:     	  node = E->IEN[lev][m][element].node[j];
Nodal_mesh.c:221:    	  PN[m][node] += P[m][element] * E->TWW[lev][m][element].node[j] ;
Nodal_mesh.c:224:   (E->exchange_node_f)(E,PN,lev);
Nodal_mesh.c:226:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:227:     for(node=1;node<=E->lmesh.NNO[lev];node++)
Nodal_mesh.c:228:        PN[m][node] *= E->MASS[lev][m][node];
Nodal_mesh.c:245:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:250:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:251:    for(i=1;i<=E->lmesh.NNO[lev];i++)
Nodal_mesh.c:253:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:254:    for(e=1;e<=E->lmesh.NEL[lev];e++)   {
Nodal_mesh.c:261:	n = E->IEN[lev][m][e].node[j];
Nodal_mesh.c:262:	VN[m][n] += E->TWW[lev][m][e].node[j] * temp_visc;
Nodal_mesh.c:265:  (E->exchange_node_f)(E,VN,lev);
Nodal_mesh.c:266:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:267:    for(n=1;n<=E->lmesh.NNO[lev];n++)
Nodal_mesh.c:268:      VN[m][n] *= E->MASS[lev][m][n];
Nodal_mesh.c:285:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:291:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:292:    for(e=1;e<=E->lmesh.NEL[lev];e++)
Nodal_mesh.c:295:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:296:    for(e=1;e<=E->lmesh.NEL[lev];e++)
Nodal_mesh.c:300:	  temp_visc += E->N.vpt[GNVINDEX(j,i)]*VN[m][E->IEN[lev][m][e].node[j]];
Nodal_mesh.c:309:   visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv) 
Nodal_mesh.c:318:    const int nsd=E->mesh.nsd;
Nodal_mesh.c:323:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:324:      for(i=1;i<=E->lmesh.NEL[lev];i++)
Nodal_mesh.c:326:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:327:      for(e=1;e<=E->lmesh.NEL[lev];e++)   {
Nodal_mesh.c:340:   visc_from_ele_to_gint(E,viscD,E->EVI[sl_minus],sl_minus); 
Nodal_mesh.c:350:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:355:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:356:    for(e=1;e<=E->lmesh.NEL[lev];e++)
Obsolete.c:66:  const int dims=E->mesh.nsd;
Obsolete.c:82:          x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]*
Obsolete.c:83:                E->N.vpt[GNVINDEX(i,k)];
Obsolete.c:88:            dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Obsolete.c:89:               * E->Nx.vpt[GNVXINDEX(d-1,i,k)];
Obsolete.c:91:      jacobian = determinant(dxda,E->mesh.nsd);
Obsolete.c:106:                 E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Obsolete.c:125:                 E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Obsolete.c:143:          x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Obsolete.c:144:                 *E->N.ppt[GNPINDEX(i,k)];
Obsolete.c:149:            dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Obsolete.c:150:                     * E->Nx.ppt[GNPXINDEX(d-1,i,k)];
Obsolete.c:152:      jacobian = determinant(dxda,E->mesh.nsd);
Obsolete.c:157:          cof[d][e]=cofactor(dxda,d,e,E->mesh.nsd);
Obsolete.c:166:                E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Obsolete.c:184:                E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Obsolete.c:210:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Obsolete.c:216:   for(k=1;k<=vpoints[E->mesh.nsd];k++)  {
Obsolete.c:222:            dxda[d][e] += E->NMx.vpt[GNVXINDEX(d-1,i,k)]
Obsolete.c:223:                * E->x[m][e][E->ien[m][el].node[i]];
Obsolete.c:234:        jacobian = sqrt(fabs(determinant(cof,E->mesh.nsd)))/cof[3][3];
Obsolete.c:266:  const int oned = onedvpoints[E->mesh.nsd];
Obsolete.c:267:  const int vpts = vpoints[E->mesh.nsd-1];
Obsolete.c:268:  const int ppts = ppoints[E->mesh.nsd-1];
Obsolete.c:269:  const int ends = enodes[E->mesh.nsd-1];
Obsolete.c:287:  to = E->eco[m][el].centre[1];
Obsolete.c:288:  fo = E->eco[m][el].centre[2];
Obsolete.c:289:  ro = E->eco[m][el].centre[3];
Obsolete.c:304:    node=E->ien[m][el].node[a];
Obsolete.c:305:    xx[1][i] = E->x[m][1][node]*dxdy[1][1]
Obsolete.c:306:      + E->x[m][2][node]*dxdy[1][2]
Obsolete.c:307:      + E->x[m][3][node]*dxdy[1][3];
Obsolete.c:308:    xx[2][i] = E->x[m][1][node]*dxdy[2][1]
Obsolete.c:309:      + E->x[m][2][node]*dxdy[2][2]
Obsolete.c:310:      + E->x[m][3][node]*dxdy[2][3];
Obsolete.c:311:    xx[3][i] = E->x[m][1][node]*dxdy[3][1]
Obsolete.c:312:      + E->x[m][2][node]*dxdy[3][2]
Obsolete.c:313:      + E->x[m][3][node]*dxdy[3][3];
Obsolete.c:317:    for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:318:      for(e=1;e<=E->mesh.nsd-1;e++)
Obsolete.c:324:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:325:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:326:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Obsolete.c:333:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:334:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:335:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Obsolete.c:342:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:343:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:344:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Obsolete.c:349:    jacobian = determinant(dxda,E->mesh.nsd-1);
Obsolete.c:354:    for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:355:      for(e=1;e<=E->mesh.nsd-1;e++)
Obsolete.c:361:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:362:	  for(e=1;e<=E->mesh.nsd-1;e++)
Obsolete.c:363:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Obsolete.c:369:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:370:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:372:	    node=E->ien[m][el].node[a];
Obsolete.c:373:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Obsolete.c:380:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:381:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:383:	    node=E->ien[m][el].node[a];
Obsolete.c:384:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Obsolete.c:389:    jacobian = determinant(dxda,E->mesh.nsd-1);
Obsolete.c:425:  for(i=1;i<=E->mesh.nsd;i++)
Obsolete.c:426:    { for(a=1;a<=enodes[E->mesh.nsd];a++)
Obsolete.c:427:	{ if (E->node[m][E->ien[m][el].node[a]] & type)
Obsolete.c:429:		{  get_elt_g(E,el,elt_g,E->mesh.levmax,m);
Obsolete.c:433:	      p=E->mesh.nsd*(a-1) + i - 1;
Obsolete.c:434:	      for(b=1;b<=pnodes[E->mesh.nsd];b++)
Obsolete.c:436:		  elt_h[q] -= elt_g[p][q] * E->sphere.cap[m].VB[i][E->ien[m][el].node[a]];
Obsolete.c:457:  const int nel=E->lmesh.nel;
Obsolete.c:458:  const int vpts=vpoints[E->mesh.nsd];
Obsolete.c:460:  lev = E->mesh.levmax;
Obsolete.c:462:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:466:        EV[el] +=  E->EVI[lev][m][(el-1)*vpts+j];
Obsolete.c:492:    E->sphere.con = (double *)malloc(E->sphere.hindice*sizeof(double));
Obsolete.c:493:    for (ll=0;ll<=E->output.llmax;ll++)
Obsolete.c:495:	    E->sphere.con[E->sphere.hindex[ll][mm]] =
Obsolete.c:500:    E->sphere.tablenplm   = (double **) malloc((E->sphere.nox+1)
Obsolete.c:502:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:503:	E->sphere.tablenplm[i]= (double *)malloc(E->sphere.hindice
Obsolete.c:506:    E->sphere.tablencosf  = (double **) malloc((E->sphere.noy+1)
Obsolete.c:508:    E->sphere.tablensinf  = (double **) malloc((E->sphere.noy+1)
Obsolete.c:510:    for (i=1;i<=E->sphere.noy;i++)   {
Obsolete.c:511:	E->sphere.tablencosf[i]= (double *)malloc((E->output.llmax+3)
Obsolete.c:513:	E->sphere.tablensinf[i]= (double *)malloc((E->output.llmax+3)
Obsolete.c:517:    E->sphere.sx[1] = (double *) malloc((E->sphere.nsf+1)*sizeof(double));
Obsolete.c:518:    E->sphere.sx[2] = (double *) malloc((E->sphere.nsf+1)*sizeof(double));
Obsolete.c:520:    dth = M_PI/E->sphere.elx;
Obsolete.c:521:    dfi = 2.0*M_PI/E->sphere.ely;
Obsolete.c:523:    for (j=1;j<=E->sphere.noy;j++)
Obsolete.c:524:	for (i=1;i<=E->sphere.nox;i++) {
Obsolete.c:525:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:526:	    E->sphere.sx[1][node] = dth*(i-1);
Obsolete.c:527:	    E->sphere.sx[2][node] = dfi*(j-1);
Obsolete.c:530:    for (j=1;j<=E->sphere.nox;j++)  {
Obsolete.c:531:	t=E->sphere.sx[1][j];
Obsolete.c:532:	for (ll=0;ll<=E->output.llmax;ll++)
Obsolete.c:534:		p = E->sphere.hindex[ll][mm];
Obsolete.c:535:		E->sphere.tablenplm[j][p] = modified_plgndr_a(ll,mm,t) ;
Obsolete.c:538:    for (j=1;j<=E->sphere.noy;j++)  {
Obsolete.c:539:	node = 1+(j-1)*E->sphere.nox;
Obsolete.c:540:	f=E->sphere.sx[2][node];
Obsolete.c:541:	for (mm=0;mm<=E->output.llmax;mm++)   {
Obsolete.c:542:	    E->sphere.tablencosf[j][mm] = cos( (double)(mm)*f );
Obsolete.c:543:	    E->sphere.tablensinf[j][mm] = sin( (double)(mm)*f );
Obsolete.c:565:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:566:	for (j=1;j<=E->sphere.noy;j++)   {
Obsolete.c:567:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:568:	    E->sphere.int_cap[node]=0;
Obsolete.c:569:	    E->sphere.int_ele[node]=0;
Obsolete.c:573:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:574:	for (j=1;j<=E->sphere.noy;j++)   {
Obsolete.c:575:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:578:	    t = E->sphere.sx[1][node];
Obsolete.c:579:	    f = E->sphere.sx[2][node];
Obsolete.c:586:	    fprintf(E->fp,"mmm0=%d\n",node);
Obsolete.c:590:	    fprintf(E->fp,"mmm=%d\n",m);
Obsolete.c:596:		    fprintf(stderr,"!!! Processor %d cannot find the right element in cap %d\n",E->parallel.me,m);
Obsolete.c:600:		E->sphere.int_cap[node]=m;
Obsolete.c:601:		E->sphere.int_ele[node]=el;
Obsolete.c:629:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Obsolete.c:631:	ia[2] = E->lmesh.noz*E->lmesh.nox-E->lmesh.noz+1;
Obsolete.c:632:	ia[3] = E->lmesh.nno-E->lmesh.noz+1;
Obsolete.c:633:	ia[4] = ia[3]-E->lmesh.noz*(E->lmesh.nox-1);
Obsolete.c:636:	    xx[1] = E->x[m][1][ia[i]]/E->sx[m][3][ia[1]];
Obsolete.c:637:	    xx[2] = E->x[m][2][ia[i]]/E->sx[m][3][ia[1]];
Obsolete.c:638:	    xx[3] = E->x[m][3][ia[i]]/E->sx[m][3][ia[1]];
Obsolete.c:640:	    angle1[i]=E->sphere.angle[m][i];
Obsolete.c:648:	if ( fabs ((area1-E->sphere.area[m])/E->sphere.area[m]) <e_7 ) {
Obsolete.c:678:    level=E->mesh.levmin;
Obsolete.c:679:    for (es=1;es<=E->lmesh.SNEL[level];es++)              {
Obsolete.c:681:	el = (es-1)*E->lmesh.ELZ[level]+1;
Obsolete.c:683:	area = E->sphere.area1[level][m][es];
Obsolete.c:686:	    for (lev=E->mesh.levmin;lev<E->mesh.levmax;lev++)  {
Obsolete.c:691:		    el_plus = E->EL[lev][m][el].sub[j];
Obsolete.c:693:		    es_plus = (el_plus-1)/E->lmesh.ELZ[lev_plus]+1;
Obsolete.c:696:		    area = E->sphere.area1[lev_plus][m][es_plus];
Obsolete.c:744:    es = (el-1)/E->lmesh.elz+1;
Obsolete.c:746:    to = E->eco[m][el].centre[1];
Obsolete.c:747:    fo = E->eco[m][el].centre[2];
Obsolete.c:760:	node = E->ien[m][el].node[i];
Obsolete.c:761:	snode = E->sien[m][es].node[i];
Obsolete.c:763:	for (j=1;j<=E->mesh.nsd;j++)
Obsolete.c:764:	    yy[j][i] = E->x[m][1][node]*dxdy[j][1]
Obsolete.c:765:                + E->x[m][2][node]*dxdy[j][2]
Obsolete.c:766:                + E->x[m][3][node]*dxdy[j][3];
Obsolete.c:769:    for (j=1;j<=E->mesh.nsd;j++)
Obsolete.c:807:    /*if(fabs(xx1)>1.5 || fabs(yy1)>1.5)fprintf(E->fp_out,"ME= %d %d %d %g %g %g %g %g %g %g\n",ne,m,es,t[1],t[2],t[3],t[4],ta,xx1,yy1);
Obsolete.c:832:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:833:	for (j=1;j<=E->sphere.noy;j++)   {
Obsolete.c:834:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:838:	    m = E->sphere.int_cap[node];
Obsolete.c:839:	    el = E->sphere.int_ele[node];
Obsolete.c:842:		t = E->sphere.sx[1][node];
Obsolete.c:843:		f = E->sphere.sx[2][node];
Obsolete.c:845:		x[1] = E->sx[1][3][1]*sin(t)*cos(f);
Obsolete.c:846:		x[2] = E->sx[1][3][1]*sin(t)*sin(f);
Obsolete.c:847:		x[3] = E->sx[1][3][1]*cos(t);
Obsolete.c:876:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Obsolete.c:877:    for(i=1;i<=E->lmesh.nno;i++)  {
Obsolete.c:878:      e_pressure = (E->sphere.ro-E->sx[m][3][i])-E->viscosity.z410-
Obsolete.c:879:            E->control.clapeyron410*(E->T[m][i]-E->control.transT410);
Obsolete.c:881:      B[m][i] = pt5*(one+tanh(E->control.width410*e_pressure));
Obsolete.c:885:    for (k=1;k<=E->lmesh.noy;k++)
Obsolete.c:886:      for (j=1;j<=E->lmesh.nox;j++)  {
Obsolete.c:889:        for (i=1;i<E->lmesh.noz;i++)   {
Obsolete.c:890:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Obsolete.c:892:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Obsolete.c:911:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Obsolete.c:912:    for(i=1;i<=E->lmesh.nno;i++)  {
Obsolete.c:913:      e_pressure = (E->sphere.ro-E->sx[m][3][i])-E->viscosity.zlm-
Obsolete.c:914:            E->control.clapeyron670*(E->T[m][i]-E->control.transT670);
Obsolete.c:916:      B[m][i] = pt5*(one+tanh(E->control.width670*e_pressure));
Obsolete.c:920:    for (k=1;k<=E->lmesh.noy;k++)
Obsolete.c:921:      for (j=1;j<=E->lmesh.nox;j++)  {
Obsolete.c:924:        for (i=1;i<E->lmesh.noz;i++)   {
Obsolete.c:925:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Obsolete.c:927:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Obsolete.c:946:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Obsolete.c:947:    for(i=1;i<=E->lmesh.nno;i++)  {
Obsolete.c:948:      e_pressure = (E->sphere.ro-E->sx[m][3][i])-E->viscosity.zcmb-
Obsolete.c:949:            E->control.clapeyroncmb*(E->T[m][i]-E->control.transTcmb);
Obsolete.c:951:      B[m][i] = pt5*(one+tanh(E->control.widthcmb*e_pressure));
Obsolete.c:955:    for (k=1;k<=E->lmesh.noy;k++)
Obsolete.c:956:      for (j=1;j<=E->lmesh.nox;j++)  {
Obsolete.c:959:        for (i=1;i<E->lmesh.noz;i++)   {
Obsolete.c:960:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Obsolete.c:962:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Obsolete.c:995:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:996:    for(p=1;p<=E->lmesh.NEL[lev];p++)
Obsolete.c:999:   weight=1.0/((double)enodes[E->mesh.nsd]) ;
Obsolete.c:1001:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1002:    for(p=1;p<=E->lmesh.NEL[lev];p++)
Obsolete.c:1003:      for(j=1;j<=enodes[E->mesh.nsd];j++)
Obsolete.c:1004:        P[m][p] += PN[m][E->IEN[lev][m][p].node[j]] * weight;
Obsolete.c:1017:   const int nsd=E->mesh.nsd;
Obsolete.c:1021: for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1022:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Obsolete.c:1026:          VE[m][(e-1)*vpts + i] += VN[m][E->IEN[lev][m][e].node[j]]*E->N.vpt[GNVINDEX(j,i)];
Obsolete.c:1040:   const int nsd=E->mesh.nsd;
Obsolete.c:1044: for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1045:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Obsolete.c:1049:          VE[m][(e-1)*vpts + i] += log(VN[m][E->IEN[lev][m][e].node[j]]) *  E->N.vpt[GNVINDEX(j,i)];
Obsolete.c:1163:    if(!input_string(input_token,filename,"initialize",E->parallel.me)) {
Obsolete.c:1164:	fprintf(E->fp,"No previous %s information found in input file\n",name);fflush(E->fp);
Obsolete.c:1169:    fprintf(E->fp,"Previous %s information is in file %s\n",name,filename);fflush(E->fp);
Obsolete.c:1174:	fprintf(E->fp,"Unable to open the required file `%s' (this is fatal)",filename);
Obsolete.c:1175:	fflush(E->fp);
Obsolete.c:1187:	fprintf(E->fp,"File %s is not in the correct format\n",filename);fflush(E->fp);
Obsolete.c:1198:	fprintf(E->fp,"Unable to deciphre the columns in the input file");fflush(E->fp);
Obsolete.c:1212:	fprintf(E->fp,"\t%s (%s) found in column %d\n",name,abbr,column);fflush(E->fp);
Obsolete.c:1215:	fprintf(E->fp,"\t%s (%s) not found in file: %s\n",name,abbr,filename);fflush(E->fp);
Obsolete.c:1222:    if(((3!= E->mesh.nsd) && (fnodesy !=1)) || ((3==E->mesh.nsd) && (1==fnodesy))) {
Obsolete.c:1223:	fprintf(E->fp,"Input data for file `%s'  is of inappropriate dimension (not %dD)\n",filename,E->mesh.nsd);fflush(E->fp);
Obsolete.c:1227:    if(fnodesx != E->lmesh.nox || fnodesz != E->lmesh.noz || fnodesy != E->lmesh.noy) {
Obsolete.c:1244:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1392:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1490:  n = loc_mat_size[E->mesh.nsd];
Obsolete.c:1573:    const int dims=E->mesh.nsd;
Obsolete.c:1575:    const int n=loc_mat_size[E->mesh.nsd];
Obsolete.c:1576:    const int neq=E->lmesh.NEQ[level];
Obsolete.c:1577:    const int num_nodes=E->lmesh.NNO[level];
Obsolete.c:1578:    const int nox=E->lmesh.NOX[level];
Obsolete.c:1579:    const int noz=E->lmesh.NOY[level];
Obsolete.c:1580:    const int noy=E->lmesh.NOZ[level];
Obsolete.c:1583:    gneq = E->mesh.NEQ[level];
Obsolete.c:1587:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1588:      r1[m] = (double *)malloc(E->lmesh.neq*sizeof(double));
Obsolete.c:1591:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1596:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1601:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1609:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1610: 	for(i=1;i<=E->lmesh.NNO[level];i++)  {
Obsolete.c:1611:	    eqn1=E->ID[level][m][i].doff[1];
Obsolete.c:1612:	    eqn2=E->ID[level][m][i].doff[2];
Obsolete.c:1613:	    eqn3=E->ID[level][m][i].doff[3];
Obsolete.c:1614:            d0[m][eqn1] += r1[m][eqn1]*E->BI[level][m][eqn1];
Obsolete.c:1615:            d0[m][eqn2] += r1[m][eqn2]*E->BI[level][m][eqn2];
Obsolete.c:1616:            d0[m][eqn3] += r1[m][eqn3]*E->BI[level][m][eqn3];
Obsolete.c:1619:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1623:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1624: 	for(i=1;i<=E->lmesh.NNO[level];i++)  {
Obsolete.c:1625:	    eqn1=E->ID[level][m][i].doff[1];
Obsolete.c:1626:	    eqn2=E->ID[level][m][i].doff[2];
Obsolete.c:1627:	    eqn3=E->ID[level][m][i].doff[3];
Obsolete.c:1632:            C=E->Node_map[level][m]+(i-1)*max_eqn;
Obsolete.c:1633:	    B1=E->Eqn_k1[level][m]+(i-1)*max_eqn;
Obsolete.c:1634:	    B2=E->Eqn_k2[level][m]+(i-1)*max_eqn;
Obsolete.c:1635: 	    B3=E->Eqn_k3[level][m]+(i-1)*max_eqn;
Obsolete.c:1648:      (E->solver.exchange_id_d)(E, Ad, level);
Obsolete.c:1650:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1656:   if(E->parallel.me==0)fprintf(stderr,"residuall =%.5e for %d\n",residual,count);
Obsolete.c:1662:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Output.c:73:    int m = E->parallel.me;
Output.c:75:    input_string("output_format", E->output.format, "ascii",m);
Output.c:76:    input_string("output_optional", E->output.optional, "surf,botm,tracer",m);
Output.c:79:    E->output.gzdir.vtk_io = 0;
Output.c:80:    E->output.gzdir.rnr = 0;
Output.c:81:    if(strcmp(E->output.format, "ascii-gz") == 0){
Output.c:88:      input_int("gzdir_vtkio",&(E->output.gzdir.vtk_io),"1",m);
Output.c:90:      input_boolean("gzdir_rnr",&(E->output.gzdir.rnr),"off",m);
Output.c:91:      E->output.gzdir.vtk_base_init = 0;
Output.c:92:      E->output.gzdir.vtk_base_save = 1; /* should we save the basis vectors? (memory!) */
Output.c:94:      //      E->output.gzdir.vtk_io,E->output.gzdir.vtk_base_save);
Output.c:97:    if(strcmp(E->output.format, "vtk") == 0) {
Output.c:98:        input_string("vtk_format", E->output.vtk_format, "ascii",m);
Output.c:99:        if (strcmp(E->output.vtk_format, "binary") != 0 &&
Output.c:100:            strcmp(E->output.vtk_format, "ascii") != 0) {
Output.c:101:            if(E->parallel.me == 0) {
Output.c:102:                fprintf(stderr, "Unknown vtk_format: %s\n", E->output.vtk_format);
Output.c:119:    if (E->output.coord_bin)
Output.c:136:  if (E->output.geoid)		/* this needs to be called after the
Output.c:141:  if (E->output.stress){
Output.c:144:  if (E->output.pressure)
Output.c:147:  if (E->output.horiz_avg)
Output.c:150:  if (E->output.seismic)
Output.c:153:  if(E->output.tracer && E->control.tracer)
Output.c:156:  if (E->output.comp_nd && E->composition.on)
Output.c:159:  if (E->output.comp_el && E->composition.on)
Output.c:162:  if(E->output.heating && E->control.disptn_number != 0)
Output.c:195:  sprintf(output_file,"%s.coord.%d",E->control.data_file,E->parallel.me);
Output.c:198:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Output.c:199:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Output.c:200:    for(i=1;i<=E->lmesh.nno;i++)
Output.c:201:      fprintf(fp1,"%.6e %.6e %.6e\n",E->sx[j][1][i],E->sx[j][2][i],E->sx[j][3][i]);
Output.c:221:    const int nox = E->lmesh.nox;
Output.c:222:    const int noy = E->lmesh.noy;
Output.c:223:    const int noz = E->lmesh.noz;
Output.c:235:    buffer[0] = E->sx[j][3][1];
Output.c:236:    buffer[1] = E->sx[j][3][noz];
Output.c:237:    buffer[2] = E->sx[j][1][corner_nodes[0]];
Output.c:238:    buffer[3] = E->sx[j][2][corner_nodes[0]];
Output.c:239:    buffer[4] = E->sx[j][1][corner_nodes[1]];
Output.c:240:    buffer[5] = E->sx[j][2][corner_nodes[1]];
Output.c:241:    buffer[6] = E->sx[j][1][corner_nodes[2]];
Output.c:242:    buffer[7] = E->sx[j][2][corner_nodes[2]];
Output.c:243:    buffer[8] = E->sx[j][1][corner_nodes[3]];
Output.c:244:    buffer[9] = E->sx[j][2][corner_nodes[3]];
Output.c:246:    if(E->parallel.me == 0) {
Output.c:253:        sprintf(output_file,"%s.domain",E->control.data_file);
Output.c:257:        header[0] = E->parallel.nproc;
Output.c:267:        for(rank=1; rank<E->parallel.nproc; rank++) {
Output.c:268:            MPI_Recv(buffer, ncolumns, MPI_DOUBLE, rank, tag, E->parallel.world, &status);
Output.c:275:        MPI_Send(buffer, ncolumns, MPI_DOUBLE, receiver, tag, E->parallel.world);
Output.c:291:  sprintf(output_file,"%s.coord_bin.%d",E->control.data_file,E->parallel.me);
Output.c:294:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:296:      header[0] = E->lmesh.nox;
Output.c:297:      header[1] = E->lmesh.noy;
Output.c:298:      header[2] = E->lmesh.noz;
Output.c:302:      fwrite(&(E->x[j][1][1]), sizeof(double), E->lmesh.nno, fp1);
Output.c:303:      fwrite(&(E->x[j][2][1]), sizeof(double), E->lmesh.nno, fp1);
Output.c:304:      fwrite(&(E->x[j][3][1]), sizeof(double), E->lmesh.nno, fp1);
Output.c:318:  int lev = E->mesh.levmax;
Output.c:320:  sprintf(output_file,"%s.visc.%d.%d", E->control.data_file,
Output.c:321:          E->parallel.me, cycles);
Output.c:325:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:326:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Output.c:327:    for(i=1;i<=E->lmesh.nno;i++)
Output.c:328:      fprintf(fp1,"%.4e\n",E->VI[lev][j][i]);
Output.c:342:  int lev = E->mesh.levmax;
Output.c:343:  if(E->viscosity.allow_anisotropic_viscosity){
Output.c:344:    sprintf(output_file,"%s.avisc.%d.%d", E->control.data_file,
Output.c:345:	    E->parallel.me, cycles);
Output.c:347:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:348:      fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Output.c:349:      for(i=1;i<=E->lmesh.nno;i++)
Output.c:350:	fprintf(fp1,"%.4e %.4e %.4e %.4e\n",E->VI2[lev][j][i],E->VIn1[lev][j][i],E->VIn2[lev][j][i],E->VIn3[lev][j][i]);
Output.c:366:  sprintf(output_file,"%s.velo.%d.%d", E->control.data_file,
Output.c:367:          E->parallel.me, cycles);
Output.c:370:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output.c:372:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:373:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Output.c:374:    for(i=1;i<=E->lmesh.nno;i++) {
Output.c:375:        fprintf(fp1,"%.6e %.6e %.6e %.6e\n",E->sphere.cap[j].V[1][i],E->sphere.cap[j].V[2][i],E->sphere.cap[j].V[3][i],E->T[j][i]);
Output.c:392:  if((E->output.write_q_files == 0) || (cycles == 0) ||
Output.c:393:     (cycles % E->output.write_q_files)!=0)
Output.c:397:  if(E->control.use_cbf_topo){
Output.c:398:    get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);
Output.c:401:    get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,cycles);
Output.c:404:  if (E->output.surf && (E->parallel.me_loc[3]==E->parallel.nprocz-1)) {
Output.c:405:    sprintf(output_file,"%s.surf.%d.%d", E->control.data_file,
Output.c:406:            E->parallel.me, cycles);
Output.c:409:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Output.c:411:        if(E->control.pseudo_free_surf)
Output.c:412:            topo = E->slice.freesurf[j];
Output.c:414:            topo = E->slice.tpg[j];
Output.c:416:        fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Output.c:417:        for(i=1;i<=E->lmesh.nsf;i++)   {
Output.c:418:            s = i*E->lmesh.noz;
Output.c:420:		    topo[i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Output.c:427:  if (E->output.botm && (E->parallel.me_loc[3]==0)) {
Output.c:428:    sprintf(output_file,"%s.botm.%d.%d", E->control.data_file,
Output.c:429:            E->parallel.me, cycles);
Output.c:432:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Output.c:433:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Output.c:434:      for(i=1;i<=E->lmesh.nsf;i++)  {
Output.c:435:        s = (i-1)*E->lmesh.noz + 1;
Output.c:437:		E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Output.c:456:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Output.c:457:        sprintf(output_file, "%s.geoid.%d.%d", E->control.data_file,
Output.c:458:                E->parallel.me, cycles);
Output.c:462:        fprintf(fp1, "%d %d %.5e\n", cycles, E->output.llmax,
Output.c:463:                E->monitor.elapsed_time);
Output.c:466:        for (ll=0; ll<=E->output.llmax; ll++)
Output.c:468:                p = E->sphere.hindex[ll][mm];
Output.c:471:                        E->sphere.harm_geoid[0][p],
Output.c:472:                        E->sphere.harm_geoid[1][p],
Output.c:473:                        E->sphere.harm_geoid_from_tpgt[0][p],
Output.c:474:                        E->sphere.harm_geoid_from_tpgt[1][p],
Output.c:475:                        E->sphere.harm_geoid_from_bncy[0][p],
Output.c:476:                        E->sphere.harm_geoid_from_bncy[1][p]);
Output.c:499:  if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Output.c:504:  sprintf(output_file,"%s.stress.%d.%d", E->control.data_file,
Output.c:505:          E->parallel.me, cycles);
Output.c:508:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output.c:510:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Output.c:511:    fprintf(fp1,"%3d %7d\n",m,E->lmesh.nno);
Output.c:513:    for (node=1;node<=E->lmesh.nno;node++)
Output.c:515:              E->gstress[m][(node-1)*6+1],
Output.c:516:              E->gstress[m][(node-1)*6+2],
Output.c:517:              E->gstress[m][(node-1)*6+3],
Output.c:518:              E->gstress[m][(node-1)*6+4],
Output.c:519:              E->gstress[m][(node-1)*6+5],
Output.c:520:              E->gstress[m][(node-1)*6+6]);
Output.c:540:  if (E->parallel.me<E->parallel.nprocz)  {
Output.c:541:    sprintf(output_file,"%s.horiz_avg.%d.%d", E->control.data_file,
Output.c:542:            E->parallel.me, cycles);
Output.c:544:    for(j=1;j<=E->lmesh.noz;j++)  {
Output.c:545:        fprintf(fp1,"%.4e %.4e %.4e %.4e %.4e",E->sx[1][3][j],
Output.c:546:		E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j],E->Have.vis[j]);
Output.c:548:        if (E->composition.on) {
Output.c:550:            for(n=0; n<E->composition.ncomp; n++)
Output.c:551:                fprintf(fp1," %.4e", E->Have.C[n][j]);
Output.c:574:    const int len = E->lmesh.nno;
Output.c:588:    sprintf(output_file,"%s.seismic.%d.%d", E->control.data_file, E->parallel.me, cycles);
Output.c:591:    fwrite(rho, sizeof(double), E->lmesh.nno, fp);
Output.c:592:    fwrite(vp, sizeof(double), E->lmesh.nno, fp);
Output.c:593:    fwrite(vs, sizeof(double), E->lmesh.nno, fp);
Output.c:599:    sprintf(output_file,"%s.dv.%d.%d", E->control.data_file, E->parallel.me, cycles);
Output.c:601:    fprintf(fp, "%d %d %.5e\n", cycles, E->lmesh.nno, E->monitor.elapsed_time);
Output.c:602:    for(i=0; i<E->lmesh.nno; i++) {
Output.c:604:        int nz = (i % E->lmesh.noz) + 1;
Output.c:605:        get_prem(E->sx[1][3][nz], &vpr, &vsr, &rhor);
Output.c:629:  sprintf(output_file,"%s.mat.%d", E->control.data_file,E->parallel.me);
Output.c:632:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Output.c:633:    for(el=1;el<=E->lmesh.nel;el++)
Output.c:634:      fprintf(fp,"%d %d %f\n", el,E->mat[m][el],E->VIP[m][el]);
Output.c:649:  sprintf(output_file,"%s.pressure.%d.%d", E->control.data_file,
Output.c:650:          E->parallel.me, cycles);
Output.c:653:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output.c:655:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:656:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Output.c:657:    for(i=1;i<=E->lmesh.nno;i++)
Output.c:658:      fprintf(fp1,"%.6e\n",E->NP[j][i]);
Output.c:674:  sprintf(output_file,"%s.tracer.%d.%d", E->control.data_file,
Output.c:675:          E->parallel.me, cycles);
Output.c:678:  ncolumns = 3 + E->trace.number_of_extra_quantities;
Output.c:680:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:681:      fprintf(fp1,"%d %d %d %.5e\n", cycles, E->trace.ntracers[j],
Output.c:682:              ncolumns, E->monitor.elapsed_time);
Output.c:684:      for(n=1;n<=E->trace.ntracers[j];n++) {
Output.c:687:                  E->trace.basicq[j][0][n],
Output.c:688:                  E->trace.basicq[j][1][n],
Output.c:689:                  E->trace.basicq[j][2][n]);
Output.c:692:          for (i=0; i<E->trace.number_of_extra_quantities; i++) {
Output.c:693:              fprintf(fp1," %.12e", E->trace.extraq[j][i][n]);
Output.c:711:    sprintf(output_file,"%s.comp_nd.%d.%d", E->control.data_file,
Output.c:712:            E->parallel.me, cycles);
Output.c:715:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:717:                j, E->lmesh.nel,
Output.c:718:                E->monitor.elapsed_time, E->composition.ncomp);
Output.c:719:        for(i=0;i<E->composition.ncomp;i++) {
Output.c:721:                    E->composition.initial_bulk_composition[i],
Output.c:722:                    E->composition.bulk_composition[i]);
Output.c:726:        for(i=1;i<=E->lmesh.nno;i++) {
Output.c:727:            for(k=0;k<E->composition.ncomp;k++) {
Output.c:728:                fprintf(fp1,"%.6e ",E->composition.comp_node[j][k][i]);
Output.c:746:    sprintf(output_file,"%s.comp_el.%d.%d", E->control.data_file,
Output.c:747:            E->parallel.me, cycles);
Output.c:750:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:752:                j, E->lmesh.nel,
Output.c:753:                E->monitor.elapsed_time, E->composition.ncomp);
Output.c:754:        for(i=0;i<E->composition.ncomp;i++) {
Output.c:756:                    E->composition.initial_bulk_composition[i],
Output.c:757:                    E->composition.bulk_composition[i]);
Output.c:761:        for(i=1;i<=E->lmesh.nel;i++) {
Output.c:762:            for(k=0;k<E->composition.ncomp;k++) {
Output.c:764:			E->composition.comp_el[j][k][i]);
Output.c:781:    sprintf(output_file,"%s.heating.%d.%d", E->control.data_file,
Output.c:782:            E->parallel.me, cycles);
Output.c:785:    fprintf(fp1,"%.5e\n",E->monitor.elapsed_time);
Output.c:787:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:788:        fprintf(fp1,"%3d %7d\n", j, E->lmesh.nel);
Output.c:789:        for(e=1; e<=E->lmesh.nel; e++)
Output.c:790:            fprintf(fp1, "%.4e %.4e %.4e\n", E->heating_adi[j][e],
Output.c:791:                    E->heating_visc[j][e], E->heating_latent[j][e]);
Output.c:805:  if (E->parallel.me == 0) {
Output.c:806:    fprintf(E->fptime,"%d %.4e %.4e %.4e %.4e\n",
Output.c:808:            E->monitor.elapsed_time,
Output.c:809:            E->advection.timestep,
Output.c:810:            current_time - E->monitor.cpu_time_at_start,
Output.c:811:            current_time - E->monitor.cpu_time_at_last_cycle);
Output.c:813:    fflush(E->fptime);
Output.c:816:  E->monitor.cpu_time_at_last_cycle = current_time;
Output_gzdir.c:147:    if (E->output.coord_bin)
Output_gzdir.c:159:  snprintf(output_dir,255,"%s/%d",E->control.data_dir,out_cycles);
Output_gzdir.c:178:  if (E->output.geoid)
Output_gzdir.c:181:  if (E->output.stress){
Output_gzdir.c:184:  if (E->output.pressure)
Output_gzdir.c:187:  if (E->output.horiz_avg)
Output_gzdir.c:190:  if(E->control.tracer){
Output_gzdir.c:191:    if(E->output.tracer ||
Output_gzdir.c:192:       (out_cycles == E->advection.max_timesteps))
Output_gzdir.c:196:  if (E->output.comp_nd && E->composition.on)
Output_gzdir.c:199:  if (E->output.comp_el && E->composition.on)
Output_gzdir.c:202:  if(E->output.heating && E->control.disptn_number != 0)
Output_gzdir.c:241:  if((E->output.gzdir.vtk_io == 2)||(E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:245:    if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:252:    E->output.gzdir.vtk_ocount = -1;
Output_gzdir.c:254:    if(E->parallel.me == 0){
Output_gzdir.c:256:      snprintf(message,255,"%s/vtk_time.log",E->control.data_dir);
Output_gzdir.c:257:      E->output.gzdir.vtk_fp = output_open(message,"w");
Output_gzdir.c:259:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:271:      if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:273:		E->lmesh.nno * E->parallel.nproc *
Output_gzdir.c:274:		E->sphere.caps_per_proc);
Output_gzdir.c:277:		E->lmesh.nno * E->sphere.caps_per_proc);
Output_gzdir.c:281:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:287:    for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:288:      for(i=1;i <= E->lmesh.nno;i++) {
Output_gzdir.c:290:	x[0]=E->x[j][1][i];x[1]=E->x[j][2][i];x[2]=E->x[j][3][i];
Output_gzdir.c:296:    if(E->output.gzdir.vtk_io == 2){ /* serial output, close and have
Output_gzdir.c:299:      if(E->parallel.me <  E->parallel.nproc-1){/* send to next if not last*/
Output_gzdir.c:300:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:307:    if((E->output.gzdir.vtk_io == 3) || (E->parallel.me == 0)){ /* in first CPU, or parallel output */
Output_gzdir.c:308:      if(E->output.gzdir.vtk_io == 2){ /* need to reopen, serial */
Output_gzdir.c:310:	j = E->parallel.nproc * E->lmesh.nel *
Output_gzdir.c:311:	  E->sphere.caps_per_proc; /* total number of elements */
Output_gzdir.c:313:	j = E->lmesh.nel * E->sphere.caps_per_proc;
Output_gzdir.c:319:	      j,j*(enodes[E->mesh.nsd]+1));
Output_gzdir.c:323:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:329:    if(enodes[E->mesh.nsd] != 8)
Output_gzdir.c:331:    if(E->output.gzdir.vtk_io == 2){ /* serial, global node numbers */
Output_gzdir.c:332:      offset = E->lmesh.nno * E->parallel.me - 1;
Output_gzdir.c:336:    ix[0] = enodes[E->mesh.nsd];
Output_gzdir.c:337:    for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:338:      for(i=1;i <= E->lmesh.nel;i++) {
Output_gzdir.c:343:	ix[1]= E->ien[j][i].node[1]+offset;ix[2] = E->ien[j][i].node[2]+offset;
Output_gzdir.c:344:	ix[3]= E->ien[j][i].node[3]+offset;ix[4] = E->ien[j][i].node[4]+offset;
Output_gzdir.c:345:	ix[5]= E->ien[j][i].node[5]+offset;ix[6] = E->ien[j][i].node[6]+offset;
Output_gzdir.c:346:	ix[7]= E->ien[j][i].node[7]+offset;ix[8] = E->ien[j][i].node[8]+offset;
Output_gzdir.c:351:    if(E->output.gzdir.vtk_io == 2){ /* serial IO */
Output_gzdir.c:353:      if(E->parallel.me <  E->parallel.nproc-1)
Output_gzdir.c:354:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:357:    if((E->output.gzdir.vtk_io==3) || (E->parallel.me == 0) ){
Output_gzdir.c:358:      if(E->output.gzdir.vtk_io == 2){ /* serial */
Output_gzdir.c:360:	j=E->parallel.nproc*E->lmesh.nel*E->sphere.caps_per_proc;
Output_gzdir.c:362:	j = E->lmesh.nel*E->sphere.caps_per_proc;
Output_gzdir.c:370:      if(E->parallel.me == 0)
Output_gzdir.c:384:	   E->control.data_dir,E->parallel.me);
Output_gzdir.c:388:    for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:389:      gzprintf(gz1,"%3d %7d\n",j,E->lmesh.nno);
Output_gzdir.c:390:      for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:392:		 E->sx[j][1][i],E->sx[j][2][i],E->sx[j][3][i]);
Output_gzdir.c:396:    if(E->output.gzdir.vtk_io == 1){
Output_gzdir.c:407:	       E->control.data_dir,E->parallel.me);
Output_gzdir.c:409:      for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:410:	for(i=1;i <= E->lmesh.nno;i++) {
Output_gzdir.c:412:		   E->x[j][1][i],E->x[j][2][i],E->x[j][3][i]);
Output_gzdir.c:419:      offset = E->lmesh.nno * E->parallel.me - 1;
Output_gzdir.c:421:	       E->control.data_dir,E->parallel.me);
Output_gzdir.c:423:      for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:424:	for(i=1;i <= E->lmesh.nel;i++) {
Output_gzdir.c:425:	  gzprintf(gz1,"%2i\t",enodes[E->mesh.nsd]);
Output_gzdir.c:426:	  if(enodes[E->mesh.nsd] != 8){
Output_gzdir.c:435:		   E->ien[j][i].node[1]+offset,E->ien[j][i].node[2]+offset,
Output_gzdir.c:436:		   E->ien[j][i].node[3]+offset,E->ien[j][i].node[4]+offset,
Output_gzdir.c:437:		   E->ien[j][i].node[5]+offset,E->ien[j][i].node[6]+offset,
Output_gzdir.c:438:		   E->ien[j][i].node[7]+offset,E->ien[j][i].node[8]+offset);
Output_gzdir.c:470:  if(E->output.gzdir.vtk_io){	/* all VTK modes need basis vectors */
Output_gzdir.c:471:    os = E->lmesh.nno*9;
Output_gzdir.c:472:    if((!E->output.gzdir.vtk_base_init) ||(!E->output.gzdir.vtk_base_save)){
Output_gzdir.c:474:      if(!E->output.gzdir.vtk_base_init) /* init space */
Output_gzdir.c:475:	E->output.gzdir.vtk_base = (float *)safe_malloc(sizeof(float)*os*E->sphere.caps_per_proc);
Output_gzdir.c:477:      for(k=0,j=1;j <= E->sphere.caps_per_proc;j++,k += os)     {
Output_gzdir.c:478:	for(i=1;i <= E->lmesh.nno;i++,k += 9){
Output_gzdir.c:480:	  calc_cbase_at_node(j,i,(E->output.gzdir.vtk_base+k),E);
Output_gzdir.c:483:      E->output.gzdir.vtk_base_init = 1;
Output_gzdir.c:487:  if(E->output.gzdir.rnr){	/* remove the whole model net rotation */
Output_gzdir.c:488:    if((E->control.remove_rigid_rotation || E->control.remove_angular_momentum) &&
Output_gzdir.c:489:       (E->parallel.me == 0))	/* that's not too terrible but wastes time */
Output_gzdir.c:492:    if(E->parallel.me == 0)
Output_gzdir.c:496:  if((E->output.gzdir.vtk_io == 2) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:502:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:505:    E->output.gzdir.vtk_ocount++; /* regular output file name */
Output_gzdir.c:513:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:518:      if(E->parallel.me == 0){
Output_gzdir.c:520:	fprintf(E->output.gzdir.vtk_fp,"%12i %12i %12.6e %s\n",
Output_gzdir.c:521:		E->output.gzdir.vtk_ocount,cycles,E->monitor.elapsed_time,output_file);
Output_gzdir.c:524:      if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:525:	sprintf(message,"POINT_DATA %i\n",E->lmesh.nno*E->parallel.nproc*E->sphere.caps_per_proc);
Output_gzdir.c:527:	sprintf(message,"POINT_DATA %i\n",E->lmesh.nno*E->sphere.caps_per_proc);
Output_gzdir.c:533:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 7, E->parallel.world, &mpi_stat);
Output_gzdir.c:537:    for(j=1; j<= E->sphere.caps_per_proc;j++) /* print the temperatures */
Output_gzdir.c:538:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:539:	cvec[0] = E->T[j][i];
Output_gzdir.c:543:    if(E->output.gzdir.vtk_io == 2){
Output_gzdir.c:545:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:546:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 7, E->parallel.world);
Output_gzdir.c:548:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, 0, 6, E->parallel.world); /* tell m=0 to go ahead */
Output_gzdir.c:554:    if((E->output.gzdir.vtk_io == 3) || (E->parallel.me == 0)){
Output_gzdir.c:555:      if(E->output.gzdir.vtk_io == 2){
Output_gzdir.c:556:	mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, E->parallel.nproc-1 , 6, E->parallel.world, &mpi_stat);
Output_gzdir.c:561:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 5, E->parallel.world, &mpi_stat);
Output_gzdir.c:564:    for(k=0,j=1;j <= E->sphere.caps_per_proc;j++,k += os)     {
Output_gzdir.c:565:      if(E->output.gzdir.rnr){
Output_gzdir.c:567:	for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:568:	  vcorr[0] = E->sphere.cap[j].V[1][i]; /* vtheta */
Output_gzdir.c:569:	  vcorr[1] = E->sphere.cap[j].V[2][i]; /* vphi */
Output_gzdir.c:573:	  sub_netr(E->sx[j][3][i],E->sx[j][1][i],E->sx[j][2][i],(vcorr+0),(vcorr+1),omega);
Output_gzdir.c:575:	  convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],vcorr[0],vcorr[1],
Output_gzdir.c:576:			       (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:581:	for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:582:	  convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],E->sphere.cap[j].V[1][i],E->sphere.cap[j].V[2][i],
Output_gzdir.c:583:			       (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:589:    if(E->output.gzdir.vtk_io == 2){
Output_gzdir.c:590:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:591:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 5, E->parallel.world);
Output_gzdir.c:596:      if(E->parallel.me == 0)
Output_gzdir.c:615:    if(E->output.gzdir.vtk_io == 1) {
Output_gzdir.c:620:	       E->control.data_dir,
Output_gzdir.c:621:	       cycles,E->parallel.me,cycles);
Output_gzdir.c:624:	       E->control.data_dir,cycles,
Output_gzdir.c:625:	       E->parallel.me,cycles);
Output_gzdir.c:631:	     cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output_gzdir.c:632:    for(j=1; j<= E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:633:      gzprintf(gzout,"%3d %7d\n",j,E->lmesh.nno);
Output_gzdir.c:634:      if(E->output.gzdir.vtk_io){
Output_gzdir.c:636:	for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:637:	  gzprintf(gzout,"%.6e\n",E->T[j][i]);
Output_gzdir.c:640:	if(E->output.gzdir.rnr){
Output_gzdir.c:642:	  for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:643:	    vcorr[0] = E->sphere.cap[j].V[1][i]; /* vt */
Output_gzdir.c:644:	    vcorr[1] = E->sphere.cap[j].V[2][i]; /* vphi */
Output_gzdir.c:645:	    sub_netr(E->sx[j][3][i],E->sx[j][1][i],E->sx[j][2][i],(vcorr+0),(vcorr+1),omega);
Output_gzdir.c:648:		     E->sphere.cap[j].V[3][i],E->T[j][i]);
Output_gzdir.c:652:	  for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:654:		     E->sphere.cap[j].V[1][i],
Output_gzdir.c:655:		     E->sphere.cap[j].V[2][i],
Output_gzdir.c:656:		     E->sphere.cap[j].V[3][i],E->T[j][i]);
Output_gzdir.c:661:    if(E->output.gzdir.vtk_io){
Output_gzdir.c:666:	       E->control.data_dir,cycles,E->parallel.me,cycles);
Output_gzdir.c:668:      for(k=0,j=1;j <= E->sphere.caps_per_proc;j++,k += os)     {
Output_gzdir.c:669:	if(E->output.gzdir.rnr){
Output_gzdir.c:671:	  for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:672:	    vcorr[0] = E->sphere.cap[j].V[1][i];
Output_gzdir.c:673:	    vcorr[1] = E->sphere.cap[j].V[2][i];
Output_gzdir.c:674:	    sub_netr(E->sx[j][3][i],E->sx[j][1][i],E->sx[j][2][i],(vcorr+0),(vcorr+1),omega);
Output_gzdir.c:675:	    convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],vcorr[0],vcorr[1],
Output_gzdir.c:676:				 (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:681:	  for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:683:	    convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],
Output_gzdir.c:684:				 E->sphere.cap[j].V[1][i],
Output_gzdir.c:685:				 E->sphere.cap[j].V[2][i],
Output_gzdir.c:686:				 (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:697:  if(E->output.gzdir.vtk_io){	/* all VTK modes */
Output_gzdir.c:699:    if(!E->output.gzdir.vtk_base_save)
Output_gzdir.c:700:      free(E->output.gzdir.vtk_base);
Output_gzdir.c:714:  int lev = E->mesh.levmax;
Output_gzdir.c:722:  if(E->output.gzdir.vtk_io < 2){
Output_gzdir.c:724:	     "%s/%d/visc.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:725:	     cycles,E->parallel.me, cycles);
Output_gzdir.c:727:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:728:      gzprintf(gz1,"%3d %7d\n",j,E->lmesh.nno);
Output_gzdir.c:729:      for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:730:	gzprintf(gz1,"%.4e\n",E->VI[lev][j][i]);
Output_gzdir.c:735:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:739:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:745:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:749:    for(j=1; j<= E->sphere.caps_per_proc;j++)
Output_gzdir.c:750:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:751:	ftmp = log10(E->VI[lev][j][i]);
Output_gzdir.c:756:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:757:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:758:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:775:  int lev = E->mesh.levmax;
Output_gzdir.c:781:  if(E->viscosity.allow_anisotropic_viscosity){
Output_gzdir.c:783:    if(E->output.gzdir.vtk_io < 2){
Output_gzdir.c:785:	       "%s/%d/avisc.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:786:	       cycles,E->parallel.me, cycles);
Output_gzdir.c:788:      for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:789:	gzprintf(gz1,"%3d %7d\n",j,E->lmesh.nno);
Output_gzdir.c:790:	for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:791:	  gzprintf(gz1,"%.4e %.4e %.4e %.4e\n",E->VI2[lev][j][i],E->VIn1[lev][j][i],E->VIn2[lev][j][i],E->VIn3[lev][j][i]);
Output_gzdir.c:796:      if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:800:      if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:806:	mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:810:      for(j=1; j<= E->sphere.caps_per_proc;j++)
Output_gzdir.c:811:	for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:812:	  ftmp = E->VI2[lev][j][i];
Output_gzdir.c:817:      if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:818:	if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:819:	  mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:835:  if((E->output.write_q_files == 0) || (cycles == 0) ||
Output_gzdir.c:836:     (cycles % E->output.write_q_files)!=0)
Output_gzdir.c:840:  if(E->control.use_cbf_topo){
Output_gzdir.c:841:    get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);
Output_gzdir.c:843:    get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,cycles);
Output_gzdir.c:847:  if (E->output.surf && (E->parallel.me_loc[3]==E->parallel.nprocz-1)) {
Output_gzdir.c:848:    snprintf(output_file,255,"%s/%d/surf.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:849:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:852:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Output_gzdir.c:854:        if(E->control.pseudo_free_surf)
Output_gzdir.c:855:            topo = E->slice.freesurf[j];
Output_gzdir.c:857:            topo = E->slice.tpg[j];
Output_gzdir.c:859:        gzprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Output_gzdir.c:860:        for(i=1;i<=E->lmesh.nsf;i++)   {
Output_gzdir.c:861:            s = i*E->lmesh.noz;
Output_gzdir.c:863:		     topo[i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Output_gzdir.c:870:  if (E->output.botm && (E->parallel.me_loc[3]==0)) {
Output_gzdir.c:871:    snprintf(output_file,255,"%s/%d/botm.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:872:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:875:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Output_gzdir.c:876:      gzprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Output_gzdir.c:877:      for(i=1;i<=E->lmesh.nsf;i++)  {
Output_gzdir.c:878:        s = (i-1)*E->lmesh.noz + 1;
Output_gzdir.c:880:		 E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Output_gzdir.c:899:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Output_gzdir.c:901:		 "%s/%d/geoid.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:902:		cycles,E->parallel.me, cycles);
Output_gzdir.c:906:        gzprintf(fp1, "%d %d %.5e\n", cycles, E->output.llmax,
Output_gzdir.c:907:                E->monitor.elapsed_time);
Output_gzdir.c:910:        for (ll=0; ll<=E->output.llmax; ll++)
Output_gzdir.c:912:                p = E->sphere.hindex[ll][mm];
Output_gzdir.c:915:                        E->sphere.harm_geoid[0][p],
Output_gzdir.c:916:                        E->sphere.harm_geoid[1][p],
Output_gzdir.c:917:                        E->sphere.harm_geoid_from_tpgt[0][p],
Output_gzdir.c:918:                        E->sphere.harm_geoid_from_tpgt[1][p],
Output_gzdir.c:919:                        E->sphere.harm_geoid_from_bncy[0][p],
Output_gzdir.c:920:                        E->sphere.harm_geoid_from_bncy[1][p]);
Output_gzdir.c:942:  if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Output_gzdir.c:948:  snprintf(output_file,255,"%s/%d/stress.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:949:	  cycles,E->parallel.me, cycles);
Output_gzdir.c:952:  gzprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output_gzdir.c:954:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Output_gzdir.c:955:    gzprintf(fp1,"%3d %7d\n",m,E->lmesh.nno);
Output_gzdir.c:956:    for (node=1;node<=E->lmesh.nno;node++)
Output_gzdir.c:958:              E->gstress[m][(node-1)*6+1], /*  stt */
Output_gzdir.c:959:              E->gstress[m][(node-1)*6+2], /*  spp */
Output_gzdir.c:960:              E->gstress[m][(node-1)*6+3], /*  srr */
Output_gzdir.c:961:              E->gstress[m][(node-1)*6+4], /*  stp */
Output_gzdir.c:962:              E->gstress[m][(node-1)*6+5], /*  str */
Output_gzdir.c:963:              E->gstress[m][(node-1)*6+6]); /* srp */
Output_gzdir.c:983:  if (E->parallel.me<E->parallel.nprocz)  {
Output_gzdir.c:984:    snprintf(output_file,255,"%s/%d/horiz_avg.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:985:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:987:    for(j=1;j<=E->lmesh.noz;j++)  { /* format: r <T> <vh> <vr> (<C>) */
Output_gzdir.c:988:        gzprintf(fp1,"%.4e %.4e %.4e %.4e",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]);
Output_gzdir.c:990:        if (E->composition.on) {
Output_gzdir.c:992:            for(n=0; n<E->composition.ncomp; n++)
Output_gzdir.c:993:                gzprintf(fp1," %.4e", E->Have.C[n][j]);
Output_gzdir.c:1011:  snprintf(output_file,255,"%s/mat.%d.gz", E->control.data_dir,E->parallel.me);
Output_gzdir.c:1014:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Output_gzdir.c:1015:    for(el=1;el<=E->lmesh.nel;el++)
Output_gzdir.c:1016:      gzprintf(fp,"%d %d %f\n", el,E->mat[m][el],E->VIP[m][el]);
Output_gzdir.c:1037:  if(E->output.gzdir.vtk_io < 2){ /* old */
Output_gzdir.c:1038:    snprintf(output_file,255,"%s/%d/pressure.%d.%d.gz", E->control.data_dir,cycles,
Output_gzdir.c:1039:	     E->parallel.me, cycles);
Output_gzdir.c:1041:    gzprintf(gz1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output_gzdir.c:1042:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:1043:      gzprintf(gz1,"%3d %7d\n",j,E->lmesh.nno);
Output_gzdir.c:1044:      for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:1045:	gzprintf(gz1,"%.6e\n",E->NP[j][i]);
Output_gzdir.c:1049:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:1052:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:1057:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:1060:    for(j=1; j<= E->sphere.caps_per_proc;j++)
Output_gzdir.c:1061:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:1062:	ftmp = E->NP[j][i];
Output_gzdir.c:1066:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:1067:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:1068:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:1083:	   E->control.data_dir,cycles,
Output_gzdir.c:1084:	   E->parallel.me, cycles);
Output_gzdir.c:1087:  ncolumns = 3 + E->trace.number_of_extra_quantities;
Output_gzdir.c:1089:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:1090:      gzprintf(fp1,"%d %d %d %.5e\n", cycles, E->trace.ntracers[j],
Output_gzdir.c:1091:              ncolumns, E->monitor.elapsed_time);
Output_gzdir.c:1093:      for(n=1;n<=E->trace.ntracers[j];n++) {
Output_gzdir.c:1096:                  E->trace.basicq[j][0][n],
Output_gzdir.c:1097:                  E->trace.basicq[j][1][n],
Output_gzdir.c:1098:                  E->trace.basicq[j][2][n]);
Output_gzdir.c:1101:          for (i=0; i<E->trace.number_of_extra_quantities; i++) {
Output_gzdir.c:1102:              gzprintf(fp1," %9.5e", E->trace.extraq[j][i][n]);
Output_gzdir.c:1126:  if(E->output.gzdir.vtk_io < 2){
Output_gzdir.c:1128:	     E->control.data_dir,cycles,
Output_gzdir.c:1129:	     E->parallel.me, cycles);
Output_gzdir.c:1131:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:1133:	       j, E->lmesh.nel,
Output_gzdir.c:1134:	       E->monitor.elapsed_time,
Output_gzdir.c:1135:	       E->composition.initial_bulk_composition,
Output_gzdir.c:1136:	       E->composition.bulk_composition);
Output_gzdir.c:1137:      for(i=1;i<=E->lmesh.nno;i++) {
Output_gzdir.c:1138:	for(k=0;k < E->composition.ncomp;k++)
Output_gzdir.c:1139:	  gzprintf(gz1,"%.6e ",E->composition.comp_node[j][k][i]);
Output_gzdir.c:1145:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:1148:    if((E->output.gzdir.vtk_io==3) || (E->parallel.me == 0)){
Output_gzdir.c:1150:      if(E->composition.ncomp > 4)
Output_gzdir.c:1152:      sprintf(message,"SCALARS composition float %d\n",E->composition.ncomp);
Output_gzdir.c:1156:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:1159:    for(j=1; j<= E->sphere.caps_per_proc;j++)
Output_gzdir.c:1160:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:1161:	for(k=0;k<E->composition.ncomp;k++){
Output_gzdir.c:1162:	  ftmp = E->composition.comp_node[j][k][i];
Output_gzdir.c:1167:    if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:1168:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:1169:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:1182:    snprintf(output_file,255,"%s/%d/comp_el.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:1183:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:1186:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:1188:                j, E->lmesh.nel,
Output_gzdir.c:1189:                E->monitor.elapsed_time,
Output_gzdir.c:1190:                E->composition.initial_bulk_composition,
Output_gzdir.c:1191:                E->composition.bulk_composition);
Output_gzdir.c:1193:        for(i=1;i<=E->lmesh.nel;i++) {
Output_gzdir.c:1194:	  for(k=0;k<E->composition.ncomp;k++)
Output_gzdir.c:1195:            gzprintf(fp1,"%.6e ",E->composition.comp_el[j][k][i]);
Output_gzdir.c:1211:    snprintf(output_file,255,"%s/%d/heating.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:1212:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:1215:    gzprintf(fp1,"%.5e\n",E->monitor.elapsed_time);
Output_gzdir.c:1217:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:1218:        gzprintf(fp1,"%3d %7d\n", j, E->lmesh.nel);
Output_gzdir.c:1219:        for(e=1; e<=E->lmesh.nel; e++)
Output_gzdir.c:1220:            gzprintf(fp1, "%.4e %.4e %.4e\n", E->heating_adi[j][e],
Output_gzdir.c:1221:                      E->heating_visc[j][e], E->heating_latent[j][e]);
Output_gzdir.c:1244:  ii = E->monitor.solution_cycles_init;
Output_gzdir.c:1245:  switch(E->output.gzdir.vtk_io){
Output_gzdir.c:1253:	     E->control.data_dir_old,
Output_gzdir.c:1254:	     ii,E->parallel.me,ii);
Output_gzdir.c:1258:	     E->control.data_dir_old,ii,
Output_gzdir.c:1259:	     E->parallel.me,ii);
Output_gzdir.c:1264:  if (E->parallel.me==0){
Output_gzdir.c:1267:    fprintf(E->fp,"restart_tic_from_gzdir_file: using  %s for restarted temperature\n",
Output_gzdir.c:1272:  if(mm != E->lmesh.nno){
Output_gzdir.c:1273:    fprintf(stderr,"%i %i\n",mm, E->lmesh.nno);
Output_gzdir.c:1277:  switch(E->output.gzdir.vtk_io) {
Output_gzdir.c:1279:    for(m=1;m <= E->sphere.caps_per_proc;m++) {
Output_gzdir.c:1282:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:1289:	E->T[m][i] = g;
Output_gzdir.c:1294:    for(m=1;m <= E->sphere.caps_per_proc;m++) {
Output_gzdir.c:1296:      for(i=1;i<=E->lmesh.nno;i++)  {
Output_gzdir.c:1299:	/*  E->sphere.cap[m].V[1][i] = v1;
Output_gzdir.c:1300:	    E->sphere.cap[m].V[1][i] = v2;
Output_gzdir.c:1301:	    E->sphere.cap[m].V[1][i] = v3;  */
Output_gzdir.c:1303:	//E->T[m][i] = max(0.0,min(g,1.0));
Output_gzdir.c:1304:	E->T[m][i] = g;
Output_gzdir.c:1383:  if(E->output.gzdir.vtk_io == 2){ /* serial */
Output_gzdir.c:1386:	       E->control.data_dir);
Output_gzdir.c:1389:	       E->control.data_dir, E->output.gzdir.vtk_ocount);
Output_gzdir.c:1393:	       E->control.data_dir,E->parallel.me);
Output_gzdir.c:1396:	       E->control.data_dir,cycles,
Output_gzdir.c:1397:	       E->output.gzdir.vtk_ocount,
Output_gzdir.c:1398:	       E->parallel.me);
Output_h5.c:163:    int nprocx = E->parallel.nprocx;
Output_h5.c:164:    int nprocy = E->parallel.nprocy;
Output_h5.c:165:    int nprocz = E->parallel.nprocz;
Output_h5.c:168:    E->hdf5.cap = (E->parallel.me) / (nprocx * nprocy * nprocz);
Output_h5.c:191:    if (E->output.stress == 1)
Output_h5.c:192:        E->hdf5.data = (float *)malloc((tensor3d->n) * sizeof(float));
Output_h5.c:194:        E->hdf5.data = (float *)malloc((vector3d->n) * sizeof(float));
Output_h5.c:197:    tensor3d->data = E->hdf5.data;
Output_h5.c:198:    vector3d->data = E->hdf5.data;
Output_h5.c:199:    vector2d->data = E->hdf5.data;
Output_h5.c:200:    scalar3d->data = E->hdf5.data;
Output_h5.c:201:    scalar2d->data = E->hdf5.data;
Output_h5.c:202:    scalar1d->data = E->hdf5.data;
Output_h5.c:204:    E->hdf5.tensor3d = tensor3d;
Output_h5.c:205:    E->hdf5.vector3d = vector3d;
Output_h5.c:206:    E->hdf5.vector2d = vector2d;
Output_h5.c:207:    E->hdf5.scalar3d = scalar3d;
Output_h5.c:208:    E->hdf5.scalar2d = scalar2d;
Output_h5.c:209:    E->hdf5.scalar1d = scalar1d;
Output_h5.c:218: * These represent possible choices for (E->output) function pointer.       *
Output_h5.c:224:    if(E->parallel.me == 0)
Output_h5.c:233:        if (E->output.coord_bin)
Output_h5.c:249:    int m = E->parallel.me;
Output_h5.c:253:    input_int("cb_block_size", &(E->output.cb_block_size), "1048576", m);
Output_h5.c:254:    input_int("cb_buffer_size", &(E->output.cb_buffer_size), "4194304", m);
Output_h5.c:256:    input_int("sieve_buf_size", &(E->output.sieve_buf_size), "1048576", m);
Output_h5.c:258:    input_int("output_alignment", &(E->output.alignment), "262144", m);
Output_h5.c:259:    input_int("output_alignment_threshold", &(E->output.alignment_threshold), "524288", m);
Output_h5.c:261:    input_int("cache_mdc_nelmts", &(E->output.cache_mdc_nelmts), "10330", m);
Output_h5.c:262:    input_int("cache_rdcc_nelmts", &(E->output.cache_rdcc_nelmts), "521", m);
Output_h5.c:263:    input_int("cache_rdcc_nbytes", &(E->output.cache_rdcc_nbytes), "1048576", m);
Output_h5.c:276:    snprintf(filename, (size_t)100, "%s.h5", E->control.data_file);
Output_h5.c:294:             E->control.data_file, cycles);
Output_h5.c:306:    if(E->control.tracer == 1)
Output_h5.c:310:    if(E->output.geoid == 1)
Output_h5.c:313:    if(E->output.stress == 1){
Output_h5.c:316:    if(E->output.pressure == 1)
Output_h5.c:319:    if (E->output.horiz_avg == 1)
Output_h5.c:340:    MPI_Comm comm = E->parallel.world;
Output_h5.c:372:    snprintf(tmp, (size_t)100, "%d", E->output.cb_block_size);
Output_h5.c:374:    snprintf(tmp, (size_t)100, "%d", E->output.cb_buffer_size);
Output_h5.c:380:    status = H5Pset_sieve_buf_size(fapl_id, (size_t)(E->output.sieve_buf_size));
Output_h5.c:381:    status = H5Pset_alignment(fapl_id, (hsize_t)(E->output.alignment_threshold),
Output_h5.c:382:                                       (hsize_t)(E->output.alignment));
Output_h5.c:383:    status = H5Pset_cache(fapl_id, E->output.cache_mdc_nelmts,
Output_h5.c:384:                                   (size_t)(E->output.cache_rdcc_nelmts),
Output_h5.c:385:                                   (size_t)(E->output.cache_rdcc_nbytes),
Output_h5.c:399:    E->hdf5.file_id = file_id;
Output_h5.c:411:    status = H5Fclose(E->hdf5.file_id);
Output_h5.c:435:    field = E->hdf5.vector3d;
Output_h5.c:437:    nx = E->lmesh.nox;
Output_h5.c:438:    ny = E->lmesh.noy;
Output_h5.c:439:    nz = E->lmesh.noz;
Output_h5.c:454:                field->data[3*m+0] = E->sx[1][1][n+1];
Output_h5.c:455:                field->data[3*m+1] = E->sx[1][2][n+1];
Output_h5.c:456:                field->data[3*m+2] = E->sx[1][3][n+1];
Output_h5.c:461:    h5create_field(E->hdf5.file_id, field, "coord", "coordinates of nodes");
Output_h5.c:464:    dataset = H5Dopen(E->hdf5.file_id, "/coord");
Output_h5.c:481:    field = E->hdf5.vector3d;
Output_h5.c:483:    nx = E->lmesh.nox;
Output_h5.c:484:    ny = E->lmesh.noy;
Output_h5.c:485:    nz = E->lmesh.noz;
Output_h5.c:500:                field->data[3*m+0] = E->sphere.cap[1].V[1][n+1];
Output_h5.c:501:                field->data[3*m+1] = E->sphere.cap[1].V[2][n+1];
Output_h5.c:502:                field->data[3*m+2] = E->sphere.cap[1].V[3][n+1];
Output_h5.c:507:    h5create_field(E->hdf5.file_id, field, "velocity", "velocity values on nodes");
Output_h5.c:510:    dataset = H5Dopen(E->hdf5.file_id, "/velocity");
Output_h5.c:527:    field = E->hdf5.scalar3d;
Output_h5.c:529:    nx = E->lmesh.nox;
Output_h5.c:530:    ny = E->lmesh.noy;
Output_h5.c:531:    nz = E->lmesh.noz;
Output_h5.c:546:                field->data[m] = E->T[1][n+1];
Output_h5.c:551:    h5create_field(E->hdf5.file_id, field, "temperature", "temperature values on nodes");
Output_h5.c:553:    dataset = H5Dopen(E->hdf5.file_id, "/temperature");
Output_h5.c:571:    field = E->hdf5.scalar3d;
Output_h5.c:573:    lev = E->mesh.levmax;
Output_h5.c:575:    nx = E->lmesh.nox;
Output_h5.c:576:    ny = E->lmesh.noy;
Output_h5.c:577:    nz = E->lmesh.noz;
Output_h5.c:592:                field->data[m] = E->VI[lev][1][n+1];
Output_h5.c:597:    h5create_field(E->hdf5.file_id, field, "viscosity", "viscosity values on nodes");
Output_h5.c:599:    dataset = H5Dopen(E->hdf5.file_id, "/viscosity");
Output_h5.c:616:    field = E->hdf5.scalar3d;
Output_h5.c:618:    nx = E->lmesh.nox;
Output_h5.c:619:    ny = E->lmesh.noy;
Output_h5.c:620:    nz = E->lmesh.noz;
Output_h5.c:635:                field->data[m] = E->NP[1][n+1];
Output_h5.c:641:    h5create_field(E->hdf5.file_id, field, "pressure", "pressure values on nodes");
Output_h5.c:644:    dataset = H5Dopen(E->hdf5.file_id, "/pressure");
Output_h5.c:668:    if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Output_h5.c:674:    field = E->hdf5.tensor3d;
Output_h5.c:676:    nx = E->lmesh.nox;
Output_h5.c:677:    ny = E->lmesh.noy;
Output_h5.c:678:    nz = E->lmesh.noz;
Output_h5.c:693:                field->data[6*m+0] = E->gstress[1][6*n+1];
Output_h5.c:694:                field->data[6*m+1] = E->gstress[1][6*n+2];
Output_h5.c:695:                field->data[6*m+2] = E->gstress[1][6*n+3];
Output_h5.c:696:                field->data[6*m+3] = E->gstress[1][6*n+4];
Output_h5.c:697:                field->data[6*m+4] = E->gstress[1][6*n+5];
Output_h5.c:698:                field->data[6*m+5] = E->gstress[1][6*n+6];
Output_h5.c:704:    h5create_field(E->hdf5.file_id, field, "stress", "stress values on nodes");
Output_h5.c:707:    dataset = H5Dopen(E->hdf5.file_id, "/stress");
Output_h5.c:736:    int pz = E->parallel.me_loc[3];
Output_h5.c:737:    int nprocz = E->parallel.nprocz;
Output_h5.c:739:    field = E->hdf5.vector2d;
Output_h5.c:741:    nx = E->lmesh.nox;
Output_h5.c:742:    ny = E->lmesh.noy;
Output_h5.c:743:    nz = E->lmesh.noz;
Output_h5.c:748:    if (E->output.surf == 1)
Output_h5.c:757:                field->data[2*m+0] = E->sx[1][1][n+1];
Output_h5.c:758:                field->data[2*m+1] = E->sx[1][2][n+1];
Output_h5.c:761:        dataset = H5Dopen(E->hdf5.file_id, "/surf/coord");
Output_h5.c:766:    if (E->output.botm == 1)
Output_h5.c:775:                field->data[2*m+0] = E->sx[1][1][n+1];
Output_h5.c:776:                field->data[2*m+1] = E->sx[1][2][n+1];
Output_h5.c:779:        dataset = H5Dopen(E->hdf5.file_id, "/botm/coord");
Output_h5.c:801:    int pz = E->parallel.me_loc[3];
Output_h5.c:802:    int nprocz = E->parallel.nprocz;
Output_h5.c:804:    file_id = E->hdf5.file_id;
Output_h5.c:806:    scalar = E->hdf5.scalar2d;
Output_h5.c:807:    vector = E->hdf5.vector2d;
Output_h5.c:809:    nx = E->lmesh.nox;
Output_h5.c:810:    ny = E->lmesh.noy;
Output_h5.c:811:    nz = E->lmesh.noz;
Output_h5.c:816:    if((E->output.write_q_files == 0) || (cycles == 0) ||
Output_h5.c:817:       (cycles % E->output.write_q_files)!=0)
Output_h5.c:823:    if(E->control.use_cbf_topo){
Output_h5.c:824:      get_CBF_topo(E, E->slice.tpg, E->slice.tpgb);
Output_h5.c:826:      get_STD_topo(E, E->slice.tpg, E->slice.tpgb, E->slice.divg, E->slice.vort, cycles);
Output_h5.c:832:    if (E->output.surf == 1)
Output_h5.c:836:        h5create_field(surf_group, E->hdf5.vector2d, "velocity",
Output_h5.c:838:        h5create_field(surf_group, E->hdf5.scalar2d, "heatflux",
Output_h5.c:840:        h5create_field(surf_group, E->hdf5.scalar2d, "topography",
Output_h5.c:854:                vector->data[2*m+0] = E->sphere.cap[1].V[1][n+1];
Output_h5.c:855:                vector->data[2*m+1] = E->sphere.cap[1].V[2][n+1];
Output_h5.c:869:                scalar->data[m] = E->slice.shflux[1][n+1];
Output_h5.c:878:        if (E->control.pseudo_free_surf)
Output_h5.c:879:            topo = E->slice.freesurf[1];
Output_h5.c:881:            topo = E->slice.tpg[1];
Output_h5.c:902:    if (E->output.botm == 1)
Output_h5.c:906:        h5create_field(botm_group, E->hdf5.vector2d, "velocity",
Output_h5.c:908:        h5create_field(botm_group, E->hdf5.scalar2d, "heatflux",
Output_h5.c:910:        h5create_field(botm_group, E->hdf5.scalar2d, "topography",
Output_h5.c:924:                vector->data[2*m+0] = E->sphere.cap[1].V[1][n+1];
Output_h5.c:925:                vector->data[2*m+1] = E->sphere.cap[1].V[2][n+1];
Output_h5.c:939:                scalar->data[m] = E->slice.bhflux[1][n+1];
Output_h5.c:947:        topo = E->slice.tpg[1];
Output_h5.c:979:    int px = E->parallel.me_loc[1];
Output_h5.c:980:    int py = E->parallel.me_loc[2];
Output_h5.c:982:    field = E->hdf5.scalar1d;
Output_h5.c:986:    if (E->output.horiz_avg == 1)
Output_h5.c:989:            field->data[k] = E->sx[1][3][k+1];
Output_h5.c:990:        dataset = H5Dopen(E->hdf5.file_id, "/horiz_avg/coord");
Output_h5.c:1012:    int px = E->parallel.me_loc[1];
Output_h5.c:1013:    int py = E->parallel.me_loc[2];
Output_h5.c:1016:    file_id = E->hdf5.file_id;
Output_h5.c:1018:    field = E->hdf5.scalar1d;
Output_h5.c:1027:    h5create_field(avg_group, E->hdf5.scalar1d, "temperature",
Output_h5.c:1029:    h5create_field(avg_group, E->hdf5.scalar1d, "velocity_xy",
Output_h5.c:1031:    h5create_field(avg_group, E->hdf5.scalar1d, "velocity_z",
Output_h5.c:1041:        field->data[k] = E->Have.T[k+1];
Output_h5.c:1048:        field->data[k] = E->Have.V[1][k+1];
Output_h5.c:1055:        field->data[k] = E->Have.V[2][k+1];
Output_h5.c:1087:    hsize_t dim = E->sphere.hindice;
Output_h5.c:1119:    dataset = H5Dcreate(E->hdf5.file_id, "geoid", datatype,
Output_h5.c:1157:    if (E->parallel.me == 0) {
Output_h5.c:1159:        row = (struct HDF5_GEOID *) malloc((E->sphere.hindice)
Output_h5.c:1162:        for(ll = 0; ll <= E->output.llmax; ll++)
Output_h5.c:1166:                row[i].total_sin = E->sphere.harm_geoid[0][i];
Output_h5.c:1167:                row[i].total_cos = E->sphere.harm_geoid[1][i];
Output_h5.c:1168:                row[i].tpgt_sin = E->sphere.harm_geoid_from_tpgt[0][i];
Output_h5.c:1169:                row[i].tpgt_cos = E->sphere.harm_geoid_from_tpgt[1][i];
Output_h5.c:1170:                row[i].bncy_sin = E->sphere.harm_geoid_from_bncy[0][i];
Output_h5.c:1171:                row[i].bncy_cos = E->sphere.harm_geoid_from_bncy[1][i];
Output_h5.c:1237:    int px = E->parallel.me_loc[1];
Output_h5.c:1238:    int py = E->parallel.me_loc[2];
Output_h5.c:1239:    int pz = E->parallel.me_loc[3];
Output_h5.c:1240:    int nprocx = E->parallel.nprocx;
Output_h5.c:1241:    int nprocy = E->parallel.nprocy;
Output_h5.c:1242:    int nprocz = E->parallel.nprocz;
Output_h5.c:1246:    int nel = E->lmesh.nel;
Output_h5.c:1251:    if (E->output.connectivity == 1)
Output_h5.c:1277:            ien = E->ien[1][e+1].node;
Output_h5.c:1289:        h5create_connectivity(E->hdf5.file_id, E->lmesh.nel * procs_per_cap);
Output_h5.c:1291:        dataset = H5Dopen(E->hdf5.file_id, "/connectivity");
Output_h5.c:1295:                                 0, (E->hdf5.cap == 0));
Output_h5.c:1314:    root = H5Gopen(E->hdf5.file_id, "/");
Output_h5.c:1315:    status = set_attribute_float(root, "time", E->monitor.elapsed_time);
Output_h5.c:1337:    input = h5create_group(E->hdf5.file_id, "input", (size_t)0);
Output_h5.c:1339:    status = set_attribute_int(input, "PID", E->control.PID);
Output_h5.c:1345:    status = set_attribute_int(input, "ADV", E->advection.ADVECTION);
Output_h5.c:1346:    status = set_attribute_int(input, "filter_temp", E->advection.filter_temperature);
Output_h5.c:1348:    status = set_attribute_float(input, "finetunedt", E->advection.fine_tune_dt);
Output_h5.c:1349:    status = set_attribute_float(input, "fixed_timestep", E->advection.fixed_timestep);
Output_h5.c:1350:    status = set_attribute_float(input, "inputdiffusivity", E->control.inputdiff);
Output_h5.c:1352:    status = set_attribute_int(input, "adv_sub_iterations", E->advection.temp_iterations);
Output_h5.c:1359:    status = set_attribute_int(input, "side_sbcs", E->control.side_sbcs);
Output_h5.c:1360:    status = set_attribute_int(input, "pseudo_free_surf", E->control.pseudo_free_surf);
Output_h5.c:1362:    status = set_attribute_int(input, "topvbc", E->mesh.topvbc);
Output_h5.c:1363:    status = set_attribute_float(input, "topvbxval", E->control.VBXtopval);
Output_h5.c:1364:    status = set_attribute_float(input, "topvbyval", E->control.VBYtopval);
Output_h5.c:1367:    status = set_attribute_int(input, "botvbc", E->mesh.botvbc);
Output_h5.c:1368:    status = set_attribute_float(input, "botvbxval", E->control.VBXbotval);
Output_h5.c:1369:    status = set_attribute_float(input, "botvbyval", E->control.VBYbotval);
Output_h5.c:1371:    status = set_attribute_int(input, "toptbc", E->mesh.toptbc);
Output_h5.c:1372:    status = set_attribute_float(input, "toptbcval", E->control.TBCtopval);
Output_h5.c:1374:    status = set_attribute_int(input, "bottbc", E->mesh.bottbc);
Output_h5.c:1375:    status = set_attribute_float(input, "bottbcval", E->control.TBCbotval);
Output_h5.c:1377:    status = set_attribute_int(input, "temperature_bound_adj", E->control.temperature_bound_adj);
Output_h5.c:1378:    status = set_attribute_float(input, "depth_bound_adj", E->control.depth_bound_adj);
Output_h5.c:1379:    status = set_attribute_float(input, "width_bound_adj", E->control.width_bound_adj);
Output_h5.c:1385:    status = set_attribute_float(input, "density", E->data.density);
Output_h5.c:1386:    status = set_attribute_float(input, "thermdiff", E->data.therm_diff);
Output_h5.c:1387:    status = set_attribute_float(input, "gravacc", E->data.grav_acc);
Output_h5.c:1388:    status = set_attribute_float(input, "thermexp", E->data.therm_exp);
Output_h5.c:1389:    status = set_attribute_float(input, "refvisc", E->data.ref_viscosity);
Output_h5.c:1390:    status = set_attribute_float(input, "cp", E->data.Cp);
Output_h5.c:1391:    status = set_attribute_float(input, "density_above", E->data.density_above);
Output_h5.c:1392:    status = set_attribute_float(input, "density_below", E->data.density_below);
Output_h5.c:1394:    status = set_attribute_float(input, "z_lith", E->viscosity.zlith);
Output_h5.c:1395:    status = set_attribute_float(input, "z_410", E->viscosity.z410);
Output_h5.c:1396:    status = set_attribute_float(input, "z_lmantle", E->viscosity.zlm);
Output_h5.c:1397:    status = set_attribute_float(input, "z_cmb", E->viscosity.zcmb);
Output_h5.c:1399:    status = set_attribute_float(input, "radius_km", E->data.radius_km);
Output_h5.c:1400:    status = set_attribute_float(input, "scalev", E->data.scalev);
Output_h5.c:1401:    status = set_attribute_float(input, "scalet", E->data.scalet);
Output_h5.c:1407:    status = set_attribute_int(input, "restart", E->control.restart);
Output_h5.c:1408:    status = set_attribute_int(input, "post_p", E->control.post_p);
Output_h5.c:1409:    status = set_attribute_int(input, "solution_cycles_init", E->monitor.solution_cycles_init);
Output_h5.c:1410:    status = set_attribute_int(input, "zero_elapsed_time", E->control.zero_elapsed_time);
Output_h5.c:1412:    status = set_attribute_int(input, "tic_method", E->convection.tic_method);
Output_h5.c:1414:    n = E->convection.number_of_perturbations;
Output_h5.c:1416:    status = set_attribute_int_vector(input, "perturbl", n, E->convection.perturb_ll);
Output_h5.c:1417:    status = set_attribute_int_vector(input, "perturbm", n, E->convection.perturb_mm);
Output_h5.c:1418:    status = set_attribute_int_vector(input, "perturblayer", n, E->convection.load_depth);
Output_h5.c:1419:    status = set_attribute_float_vector(input, "perturbmag", n, E->convection.perturb_mag);
Output_h5.c:1421:    status = set_attribute_float(input, "half_space_age", E->convection.half_space_age);
Output_h5.c:1422:    status = set_attribute_float(input, "mantle_temp", E->control.mantle_temp);
Output_h5.c:1424:    if (E->convection.tic_method == 2)
Output_h5.c:1426:        status = set_attribute_float_vector(input, "blob_center", 3, E->convection.blob_center);
Output_h5.c:1427:        status = set_attribute_float(input, "blob_radius", E->convection.blob_radius);
Output_h5.c:1428:        status = set_attribute_float(input, "blob_dT", E->convection.blob_dT);
Output_h5.c:1435:    status = set_attribute_int(input, "file_vbcs", E->control.vbcs_file);
Output_h5.c:1436:    status = set_attribute_string(input, "vel_bound_file", E->control.velocity_boundary_file);
Output_h5.c:1438:    status = set_attribute_int(input, "file_tbcs", E->control.tbcs_file);
Output_h5.c:1439:    status = set_attribute_string(input, "temp_bound_file", E->control.temperature_boundary_file);
Output_h5.c:1441:    status = set_attribute_int(input, "mat_control", E->control.mat_control);
Output_h5.c:1442:    status = set_attribute_string(input, "mat_file", E->control.mat_file);
Output_h5.c:1444:    status = set_attribute_int(input, "lith_age", E->control.lith_age);
Output_h5.c:1445:    status = set_attribute_string(input, "lith_age_file", E->control.lith_age_file);
Output_h5.c:1446:    status = set_attribute_int(input, "lith_age_time", E->control.lith_age_time);
Output_h5.c:1447:    status = set_attribute_float(input, "lith_age_depth", E->control.lith_age_depth);
Output_h5.c:1449:    status = set_attribute_float(input, "start_age", E->control.start_age);
Output_h5.c:1450:    status = set_attribute_int(input, "reset_startage", E->control.reset_startage);
Output_h5.c:1456:    status = set_attribute_float(input, "Ra_410", E->control.Ra_410);
Output_h5.c:1457:    status = set_attribute_float(input, "clapeyron410", E->control.clapeyron410);
Output_h5.c:1458:    status = set_attribute_float(input, "transT410", E->control.transT410);
Output_h5.c:1460:                                 (E->control.inv_width410 == 0)?
Output_h5.c:1461:                                 E->control.inv_width410 :
Output_h5.c:1462:				 1.0/E->control.inv_width410);
Output_h5.c:1464:    status = set_attribute_float(input, "Ra_670", E->control.Ra_670);
Output_h5.c:1465:    status = set_attribute_float(input, "clapeyron670", E->control.clapeyron670);
Output_h5.c:1466:    status = set_attribute_float(input, "transT670", E->control.transT670);
Output_h5.c:1468:                                 (E->control.inv_width670 == 0)?
Output_h5.c:1469:                                 E->control.inv_width670 :
Output_h5.c:1470:				 1.0/E->control.inv_width670);
Output_h5.c:1472:    status = set_attribute_float(input, "Ra_cmb", E->control.Ra_cmb);
Output_h5.c:1473:    status = set_attribute_float(input, "clapeyroncmb", E->control.clapeyroncmb);
Output_h5.c:1474:    status = set_attribute_float(input, "transTcmb", E->control.transTcmb);
Output_h5.c:1476:                                 (E->control.inv_widthcmb == 0)?
Output_h5.c:1477:                                 E->control.inv_widthcmb :
Output_h5.c:1478:				 1.0/E->control.inv_widthcmb);
Output_h5.c:1484:    status = set_attribute_string(input, "datadir", E->control.data_dir);
Output_h5.c:1485:    status = set_attribute_string(input, "datafile", E->control.data_file);
Output_h5.c:1486:    status = set_attribute_string(input, "datadir_old", E->control.data_dir_old);
Output_h5.c:1487:    status = set_attribute_string(input, "datafile_old", E->control.old_P_file);
Output_h5.c:1489:    status = set_attribute_float(input, "rayleigh", E->control.Atemp);
Output_h5.c:1490:    status = set_attribute_float(input, "dissipation_number", E->control.disptn_number);
Output_h5.c:1492:                                 (E->control.inv_gruneisen == 0)?
Output_h5.c:1493:                                  1.0/E->control.inv_gruneisen :
Output_h5.c:1494:				 E->control.inv_gruneisen);
Output_h5.c:1495:    status = set_attribute_float(input, "surfaceT", E->control.surface_temp);
Output_h5.c:1496:    status = set_attribute_float(input, "Q0", E->control.Q0);
Output_h5.c:1498:    status = set_attribute_int(input, "stokes_flow_only", E->control.stokes);
Output_h5.c:1500:    status = set_attribute_string(input, "output_format", E->output.format);
Output_h5.c:1501:    status = set_attribute_string(input, "output_optional", E->output.optional);
Output_h5.c:1502:    status = set_attribute_int(input, "output_ll_max", E->output.llmax);
Output_h5.c:1504:    status = set_attribute_int(input, "verbose", E->control.verbose);
Output_h5.c:1505:    status = set_attribute_int(input, "see_convergence", E->control.print_convergence);
Output_h5.c:1511:    status = set_attribute_int(input, "nproc_surf", E->parallel.nprocxy);
Output_h5.c:1513:    status = set_attribute_int(input, "nprocx", E->parallel.nprocx);
Output_h5.c:1514:    status = set_attribute_int(input, "nprocy", E->parallel.nprocy);
Output_h5.c:1515:    status = set_attribute_int(input, "nprocz", E->parallel.nprocz);
Output_h5.c:1517:    status = set_attribute_int(input, "coor", E->control.coor);
Output_h5.c:1518:    status = set_attribute_string(input, "coor_file", E->control.coor_file);
Output_h5.c:1520:    status = set_attribute_int(input, "nodex", E->mesh.nox);
Output_h5.c:1521:    status = set_attribute_int(input, "nodey", E->mesh.noy);
Output_h5.c:1522:    status = set_attribute_int(input, "nodez", E->mesh.noz);
Output_h5.c:1524:    status = set_attribute_int(input, "levels", E->mesh.levels);
Output_h5.c:1525:    status = set_attribute_int(input, "mgunitx", E->mesh.mgunitx);
Output_h5.c:1526:    status = set_attribute_int(input, "mgunity", E->mesh.mgunity);
Output_h5.c:1527:    status = set_attribute_int(input, "mgunitz", E->mesh.mgunitz);
Output_h5.c:1529:    status = set_attribute_double(input, "radius_outer", E->sphere.ro);
Output_h5.c:1530:    status = set_attribute_double(input, "radius_inner", E->sphere.ri);
Output_h5.c:1532:    status = set_attribute_int(input, "caps", E->sphere.caps);
Output_h5.c:1536:    dims[0] = E->sphere.caps;
Output_h5.c:1540:    for(n = 1; n <= E->sphere.caps; n++)
Output_h5.c:1542:        data[4*(n-1) + 0] = E->sphere.cap[n].theta[1];
Output_h5.c:1543:        data[4*(n-1) + 1] = E->sphere.cap[n].theta[2];
Output_h5.c:1544:        data[4*(n-1) + 2] = E->sphere.cap[n].theta[3];
Output_h5.c:1545:        data[4*(n-1) + 3] = E->sphere.cap[n].theta[4];
Output_h5.c:1549:    for(n = 1; n <= E->sphere.caps; n++)
Output_h5.c:1551:        data[4*(n-1) + 0] = E->sphere.cap[n].fi[1];
Output_h5.c:1552:        data[4*(n-1) + 1] = E->sphere.cap[n].fi[2];
Output_h5.c:1553:        data[4*(n-1) + 2] = E->sphere.cap[n].fi[3];
Output_h5.c:1554:        data[4*(n-1) + 3] = E->sphere.cap[n].fi[4];
Output_h5.c:1561:    if (E->sphere.caps == 1)
Output_h5.c:1563:        status = set_attribute_double(input, "theta_min", E->control.theta_min);
Output_h5.c:1564:        status = set_attribute_double(input, "theta_max", E->control.theta_max);
Output_h5.c:1565:        status = set_attribute_double(input, "fi_min", E->control.fi_min);
Output_h5.c:1566:        status = set_attribute_double(input, "fi_max", E->control.fi_max);
Output_h5.c:1573:    status = set_attribute_int(input, "tracer", E->control.tracer);
Output_h5.c:1574:    status = set_attribute_string(input, "tracer_file", E->trace.tracer_file);
Output_h5.c:1580:    status = set_attribute_string(input, "Viscosity", E->viscosity.STRUCTURE);
Output_h5.c:1581:    status = set_attribute_int(input, "visc_smooth_method", E->viscosity.smooth_cycles);
Output_h5.c:1582:    status = set_attribute_int(input, "VISC_UPDATE", E->viscosity.update_allowed);
Output_h5.c:1584:    n = E->viscosity.num_mat;
Output_h5.c:1586:    status = set_attribute_float_vector(input, "visc0", n, E->viscosity.N0);
Output_h5.c:1587:    status = set_attribute_int(input, "TDEPV", E->viscosity.TDEPV);
Output_h5.c:1588:    status = set_attribute_int(input, "rheol", E->viscosity.RHEOL);
Output_h5.c:1589:    status = set_attribute_float_vector(input, "viscE", n, E->viscosity.E);
Output_h5.c:1590:    status = set_attribute_float_vector(input, "viscT", n, E->viscosity.T);
Output_h5.c:1591:    status = set_attribute_float_vector(input, "viscZ", n, E->viscosity.Z);
Output_h5.c:1593:    status = set_attribute_int(input, "SDEPV", E->viscosity.SDEPV);
Output_h5.c:1594:    status = set_attribute_float(input, "sdepv_misfit", E->viscosity.sdepv_misfit);
Output_h5.c:1595:    status = set_attribute_float_vector(input, "sdepv_expt", n, E->viscosity.sdepv_expt);
Output_h5.c:1597:    status = set_attribute_int(input, "VMIN", E->viscosity.MIN);
Output_h5.c:1598:    status = set_attribute_float(input, "visc_min", E->viscosity.min_value);
Output_h5.c:1600:    status = set_attribute_int(input, "VMAX", E->viscosity.MAX);
Output_h5.c:1601:    status = set_attribute_float(input, "visc_max", E->viscosity.max_value);
Output_h5.c:1607:    status = set_attribute_string(input, "Solver", E->control.SOLVER_TYPE);
Output_h5.c:1608:    status = set_attribute_int(input, "node_assemble", E->control.NASSEMBLE);
Output_h5.c:1609:    status = set_attribute_int(input, "precond", E->control.precondition);
Output_h5.c:1611:    status = set_attribute_double(input, "accuracy", E->control.accuracy);
Output_h5.c:1613:    status = set_attribute_int(input, "mg_cycle", E->control.mg_cycle);
Output_h5.c:1614:    status = set_attribute_int(input, "down_heavy", E->control.down_heavy);
Output_h5.c:1615:    status = set_attribute_int(input, "up_heavy", E->control.up_heavy);
Output_h5.c:1617:    status = set_attribute_int(input, "vlowstep", E->control.v_steps_low);
Output_h5.c:1618:    status = set_attribute_int(input, "vhighstep", E->control.v_steps_high);
Output_h5.c:1619:    status = set_attribute_int(input, "piterations", E->control.p_iterations);
Output_h5.c:1621:    status = set_attribute_int(input, "aug_lagr", E->control.augmented_Lagr);
Output_h5.c:1622:    status = set_attribute_double(input, "aug_number", E->control.augmented);
Output_h5.c:1624:    /* status = set_attribute(input, "", H5T_NATIVE_, &(E->)); */
Output_h5.c:1793:    px = E->parallel.me_loc[1];
Output_h5.c:1794:    py = E->parallel.me_loc[2];
Output_h5.c:1795:    pz = E->parallel.me_loc[3];
Output_h5.c:1798:    nprocx = E->parallel.nprocx;
Output_h5.c:1799:    nprocy = E->parallel.nprocy;
Output_h5.c:1800:    nprocz = E->parallel.nprocz;
Output_h5.c:1803:    nodex = E->mesh.nox;
Output_h5.c:1804:    nodey = E->mesh.noy;
Output_h5.c:1805:    nodez = E->mesh.noz;
Output_h5.c:1808:    nx = E->lmesh.nox;
Output_h5.c:1809:    ny = E->lmesh.noy;
Output_h5.c:1810:    nz = E->lmesh.noz;
Output_h5.c:1879:            (*field)->dims[s] = E->sphere.caps;
Output_h5.c:1880:            (*field)->maxdims[s] = E->sphere.caps;
Output_h5.c:1883:            (*field)->offset[s] = E->hdf5.cap;
Output_h5.c:1947:        if(E->control.verbose) {
Output_h5.c:1948:            fprintf(E->fp_out, "creating dataset: rank=%d  size=%d\n",
Output_h5.c:1950:            fprintf(E->fp_out, "  s=%d  x=%d  y=%d  z=%d  c=%d\n",
Output_h5.c:1952:            fprintf(E->fp_out, "\tdim\tmaxdim\toffset\tstride\tcount\tblock\n");
Output_h5.c:1954:                fprintf(E->fp_out, "\t%d\t%d\t%d\t%d\t%d\t%d\n",
Output_vtk.c:60:             E->lmesh.ezs, E->lmesh.ezs + E->lmesh.elz,
Output_vtk.c:61:             E->lmesh.exs, E->lmesh.exs + E->lmesh.elx,
Output_vtk.c:62:             E->lmesh.eys, E->lmesh.eys + E->lmesh.ely);
Output_vtk.c:116:    int nodes = E->sphere.caps_per_proc*E->lmesh.nno;
Output_vtk.c:119:    fprintf(fp, "        <DataArray type=\"Float32\" Name=\"temperature\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:122:        floattemp[i] =  (float) *(E->T[1]+i+1);
Output_vtk.c:124:    if (strcmp(E->output.vtk_format,"binary") == 0) {
Output_vtk.c:138:    int nodes=E->sphere.caps_per_proc*E->lmesh.nno;
Output_vtk.c:141:    const int lev = E->mesh.levmax;
Output_vtk.c:144:    fprintf(fp, "        <DataArray type=\"Float32\" Name=\"velocity\" NumberOfComponents=\"3\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:146:    for(j=1; j<=E->sphere.caps_per_proc; j++) {
Output_vtk.c:147:        V[1] = E->sphere.cap[j].V[1];
Output_vtk.c:148:        V[2] = E->sphere.cap[j].V[2];
Output_vtk.c:149:        V[3] = E->sphere.cap[j].V[3];
Output_vtk.c:151:        for(i=1; i<=E->lmesh.nno; i++) {
Output_vtk.c:152:            sint = E->SinCos[lev][j][0][i];
Output_vtk.c:153:            sinf = E->SinCos[lev][j][1][i];
Output_vtk.c:154:            cost = E->SinCos[lev][j][2][i];
Output_vtk.c:155:            cosf = E->SinCos[lev][j][3][i];
Output_vtk.c:157:            floatvel[(((j-1)*E->sphere.caps_per_proc)+i-1)*3+0] = (float)(V[1][i]*cost*cosf - V[2][i]*sinf + V[3][i]*sint*cosf);
Output_vtk.c:158:            floatvel[(((j-1)*E->sphere.caps_per_proc)+i-1)*3+1] = (float)(V[1][i]*cost*sinf + V[2][i]*cosf + V[3][i]*sint*sinf);
Output_vtk.c:159:            floatvel[(((j-1)*E->sphere.caps_per_proc)+i-1)*3+2] = (float)(-V[1][i]*sint + V[3][i]*cost);
Output_vtk.c:163:    if (strcmp(E->output.vtk_format, "binary") == 0)
Output_vtk.c:176:    int nodes = E->sphere.caps_per_proc*E->lmesh.nno;
Output_vtk.c:177:    int lev = E->mesh.levmax;
Output_vtk.c:179:    fprintf(fp, "        <DataArray type=\"Float32\" Name=\"viscosity\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:180:        if (strcmp(E->output.vtk_format, "binary") == 0) {
Output_vtk.c:181:            write_binary_array(nodes,&E->VI[lev][1][1],fp);
Output_vtk.c:183:            write_ascii_array(nodes,1,&E->VI[lev][1][1],fp);
Output_vtk.c:196:    int nodes = E->sphere.caps_per_proc*E->lmesh.nno;
Output_vtk.c:200:    fprintf(fp, "        <DataArray type=\"Float32\" Name=\"coordinate\" NumberOfComponents=\"3\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:202:    for(j=1; j<=E->sphere.caps_per_proc; j++) {
Output_vtk.c:203:        for(i=1; i<=E->lmesh.nno; i++){
Output_vtk.c:204:                floatpos[((j-1)*E->lmesh.nno+i-1)*3] = (float)(E->x[j][1][i]);
Output_vtk.c:205:	        floatpos[((j-1)*E->lmesh.nno+i-1)*3+1]=(float)(E->x[j][2][i]);
Output_vtk.c:206:	        floatpos[((j-1)*E->lmesh.nno+i-1)*3+2]=(float)(E->x[j][3][i]);
Output_vtk.c:210:    if (strcmp(E->output.vtk_format, "binary") == 0)
Output_vtk.c:222:    int nodes = E->sphere.caps_per_proc*E->lmesh.nno;
Output_vtk.c:235:    fprintf(fp, "        <DataArray type=\"Float32\" Name=\"stress\" NumberOfComponents=\"6\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:237:    if (strcmp(E->output.vtk_format, "binary") == 0) {
Output_vtk.c:238:        write_binary_array(nodes*6,&E->gstress[1][1],fp);
Output_vtk.c:240:        write_ascii_array(nodes*6,6,&E->gstress[1][1],fp);
Output_vtk.c:251:    int nodes = E->sphere.caps_per_proc*E->lmesh.nno;
Output_vtk.c:254:    for(k=0;k<E->composition.ncomp;k++) {
Output_vtk.c:255:        fprintf(fp, "        <DataArray type=\"Float32\" Name=\"composition%d\" format=\"%s\">\n", k+1, E->output.vtk_format);
Output_vtk.c:257:        for(j=1; j<=E->sphere.caps_per_proc; j++) {
Output_vtk.c:258:            for(i=1; i<=E->lmesh.nno; i++) {
Output_vtk.c:259:                floatcompo[(j-1)*E->lmesh.nno+i-1] = (float) (E->composition.comp_node[j][k][i]);
Output_vtk.c:263:        if (strcmp(E->output.vtk_format, "binary") == 0)
Output_vtk.c:277:    int nodes = E->sphere.caps_per_proc*E->lmesh.nno;
Output_vtk.c:281:    if((E->output.write_q_files == 0) || (cycles == 0) ||
Output_vtk.c:282:      (cycles % E->output.write_q_files)!=0)
Output_vtk.c:286:    if(E->control.use_cbf_topo){
Output_vtk.c:287:        get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);
Output_vtk.c:290:        get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,cycles);
Output_vtk.c:293:    fprintf(fp,"        <DataArray type=\"Float32\" Name=\"surface\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:295:    for(j=1;j<=E->sphere.caps_per_proc;j++){
Output_vtk.c:296:        for(i=1;i<=E->lmesh.nsf;i++){
Output_vtk.c:297:            for(k=1;k<=E->lmesh.noz;k++){
Output_vtk.c:298:                floattopo[(j-1)*E->lmesh.nno + (i-1)*E->lmesh.noz + k-1] = 0.0;
Output_vtk.c:301:            if (E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Output_vtk.c:304:                if(E->control.pseudo_free_surf)
Output_vtk.c:305:                floattopo[(j-1)*E->lmesh.nno + i*E->lmesh.noz-1] = E->slice.freesurf[j][i];
Output_vtk.c:307:                floattopo[(j-1)*E->lmesh.nno + i*E->lmesh.noz-1] = E->slice.tpg[j][i];
Output_vtk.c:313:    if (strcmp(E->output.vtk_format, "binary") == 0)
Output_vtk.c:335:             E->control.data_file, cycles);
Output_vtk.c:339:    for(n=0; n<E->parallel.nproc; n++) {
Output_vtk.c:341:                n, E->control.data_prefix, n, cycles);
Output_vtk.c:358:             E->control.data_file, cycles);
Output_vtk.c:360:    fprintf(fp, header, E->parallel.nproc);
Output_vtk.c:362:    for(n=0; n<E->parallel.nproc; n++) {
Output_vtk.c:364:                E->control.data_prefix, n, cycles);
Output_vtk.c:375:             E->control.data_file,cycles);
Output_vtk.c:390:        E->lmesh.ezs, E->lmesh.ezs + E->lmesh.elz*E->parallel.nprocz,
Output_vtk.c:391:        E->lmesh.exs, E->lmesh.exs + E->lmesh.elx*E->parallel.nprocx,
Output_vtk.c:392:        E->lmesh.eys, E->lmesh.eys + E->lmesh.ely*E->parallel.nprocy);
Output_vtk.c:394:    snprintf(header, 1024, format, extent, E->output.vtk_format,
Output_vtk.c:395:             E->output.vtk_format, E->output.vtk_format);
Output_vtk.c:398:    if (E->output.stress){
Output_vtk.c:399:        fprintf(fp,"      <DataArray type=\"Float32\" Name=\"stress\" NumberOfComponents=\"6\" format=\"%s\"/>\n", E->output.vtk_format);
Output_vtk.c:401:    if (E->output.comp_nd && E->composition.on){
Output_vtk.c:402:        fprintf(fp,"      <DataArray type=\"Float32\" Name=\"composition1\" format=\"%s\"/>\n", E->output.vtk_format);
Output_vtk.c:404:    if (E->output.surf){
Output_vtk.c:405:        fprintf(fp,"      <DataArray type=\"Float32\" Name=\"surface\" format=\"%s\"/>\n", E->output.vtk_format);
Output_vtk.c:415:    for(i=0; i < E->parallel.nprocy;i++){
Output_vtk.c:416:        for(j=0; j < E->parallel.nprocx;j++){
Output_vtk.c:417:            for(k=0; k < E->parallel.nprocz;k++){
Output_vtk.c:419:                    (k%E->parallel.nprocz)*E->lmesh.elz,
Output_vtk.c:420:                    (k%E->parallel.nprocz+1)*E->lmesh.elz,
Output_vtk.c:421:                    (j%E->parallel.nprocx)*E->lmesh.elx, (j%E->parallel.nprocx+1)*E->lmesh.elx,
Output_vtk.c:422:                    (i%E->parallel.nprocy)*E->lmesh.ely, (i%E->parallel.nprocy+1)*E->lmesh.ely,
Output_vtk.c:423:                    E->control.data_prefix,
Output_vtk.c:424:                    i*E->parallel.nprocx*E->parallel.nprocz+j*E->parallel.nprocz+k, cycles);
Output_vtk.c:694:             E->control.data_file, E->parallel.me, cycles);
Output_vtk.c:708:    if (E->output.stress)
Output_vtk.c:711:    if (E->output.comp_nd && E->composition.on)
Output_vtk.c:714:    if (E->output.surf)
Output_vtk.c:732:	if (E->output.geoid)      /* this needs to be called after the surface 
Output_vtk.c:737:    if (E->parallel.me == 0) {
Output_vtk.c:738:        if (E->sphere.caps == 12) {
Pan_problem_misc_functions.c:90:   if (E->parallel.me==0) {
Pan_problem_misc_functions.c:91:    sprintf(unique_name,"%06d.%s-%s",E->control.PID,comment,name);
Pan_problem_misc_functions.c:104:  /* This function is called only when E->control.side_sbcs is true.
Pan_problem_misc_functions.c:113:  if(E->parallel.total_surf_proc==12) {
Pan_problem_misc_functions.c:118:  for(m=1; m<=E->sphere.caps_per_proc; m++) {
Pan_problem_misc_functions.c:119:    E->sbc.node[m] = (int* ) malloc((E->lmesh.nno+1)*sizeof(int));
Pan_problem_misc_functions.c:122:    for(i=1; i<=E->lmesh.nno; i++) {
Pan_problem_misc_functions.c:123:      if(E->node[m][i] & sbc_flags) {
Pan_problem_misc_functions.c:124:	E->sbc.node[m][i] = n;
Pan_problem_misc_functions.c:128:	E->sbc.node[m][i] = 0;
Pan_problem_misc_functions.c:133:      for(d=1; d<=E->mesh.nsd; d++) {
Pan_problem_misc_functions.c:134:	E->sbc.SB[m][side][d] = (double *) malloc(n*sizeof(double));
Pan_problem_misc_functions.c:137:	  E->sbc.SB[m][side][d][i] = 0;
Pan_problem_misc_functions.c:140:    for(d=1; d<=E->mesh.nsd; d++)
Pan_problem_misc_functions.c:141:      for(i=1; i<=E->lmesh.nno; i++)
Pan_problem_misc_functions.c:142:	if(E->node[m][i] & sbc_flag[d] && E->sphere.cap[m].VB[d][i] != 0) {
Pan_problem_misc_functions.c:143:	  j = E->sbc.node[m][i];
Pan_problem_misc_functions.c:145:	    E->sbc.SB[m][side][d][j] = E->sphere.cap[m].VB[d][i];
Pan_problem_misc_functions.c:154:    int lev = E->mesh.levmax;
Pan_problem_misc_functions.c:159:    nxny = E->lmesh.nox*E->lmesh.noy;
Pan_problem_misc_functions.c:161:    temp = E->control.Atemp;
Pan_problem_misc_functions.c:164:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Pan_problem_misc_functions.c:165:      for(i=1;i<=E->lmesh.nno;i++) {
Pan_problem_misc_functions.c:166:	nz = ((i-1) % E->lmesh.noz) + 1;
Pan_problem_misc_functions.c:170:        buoy[m][i] =  temp * E->refstate.rho[nz]
Pan_problem_misc_functions.c:171:	  * E->refstate.thermal_expansivity[nz] * E->T[m][i];
Pan_problem_misc_functions.c:175:    if(E->control.tracer &&
Pan_problem_misc_functions.c:176:       (E->composition.ichemical_buoyancy)) {
Pan_problem_misc_functions.c:177:      for(j=0;j<E->composition.ncomp;j++) {
Pan_problem_misc_functions.c:179:	temp2 = E->composition.buoyancy_ratio[j] * temp;
Pan_problem_misc_functions.c:180:            for(m=1;m<=E->sphere.caps_per_proc;m++)
Pan_problem_misc_functions.c:181:	      for(i=1;i<=E->lmesh.nno;i++)
Pan_problem_misc_functions.c:182:		buoy[m][i] -= temp2 * E->composition.comp_node[m][j][i];
Pan_problem_misc_functions.c:187:    if(E->control.ggrd.ray_control)
Pan_problem_misc_functions.c:199:    if(E->data.use_rotation_g){
Pan_problem_misc_functions.c:207:      rfac = E->data.ge*(5./2.*E->data.rotm-E->data.ellipticity);
Pan_problem_misc_functions.c:209:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Pan_problem_misc_functions.c:211:	  for(i=1;i<=E->lmesh.noz;i++)
Pan_problem_misc_functions.c:212:	    n = j*E->lmesh.noz + i; /* this could be improved by only
Pan_problem_misc_functions.c:215:	    cost2 = cos(E->sx[m][1][n]);cost2 = cost2*cost2;	    /* cos^2(theta) */
Pan_problem_misc_functions.c:217:	    buoy[m][n] *= E->refstate.gravity[i] * (E->data.ge+rfac*cost2);
Pan_problem_misc_functions.c:223:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Pan_problem_misc_functions.c:225:	  for(i=1;i<=E->lmesh.noz;i++){
Pan_problem_misc_functions.c:226:	    n = j*E->lmesh.noz + i;
Pan_problem_misc_functions.c:227:	    buoy[m][n] *= E->refstate.gravity[i];
Pan_problem_misc_functions.c:291: * Then, the next E->mesh.nel lines are read into var array.
Pan_problem_misc_functions.c:310:            if(E->parallel.me == 0)
Pan_problem_misc_functions.c:321:    for(i=E->mesh.elz-1; i>=0; i--) {
Pan_problem_misc_functions.c:326:            fprintf(stderr,"Error while reading file '%s'\n", E->viscosity.layer_file);
Pan_problem_misc_functions.c:458:  lev = E->mesh.levmax;
Pan_problem_misc_functions.c:459:  st = E->SinCos[lev][cap][0][node]; /* for elliptical, sincos would be  corrected */
Pan_problem_misc_functions.c:460:  sp = E->SinCos[lev][cap][1][node];
Pan_problem_misc_functions.c:461:  ct = E->SinCos[lev][cap][2][node];
Pan_problem_misc_functions.c:462:  cp = E->SinCos[lev][cap][3][node];
Pan_problem_misc_functions.c:525:  E->control.verbose = 1;
Pan_problem_misc_functions.c:528:	  E->parallel.me,message);
Pan_problem_misc_functions.c:549:  brange = (double)E->control.coor_refine[0];
Pan_problem_misc_functions.c:550:  bfrac =  (double)E->control.coor_refine[1];
Pan_problem_misc_functions.c:551:  trange = (double)E->control.coor_refine[2];
Pan_problem_misc_functions.c:552:  tfrac = (double)E->control.coor_refine[3];
Pan_problem_misc_functions.c:554:  range = (double) E->sphere.ro - E->sphere.ri;		/* original range */
Pan_problem_misc_functions.c:564:  nb = E->mesh.noz * bfrac;
Pan_problem_misc_functions.c:565:  nt = E->mesh.noz * tfrac;
Pan_problem_misc_functions.c:566:  nm = E->mesh.noz - nb - nt;
Pan_problem_misc_functions.c:574:  for(r=E->sphere.ri,k=1;k<=nb;k++,r+=drb){
Pan_problem_misc_functions.c:577:  klim = E->mesh.noz - nt + 1;
Pan_problem_misc_functions.c:581:  for(;k <= E->mesh.noz;k++,r+=drt){
Pan_problem_misc_functions.c:591:rr[1...E->mesh.noz]
Pan_problem_misc_functions.c:606:  if(E->control.nrlayer[0] != 1)
Pan_problem_misc_functions.c:608:  if(E->control.nrlayer[E->control.rlayers-1] != E->mesh.noz)
Pan_problem_misc_functions.c:610:  if(fabs(E->control.rrlayer[0] -E->sphere.ri) > 1e-5)
Pan_problem_misc_functions.c:612:  if(fabs(E->control.rrlayer[ E->control.rlayers-1] - E->sphere.ro)>1e-6)
Pan_problem_misc_functions.c:614:  if(E->control.rlayers < 2)
Pan_problem_misc_functions.c:617:  rr[1] =  E->control.rrlayer[0];
Pan_problem_misc_functions.c:618:  for(j = 1; j < E->control.rlayers; j++){
Pan_problem_misc_functions.c:619:    ddr = (E->control.rrlayer[j] - E->control.rrlayer[j - 1]) /
Pan_problem_misc_functions.c:620:      (E->control.nrlayer[j] - E->control.nrlayer[j - 1]);
Pan_problem_misc_functions.c:621:    for(k = E->control.nrlayer[j-1]+1;k <= E->control.nrlayer[j];k++)
Pan_problem_misc_functions.c:690:  if(E->data.use_ellipse){
Pan_problem_misc_functions.c:692:    return M_PI_2 - atan2(tan(tmp),E->data.efac);
Parallel_util.c:60:  MPI_Barrier(E->parallel.world);
Parsing.c:98:    int m=E->parallel.me;
Phase_change.c:50:  int nno  = E->lmesh.nno;
Phase_change.c:51:  int nsf  = E->lmesh.nsf;
Phase_change.c:53:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Phase_change.c:54:    E->Fas410[j]   = (float *) malloc((nno+1)*sizeof(float));
Phase_change.c:55:    E->Fas410_b[j] = (float *) malloc((nsf+1)*sizeof(float));
Phase_change.c:56:    E->Fas670[j]   = (float *) malloc((nno+1)*sizeof(float));
Phase_change.c:57:    E->Fas670_b[j] = (float *) malloc((nsf+1)*sizeof(float));
Phase_change.c:58:    E->Fascmb[j]   = (float *) malloc((nno+1)*sizeof(float));
Phase_change.c:59:    E->Fascmb_b[j] = (float *) malloc((nsf+1)*sizeof(float));
Phase_change.c:68:  int m = E->parallel.me;
Phase_change.c:72:  input_float("Ra_410",&(E->control.Ra_410),"0.0",m);
Phase_change.c:73:  input_float("clapeyron410",&(E->control.clapeyron410),"0.0",m);
Phase_change.c:74:  input_float("transT410",&(E->control.transT410),"0.0",m);
Phase_change.c:78:    E->control.inv_width410 = 1.0/width;
Phase_change.c:81:  input_float("Ra_670",&(E->control.Ra_670),"0.0",m);
Phase_change.c:82:  input_float("clapeyron670",&(E->control.clapeyron670),"0.0",m);
Phase_change.c:83:  input_float("transT670",&(E->control.transT670),"0.0",m);
Phase_change.c:87:    E->control.inv_width670 = 1.0/width;
Phase_change.c:90:  input_float("Ra_cmb",&(E->control.Ra_cmb),"0.0",m);
Phase_change.c:91:  input_float("clapeyroncmb",&(E->control.clapeyroncmb),"0.0",m);
Phase_change.c:92:  input_float("transTcmb",&(E->control.transTcmb),"0.0",m);
Phase_change.c:96:    E->control.inv_widthcmb = 1.0/width;
Phase_change.c:105:  if (E->control.Ra_410 != 0.0)
Phase_change.c:106:    phase_change_apply(E, buoy, E->Fas410, E->Fas410_b, E->control.Ra_410,
Phase_change.c:107:		       E->control.clapeyron410, E->viscosity.z410,
Phase_change.c:108:		       E->control.transT410, E->control.inv_width410);
Phase_change.c:115:  if (E->control.Ra_670 != 0.0)
Phase_change.c:116:    phase_change_apply(E, buoy, E->Fas670, E->Fas670_b, E->control.Ra_670,
Phase_change.c:117:		       E->control.clapeyron670, E->viscosity.zlm,
Phase_change.c:118:		       E->control.transT670, E->control.inv_width670);
Phase_change.c:125:  if (E->control.Ra_cmb != 0.0)
Phase_change.c:126:    phase_change_apply(E, buoy, E->Fascmb, E->Fascmb_b, E->control.Ra_cmb,
Phase_change.c:127:		       E->control.clapeyroncmb, E->viscosity.zcmb,
Phase_change.c:128:		       E->control.transTcmb, E->control.inv_widthcmb);
Phase_change.c:141:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Phase_change.c:142:    for(i=1;i<=E->lmesh.nno;i++)
Phase_change.c:145:  if (E->control.verbose) {
Phase_change.c:146:    fprintf(E->fp_out, "Ra=%f, clapeyron=%f, depth=%f, transT=%f, inv_width=%f\n",
Phase_change.c:149:    fflush(E->fp_out);
Phase_change.c:167:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Phase_change.c:170:    for(i=1;i<=E->lmesh.nno;i++)  {
Phase_change.c:171:        nz = ((i-1) % E->lmesh.noz) + 1;
Phase_change.c:172:        dz = (E->sphere.ro-E->sx[m][3][i]) - depth;
Phase_change.c:176:        e_pressure = dz * E->refstate.rho[nz] * E->refstate.gravity[nz]
Phase_change.c:177:            - clapeyron * (E->T[m][i] - transT);
Phase_change.c:184:    for (k=1;k<=E->lmesh.noy;k++)
Phase_change.c:185:      for (j=1;j<=E->lmesh.nox;j++)  {
Phase_change.c:188:        for (i=1;i<E->lmesh.noz;i++)   {
Phase_change.c:189:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Phase_change.c:191:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Phase_change.c:204:  fprintf(E->fp_out,"output_phase_change_buoyancy\n");
Phase_change.c:205:  for(m=1;m<=E->sphere.caps_per_proc;m++)        {
Phase_change.c:206:    fprintf(E->fp_out,"for cap %d\n",E->sphere.capid[m]);
Phase_change.c:207:    for (j=1;j<=E->lmesh.nno;j++)
Phase_change.c:208:      fprintf(E->fp_out,"Z = %.6e T = %.6e B[%06d] = %.6e \n",E->sx[m][3][j],E->T[m][j],j,B[m][j]);
Phase_change.c:210:  fflush(E->fp_out);
Problem_related.c:44:    (E->solver.read_input_files_for_timesteps)(E,1,1); /* read velocity(1) and output(1) */
Problem_related.c:57:  (E->solver.read_input_files_for_timesteps)(E,4,1); /* read Rayleigh number for top layers */
Problem_related.c:68:    (E->solver.read_input_files_for_timesteps)(E,3,1); /* read element material(3) and output(1) */
Problem_related.c:79:    (E->solver.read_input_files_for_timesteps)(E,5,1); /* read temperature(5) and output(1) */
Problem_related.c:95:    E->monitor.elapsed_time = 0.0;
Problem_related.c:97:    if (E->convection.tic_method == -1) {
Problem_related.c:100:      if(strcmp(E->output.format, "ascii-gz") == 0){
Problem_related.c:101:	if(E->output.gzdir.vtk_io)
Problem_related.c:103:		  E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:106:		  E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:108:	sprintf(output_file, "%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:112:      sprintf(output_file, "%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:117:	fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file);
Problem_related.c:121:      if(sscanf(input_s,"%d %d %f",&ll,&mm,&E->monitor.elapsed_time) != 3) {
Problem_related.c:143:    if (E->control.zero_elapsed_time) /* set elapsed_time to zero */
Problem_related.c:144:	E->monitor.elapsed_time = 0.0;
Problem_related.c:158:    if (E->control.reset_startage)
Problem_related.c:159:	E->control.start_age = E->monitor.elapsed_time*E->data.scalet;
Problem_related.c:180:   if (E->data.timedir >= 0) { /* forward convection */
Problem_related.c:181:      age_in_MY = E->control.start_age - E->monitor.elapsed_time*E->data.scalet;
Problem_related.c:184:      age_in_MY = E->control.start_age + E->monitor.elapsed_time*E->data.scalet;
Problem_related.c:187:      if (((age_in_MY+e_4) < 0.0) && (E->monitor.solution_cycles < 1)) {
Problem_related.c:188:        if (E->parallel.me == 0) fprintf(stderr,"Age = %g Ma, Initial age should not be negative!\n",age_in_MY);
Process_buoyancy.c:66:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Process_buoyancy.c:70:    const int nno=E->lmesh.nno;
Process_buoyancy.c:71:    const int lev = E->mesh.levmax;
Process_buoyancy.c:78:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Process_buoyancy.c:86:    for(e=1;e<=E->lmesh.nel;e++) {
Process_buoyancy.c:96:          nz = ((E->ien[m][e].node[j]-1) % E->lmesh.noz)+1;
Process_buoyancy.c:97:          rho[i] += E->refstate.rho[nz]*E->N.vpt[GNVINDEX(j,i)];
Process_buoyancy.c:98:          u[i] += VV[3][j]*E->N.vpt[GNVINDEX(j,i)];
Process_buoyancy.c:99:          T[i] += E->T[m][E->ien[m][e].node[j]]*E->N.vpt[GNVINDEX(j,i)];
Process_buoyancy.c:100:          dTdz[i] += -E->T[m][E->ien[m][e].node[j]]*E->gNX[m][e].vpt[GNVXINDEX(2,j,i)];
Process_buoyancy.c:108:        uT += rho[i]*u[i]*T[i]*E->gDA[m][e].vpt[i] + dTdz[i]*E->gDA[m][e].vpt[i];
Process_buoyancy.c:111:      uT /= E->eco[m][e].area;
Process_buoyancy.c:114:        flux[m][E->ien[m][e].node[j]] += uT*E->TWW[lev][m][e].node[j];
Process_buoyancy.c:120:  (E->exchange_node_f)(E,flux,lev);
Process_buoyancy.c:122:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Process_buoyancy.c:124:       flux[m][i] *= E->MASS[lev][m][i];
Process_buoyancy.c:126:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Process_buoyancy.c:127:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Process_buoyancy.c:128:      for(i=1;i<=E->lmesh.nsf;i++)
Process_buoyancy.c:129:        E->slice.shflux[m][i]=2*flux[m][E->surf_node[m][i]]-flux[m][E->surf_node[m][i]-1];
Process_buoyancy.c:131:  if (E->parallel.me_loc[3]==0)
Process_buoyancy.c:132:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Process_buoyancy.c:133:      for(i=1;i<=E->lmesh.nsf;i++)
Process_buoyancy.c:134:        E->slice.bhflux[m][i] = 2*flux[m][E->surf_node[m][i]-E->lmesh.noz+1]
Process_buoyancy.c:135:                                - flux[m][E->surf_node[m][i]-E->lmesh.noz+2];
Process_buoyancy.c:137:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Process_buoyancy.c:138:    for(e=1;e<=E->lmesh.snel;e++) {
Process_buoyancy.c:139:         uT =(E->slice.shflux[m][E->sien[m][e].node[1]] +
Process_buoyancy.c:140:              E->slice.shflux[m][E->sien[m][e].node[2]] +
Process_buoyancy.c:141:              E->slice.shflux[m][E->sien[m][e].node[3]] +
Process_buoyancy.c:142:              E->slice.shflux[m][E->sien[m][e].node[4]])*0.25;
Process_buoyancy.c:143:         el = e*E->lmesh.elz;
Process_buoyancy.c:144:         sum_h[0] += uT*E->eco[m][el].area;
Process_buoyancy.c:145:         sum_h[1] += E->eco[m][el].area;
Process_buoyancy.c:147:         uT =(E->slice.bhflux[m][E->sien[m][e].node[1]] +
Process_buoyancy.c:148:              E->slice.bhflux[m][E->sien[m][e].node[2]] +
Process_buoyancy.c:149:              E->slice.bhflux[m][E->sien[m][e].node[3]] +
Process_buoyancy.c:150:              E->slice.bhflux[m][E->sien[m][e].node[4]])*0.25;
Process_buoyancy.c:151:         el = (e-1)*E->lmesh.elz+1;
Process_buoyancy.c:152:         sum_h[2] += uT*E->eco[m][el].area;
Process_buoyancy.c:153:         sum_h[3] += E->eco[m][el].area;
Process_buoyancy.c:158:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Process_buoyancy.c:160:    /*     if (E->control.verbose && E->parallel.me==E->parallel.nprocz-1) {
Process_buoyancy.c:161:	     fprintf(E->fp_out,"surface heat flux= %f %f\n",sum_h[0],E->monitor.elapsed_time);
Process_buoyancy.c:162:             fflush(E->fp_out);
Process_buoyancy.c:164:    if (E->parallel.me==E->parallel.nprocz-1) {
Process_buoyancy.c:166:      //fprintf(E->fp,"surface heat flux= %f\n",sum_h[0]); //commented out because E->fp is only on CPU 0 
Process_buoyancy.c:168:      if(E->output.write_q_files > 0){
Process_buoyancy.c:170:	fprintf(E->output.fpqt,"%13.5e %13.5e %13.5e\n",E->monitor.elapsed_time,sum_h[0],sqrt(E->monitor.vdotv));
Process_buoyancy.c:171:	fflush(E->output.fpqt);
Process_buoyancy.c:176:  if (E->parallel.me_loc[3]==0)    {
Process_buoyancy.c:178:/*     if (E->control.verbose && E->parallel.me==0) fprintf(E->fp_out,"bottom heat flux= %f %f\n",sum_h[2],E->monitor.elapsed_time); */
Process_buoyancy.c:179:    if (E->parallel.me==0) {
Process_buoyancy.c:181:      fprintf(E->fp,"bottom heat flux= %f\n",sum_h[2]);
Process_buoyancy.c:182:      if(E->output.write_q_files > 0){
Process_buoyancy.c:183:	fprintf(E->output.fpqb,"%13.5e %13.5e %13.5e\n",
Process_buoyancy.c:184:		E->monitor.elapsed_time,sum_h[2],sqrt(E->monitor.vdotv));
Process_buoyancy.c:185:	fflush(E->output.fpqb);
Process_buoyancy.c:192:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Process_buoyancy.c:212:    for(m=1;m<=E->sphere.caps_per_proc;m++)      {
Process_buoyancy.c:213:	S1[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Process_buoyancy.c:214:	S2[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Process_buoyancy.c:215:	S3[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Process_buoyancy.c:216:	S4[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Process_buoyancy.c:219:    lev = E->mesh.levmax;
Process_buoyancy.c:220:    for(m=1;m<=E->sphere.caps_per_proc;m++) {
Process_buoyancy.c:221:	for(i=1;i<=E->lmesh.nno;i++) {
Process_buoyancy.c:222:	    S1[m][i] = E->T[m][i];
Process_buoyancy.c:223:	    S2[m][i] = E->sphere.cap[m].V[1][i]*E->sphere.cap[m].V[1][i]
Process_buoyancy.c:224:          	+ E->sphere.cap[m].V[2][i]*E->sphere.cap[m].V[2][i];
Process_buoyancy.c:225:	    S3[m][i] = E->sphere.cap[m].V[3][i]*E->sphere.cap[m].V[3][i];
Process_buoyancy.c:226:	    S4[m][i] = E->VI[lev][m][i];
Process_buoyancy.c:230:    return_horiz_ave_f(E,S1,E->Have.T);
Process_buoyancy.c:231:    return_horiz_ave_f(E,S2,E->Have.V[1]);
Process_buoyancy.c:232:    return_horiz_ave_f(E,S3,E->Have.V[2]);
Process_buoyancy.c:233:    return_horiz_ave_f(E,S4,E->Have.vis);
Process_buoyancy.c:236:    if (E->composition.on) {
Process_buoyancy.c:237:        for(n=0; n<E->composition.ncomp; n++) {
Process_buoyancy.c:238:            for(m=1;m<=E->sphere.caps_per_proc;m++) {
Process_buoyancy.c:239:                for(i=1;i<=E->lmesh.nno;i++)
Process_buoyancy.c:240:                    S1[m][i] = E->composition.comp_node[m][n][i];
Process_buoyancy.c:242:            return_horiz_ave_f(E,S1,E->Have.C[n]);
Process_buoyancy.c:246:    for(m=1;m<=E->sphere.caps_per_proc;m++) {
Process_buoyancy.c:253:    for (i=1;i<=E->lmesh.noz;i++) {
Process_buoyancy.c:254:	E->Have.V[1][i] = sqrt(E->Have.V[1][i]);
Process_buoyancy.c:255:	E->Have.V[2][i] = sqrt(E->Have.V[2][i]);
Regional_boundary_conditions.c:58:  for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--)
Regional_boundary_conditions.c:59:    for (j=1;j<=E->sphere.caps_per_proc;j++)     {
Regional_boundary_conditions.c:60:      noz = E->lmesh.NOZ[lv];
Regional_boundary_conditions.c:62:      if(E->mesh.topvbc == 0) {
Regional_boundary_conditions.c:63:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,VBX,0,lv,j);
Regional_boundary_conditions.c:64:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,1,lv,j);
Regional_boundary_conditions.c:65:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,VBY,0,lv,j);
Regional_boundary_conditions.c:66:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,SBX,1,lv,j);
Regional_boundary_conditions.c:67:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,0,lv,j);
Regional_boundary_conditions.c:68:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,SBY,1,lv,j);
Regional_boundary_conditions.c:72:	if((lv==E->mesh.gridmax) && E->control.ggrd.vtop_control)
Regional_boundary_conditions.c:77:      else if(E->mesh.topvbc == 1) {
Regional_boundary_conditions.c:78:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,VBX,1,lv,j);
Regional_boundary_conditions.c:79:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,1,lv,j);
Regional_boundary_conditions.c:80:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,VBY,1,lv,j);
Regional_boundary_conditions.c:81:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,SBX,0,lv,j);
Regional_boundary_conditions.c:82:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,0,lv,j);
Regional_boundary_conditions.c:83:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,SBY,0,lv,j);
Regional_boundary_conditions.c:86:	if((lv==E->mesh.gridmax) && E->control.ggrd.vtop_control)
Regional_boundary_conditions.c:89:	if(E->control.vbcs_file)   {
Regional_boundary_conditions.c:90:	  if((lv == E->mesh.gridmin) && (j == E->sphere.caps_per_proc))
Regional_boundary_conditions.c:94:      else if(E->mesh.topvbc == 2) {
Regional_boundary_conditions.c:96:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,VBX,0,lv,j);
Regional_boundary_conditions.c:97:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,0,lv,j);
Regional_boundary_conditions.c:98:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,VBY,0,lv,j);
Regional_boundary_conditions.c:99:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,SBX,1,lv,j);
Regional_boundary_conditions.c:100:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,1,lv,j);
Regional_boundary_conditions.c:101:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,SBY,1,lv,j);
Regional_boundary_conditions.c:106:      if(E->mesh.botvbc == 0) {
Regional_boundary_conditions.c:107:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,VBX,0,lv,j);
Regional_boundary_conditions.c:108:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,1,lv,j);
Regional_boundary_conditions.c:109:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,VBY,0,lv,j);
Regional_boundary_conditions.c:110:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,SBX,1,lv,j);
Regional_boundary_conditions.c:111:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,SBZ,0,lv,j);
Regional_boundary_conditions.c:112:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,SBY,1,lv,j);
Regional_boundary_conditions.c:114:      else if(E->mesh.botvbc == 1) {
Regional_boundary_conditions.c:115:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,VBX,1,lv,j);
Regional_boundary_conditions.c:116:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,1,lv,j);
Regional_boundary_conditions.c:117:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,VBY,1,lv,j);
Regional_boundary_conditions.c:118:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,SBX,0,lv,j);
Regional_boundary_conditions.c:119:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,SBZ,0,lv,j);
Regional_boundary_conditions.c:120:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,SBY,0,lv,j);
Regional_boundary_conditions.c:128:      if(E->control.side_sbcs)
Regional_boundary_conditions.c:135:      anything at present, if E->mesh.toplayerbc != 0
Regional_boundary_conditions.c:142:      if(E->control.verbose) {
Regional_boundary_conditions.c:143:	for (j=1;j<=E->sphere.caps_per_proc;j++)
Regional_boundary_conditions.c:144:	  for (node=1;node<=E->lmesh.nno;node++)
Regional_boundary_conditions.c:145:	    fprintf(E->fp_out,"m=%d VB== %d %g %g %g flag %u %u %u\n",j,node,E->sphere.cap[j].VB[1][node],E->sphere.cap[j].VB[2][node],E->sphere.cap[j].VB[3][node],E->node[j][node]&VBX,E->node[j][node]&VBY,E->node[j][node]&VBZ);
Regional_boundary_conditions.c:146:	fflush(E->fp_out);
Regional_boundary_conditions.c:165:  lev = E->mesh.levmax;
Regional_boundary_conditions.c:170:  for (j=1;j<=E->sphere.caps_per_proc;j++)    {
Regional_boundary_conditions.c:171:    noz = E->lmesh.noz;
Regional_boundary_conditions.c:172:    if(E->mesh.toptbc == 1)    {
Regional_boundary_conditions.c:173:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,1,lev,j);
Regional_boundary_conditions.c:174:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,0,lev,j);
Regional_boundary_conditions.c:175:      if(E->control.tbcs_file)   {
Regional_boundary_conditions.c:180:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,0,lev,j);
Regional_boundary_conditions.c:181:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,1,lev,j);
Regional_boundary_conditions.c:184:    if(E->mesh.bottbc == 1)    {
Regional_boundary_conditions.c:185:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,1,lev,j);
Regional_boundary_conditions.c:186:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,0,lev,j);
Regional_boundary_conditions.c:189:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,0,lev,j);
Regional_boundary_conditions.c:190:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,1,lev,j);
Regional_boundary_conditions.c:193:    if((E->control.temperature_bound_adj==1) || (E->control.lith_age_time==1))  {
Regional_boundary_conditions.c:203:   E->temperatures_conform_bcs = temperatures_conform_bcs;
Regional_boundary_conditions.c:215:  const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:220:  if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1)
Regional_boundary_conditions.c:221:   for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:222:    for(j=1;j<=E->lmesh.noy;j++)
Regional_boundary_conditions.c:223:      for(i=1;i<=E->lmesh.noz;i++)  {
Regional_boundary_conditions.c:224:        node1 = i + (j-1)*E->lmesh.noz*E->lmesh.nox;
Regional_boundary_conditions.c:225:        node2 = node1 + (E->lmesh.nox-1)*E->lmesh.noz;
Regional_boundary_conditions.c:227:        ii = i + E->lmesh.nzs - 1;
Regional_boundary_conditions.c:228:        if (E->parallel.me_loc[1]==0 )  {
Regional_boundary_conditions.c:229:           E->sphere.cap[m].VB[1][node1] = 0.0;
Regional_boundary_conditions.c:230:           if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:231:              E->sphere.cap[m].VB[3][node1] = 0.0;
Regional_boundary_conditions.c:233:        if (E->parallel.me_loc[1]==E->parallel.nprocx-1)  {
Regional_boundary_conditions.c:234:           E->sphere.cap[m].VB[1][node2] = 0.0;
Regional_boundary_conditions.c:235:           if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:236:              E->sphere.cap[m].VB[3][node2] = 0.0;
Regional_boundary_conditions.c:243:    if (E->parallel.me_loc[2]==0)
Regional_boundary_conditions.c:244:     for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:245:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:246:        for(i=1;i<=E->lmesh.noz;i++)       {
Regional_boundary_conditions.c:247:          node1 = i + (j-1)*E->lmesh.noz;
Regional_boundary_conditions.c:248:          ii = i + E->lmesh.nzs - 1;
Regional_boundary_conditions.c:250:          E->sphere.cap[m].VB[2][node1] = 0.0;
Regional_boundary_conditions.c:251:          if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:252:            E->sphere.cap[m].VB[3][node1] = 0.0;
Regional_boundary_conditions.c:255:    if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Regional_boundary_conditions.c:256:     for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:257:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:258:        for(i=1;i<=E->lmesh.noz;i++)       {
Regional_boundary_conditions.c:259:          node2 = (E->lmesh.noy-1)*E->lmesh.noz*E->lmesh.nox + i + (j-1)*E->lmesh.noz;
Regional_boundary_conditions.c:260:          ii = i + E->lmesh.nzs - 1;
Regional_boundary_conditions.c:262:          E->sphere.cap[m].VB[2][node2] = 0.0;
Regional_boundary_conditions.c:263:          if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:264:            E->sphere.cap[m].VB[3][node2] = 0.0;
Regional_boundary_conditions.c:269:  for(level=E->mesh.levmax;level>=E->mesh.levmin;level--) {
Regional_boundary_conditions.c:271:    if ( (E->control.CONJ_GRAD && level==E->mesh.levmax) ||E->control.NMULTIGRID)  {
Regional_boundary_conditions.c:272:    noz = E->lmesh.NOZ[level] ;
Regional_boundary_conditions.c:273:    noy = E->lmesh.NOY[level] ;
Regional_boundary_conditions.c:274:    nox = E->lmesh.NOX[level] ;
Regional_boundary_conditions.c:276:     for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Regional_boundary_conditions.c:277:       if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1) {
Regional_boundary_conditions.c:282:          ii = i + E->lmesh.NZS[level] - 1;
Regional_boundary_conditions.c:283:          if (E->parallel.me_loc[1]==0 )  {
Regional_boundary_conditions.c:284:            E->NODE[level][m][node1] = E->NODE[level][m][node1] | VBX;
Regional_boundary_conditions.c:285:            E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~SBX);
Regional_boundary_conditions.c:286:            if((ii!=1) && (ii!=E->mesh.NOZ[level])) {
Regional_boundary_conditions.c:287:               E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBY);
Regional_boundary_conditions.c:288:               E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBY;
Regional_boundary_conditions.c:289:               E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBZ);
Regional_boundary_conditions.c:290:               E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBZ;
Regional_boundary_conditions.c:293:          if (E->parallel.me_loc[1]==E->parallel.nprocx-1)  {
Regional_boundary_conditions.c:294:            E->NODE[level][m][node2] = E->NODE[level][m][node2] | VBX;
Regional_boundary_conditions.c:295:            E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~SBX);
Regional_boundary_conditions.c:296:            if((ii!=1) && (ii!=E->mesh.NOZ[level])) {
Regional_boundary_conditions.c:297:              E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBY);
Regional_boundary_conditions.c:298:              E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBY;
Regional_boundary_conditions.c:299:              E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBZ);
Regional_boundary_conditions.c:300:              E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBZ;
Regional_boundary_conditions.c:308:      if (E->parallel.me_loc[2]==0)
Regional_boundary_conditions.c:312:            ii = i + E->lmesh.NZS[level] - 1;
Regional_boundary_conditions.c:313:            jj = j + E->lmesh.NXS[level] - 1;
Regional_boundary_conditions.c:315:            E->NODE[level][m][node1] = E->NODE[level][m][node1] | VBY;
Regional_boundary_conditions.c:316:            E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~SBY);
Regional_boundary_conditions.c:317:            if((ii!= 1) && (ii != E->mesh.NOZ[level]))  {
Regional_boundary_conditions.c:318:                E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBZ);
Regional_boundary_conditions.c:319:                E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBZ;
Regional_boundary_conditions.c:321:            if((jj!=1) && (jj!=E->mesh.NOX[level]) && (ii!=1) && (ii!=E->mesh.NOZ[level])){
Regional_boundary_conditions.c:322:                E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBX);
Regional_boundary_conditions.c:323:                E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBX;
Regional_boundary_conditions.c:327:      if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Regional_boundary_conditions.c:331:            ii = i + E->lmesh.NZS[level] - 1;
Regional_boundary_conditions.c:332:            jj = j + E->lmesh.NXS[level] - 1;
Regional_boundary_conditions.c:333:            E->NODE[level][m][node2] = E->NODE[level][m][node2] | VBY;
Regional_boundary_conditions.c:334:            E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~SBY);
Regional_boundary_conditions.c:335:            if((ii!= 1) && (ii != E->mesh.NOZ[level]))  {
Regional_boundary_conditions.c:336:                E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBZ);
Regional_boundary_conditions.c:337:                E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBZ;
Regional_boundary_conditions.c:339:            if((jj!=1) && (jj!=E->mesh.NOX[level]) && (ii!=1) && (ii!=E->mesh.NOZ[level])){
Regional_boundary_conditions.c:340:                E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBX);
Regional_boundary_conditions.c:341:                E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBX;
Regional_boundary_conditions.c:357:  const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:361:   if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1)
Regional_boundary_conditions.c:362:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:363:    for(j=1;j<=E->lmesh.noy;j++)
Regional_boundary_conditions.c:364:      for(i=1;i<=E->lmesh.noz;i++) {
Regional_boundary_conditions.c:365:        node1 = i + (j-1)*E->lmesh.noz*E->lmesh.nox;
Regional_boundary_conditions.c:366:        node2 = node1 + (E->lmesh.nox-1)*E->lmesh.noz;
Regional_boundary_conditions.c:367:        if (E->parallel.me_loc[1]==0 )                   {
Regional_boundary_conditions.c:368:          E->node[m][node1] = E->node[m][node1] & (~TBX);
Regional_boundary_conditions.c:369:          E->node[m][node1] = E->node[m][node1] | FBX;
Regional_boundary_conditions.c:370:          E->sphere.cap[m].TB[1][node1] = 0.0;
Regional_boundary_conditions.c:372:        if (E->parallel.me_loc[1]==E->parallel.nprocx-1)   {
Regional_boundary_conditions.c:373:          E->node[m][node2] = E->node[m][node2] & (~TBX);
Regional_boundary_conditions.c:374:          E->node[m][node2] = E->node[m][node2] | FBX;
Regional_boundary_conditions.c:375:          E->sphere.cap[m].TB[1][node2] = 0.0;
Regional_boundary_conditions.c:379:    if (E->parallel.me_loc[2]==0)
Regional_boundary_conditions.c:380:     for(m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:381:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:382:        for(i=1;i<=E->lmesh.noz;i++) {
Regional_boundary_conditions.c:383:          node1 = i + (j-1)*E->lmesh.noz;
Regional_boundary_conditions.c:384:          E->node[m][node1] = E->node[m][node1] & (~TBY);
Regional_boundary_conditions.c:385:              E->node[m][node1] = E->node[m][node1] | FBY;
Regional_boundary_conditions.c:386:              E->sphere.cap[m].TB[2][node1] = 0.0;
Regional_boundary_conditions.c:389:    if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Regional_boundary_conditions.c:390:     for(m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:391:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:392:        for(i=1;i<=E->lmesh.noz;i++) {
Regional_boundary_conditions.c:393:          node2 = i +(j-1)*E->lmesh.noz + (E->lmesh.noy-1)*E->lmesh.noz*E->lmesh.nox;
Regional_boundary_conditions.c:394:          E->node[m][node2] = E->node[m][node2] & (~TBY);
Regional_boundary_conditions.c:395:          E->node[m][node2] = E->node[m][node2] | FBY;
Regional_boundary_conditions.c:396:          E->sphere.cap[m].TB[2][node2] = 0.0;
Regional_boundary_conditions.c:411:  if(dirn > E->mesh.nsd)
Regional_boundary_conditions.c:417:      rowl = E->lmesh.NOZ[level];
Regional_boundary_conditions.c:419:  if ( ( (ROW==1) && (E->parallel.me_loc[3]==0) ) ||
Regional_boundary_conditions.c:420:       ( (ROW==E->lmesh.NOZ[level]) && (E->parallel.me_loc[3]==E->parallel.nprocz-1)) ) {
Regional_boundary_conditions.c:424:      for(j=1;j<=E->lmesh.NOY[level];j++)
Regional_boundary_conditions.c:425:    	for(i=1;i<=E->lmesh.NOX[level];i++)     {
Regional_boundary_conditions.c:426:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Regional_boundary_conditions.c:427:    	  E->NODE[level][m][node] = E->NODE[level][m][node] & (~ mask);
Regional_boundary_conditions.c:433:      for(j=1;j<=E->lmesh.NOY[level];j++)
Regional_boundary_conditions.c:434:        for(i=1;i<=E->lmesh.NOX[level];i++)       {
Regional_boundary_conditions.c:435:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Regional_boundary_conditions.c:436:    	  E->NODE[level][m][node] = E->NODE[level][m][node] | (mask);
Regional_boundary_conditions.c:438:    	  if(level==E->mesh.levmax)   /* NB */
Regional_boundary_conditions.c:454:  const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:456:  fprintf(E->fp,"Periodic boundary conditions\n");
Regional_boundary_conditions.c:464: const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:466: fprintf(E->fp,"pERIodic temperature boundary conditions\n");
Regional_geometry_cartesian.c:36:  E->mesh.nsd = 2;
Regional_geometry_cartesian.c:37:  E->mesh.dof = 2;
Regional_geometry_cartesian.c:46:  E->mesh.nsd = 2;
Regional_geometry_cartesian.c:47:  E->mesh.dof = 3;
Regional_geometry_cartesian.c:55:  E->mesh.nsd = 3;
Regional_geometry_cartesian.c:56:  E->mesh.dof = 3;
Regional_geometry_cartesian.c:63:  E->mesh.nsd = 3;
Regional_geometry_cartesian.c:64:  E->mesh.dof = 3;
Regional_geometry_cartesian.c:66:  E->sphere.caps = 1;
Regional_geometry_cartesian.c:67:  E->sphere.max_connections = 6;
Regional_obsolete.c:46:  E->parallel.me = 0;
Regional_obsolete.c:47:  E->parallel.nproc = 1;
Regional_obsolete.c:48:  E->parallel.me_loc[1] = 0;
Regional_obsolete.c:49:  E->parallel.me_loc[2] = 0;
Regional_obsolete.c:50:  E->parallel.me_loc[3] = 0;
Regional_obsolete.c:53:  MPI_Comm_rank(E->parallel.world, &(E->parallel.me) );
Regional_obsolete.c:54:  MPI_Comm_size(E->parallel.world, &(E->parallel.nproc) );
Regional_obsolete.c:81:  const int dims = E->mesh.nsd;
Regional_obsolete.c:89:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:90:    if (E->parallel.me==0) fprintf(stderr,"scatter_to_nlayer should not be called\n");
Regional_obsolete.c:95:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Regional_obsolete.c:97:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:99:    SD = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Regional_obsolete.c:102:    rootid = E->parallel.me_sph*E->parallel.nprocz; /* which is the bottom cpu */
Regional_obsolete.c:104:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:113:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:114:    if (E->parallel.me==rootid)
Regional_obsolete.c:115:      for (d=0;d<E->parallel.nprocz;d++)  {
Regional_obsolete.c:117:        for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Regional_obsolete.c:118:          k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:119:          for (j=1;j<=E->lmesh.NOY[lev];j++)
Regional_obsolete.c:120:            for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Regional_obsolete.c:121:              node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Regional_obsolete.c:122:              node1= k1+ (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Regional_obsolete.c:130:	  MPI_Send(SD,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],rootid,E->parallel.world);
Regional_obsolete.c:133:	  for (i=0;i<=E->lmesh.NEQ[lev];i++)
Regional_obsolete.c:137:      MPI_Recv(AUo[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,rootid,E->parallel.world,&status);
Regional_obsolete.c:153:  const int dims = E->mesh.nsd;
Regional_obsolete.c:161:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:162:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Regional_obsolete.c:167:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Regional_obsolete.c:169:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:171:    RV = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Regional_obsolete.c:174:    rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Regional_obsolete.c:176:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:185:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:186:    if (E->parallel.me!=rootid)
Regional_obsolete.c:187:      MPI_Send(AUi[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,E->parallel.me,E->parallel.world);
Regional_obsolete.c:189:      for (d=0;d<E->parallel.nprocz;d++) {
Regional_obsolete.c:191:	  MPI_Recv(RV,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],processors[d],E->parallel.world,&status);
Regional_obsolete.c:193:	  for (node=0;node<E->lmesh.NEQ[lev];node++)
Regional_obsolete.c:196:	for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Regional_obsolete.c:197:	  k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:198:	  for (j=1;j<=E->lmesh.NOY[lev];j++)
Regional_obsolete.c:199:	    for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Regional_obsolete.c:200:	      node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Regional_obsolete.c:201:	      node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Regional_obsolete.c:229:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:230:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Regional_obsolete.c:235:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Regional_obsolete.c:236:    NNO = NOZ*E->lmesh.NOX[lev]*E->lmesh.NOY[lev];
Regional_obsolete.c:238:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:239:    RV = (float *)malloc((E->lmesh.NNO[lev]+2)*sizeof(float));
Regional_obsolete.c:242:    rootid = E->parallel.me_sph*E->parallel.nprocz; /* which is the bottom cpu */
Regional_obsolete.c:244:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:253:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:254:    if (E->parallel.me!=rootid) {
Regional_obsolete.c:255:      MPI_Send(AUi[m],E->lmesh.NNO[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Regional_obsolete.c:260:      for (d=0;d<E->parallel.nprocz;d++) {
Regional_obsolete.c:262:	  MPI_Recv(RV,E->lmesh.NNO[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Regional_obsolete.c:264:	  for (node=1;node<=E->lmesh.NNO[lev];node++)
Regional_obsolete.c:267:	for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Regional_obsolete.c:268:	  k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:269:	  for (j=1;j<=E->lmesh.NOY[lev];j++)
Regional_obsolete.c:270:	    for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Regional_obsolete.c:271:	      node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Regional_obsolete.c:272:	      node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Regional_obsolete.c:297:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:298:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Regional_obsolete.c:303:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz;
Regional_obsolete.c:304:    NNO = NOZ*E->lmesh.ELX[lev]*E->lmesh.ELY[lev];
Regional_obsolete.c:306:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:307:    RV = (float *)malloc((E->lmesh.NEL[lev]+2)*sizeof(float));
Regional_obsolete.c:310:    rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Regional_obsolete.c:312:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:321:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:322:    if (E->parallel.me!=rootid) {
Regional_obsolete.c:323:      MPI_Send(AUi[m],E->lmesh.NEL[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Regional_obsolete.c:328:      for (d=0;d<E->parallel.nprocz;d++) {
Regional_obsolete.c:330:	  MPI_Recv(RV,E->lmesh.NEL[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Regional_obsolete.c:332:	  for (e=1;e<=E->lmesh.NEL[lev];e++)
Regional_obsolete.c:335:	for (k=1;k<=E->lmesh.ELZ[lev];k++)   {
Regional_obsolete.c:336:	  k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:337:	  for (j=1;j<=E->lmesh.ELY[lev];j++)
Regional_obsolete.c:338:	    for (i=1;i<=E->lmesh.ELX[lev];i++)   {
Regional_obsolete.c:339:	      e = k + (i-1)*E->lmesh.ELZ[lev] + (j-1)*E->lmesh.ELZ[lev]*E->lmesh.ELX[lev];
Regional_obsolete.c:340:	      e1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.ELX[lev];
Regional_obsolete.c:366:  if (E->parallel.nprocxy==1)   return;
Regional_obsolete.c:368:  nsl = E->sphere.nsf+1;
Regional_obsolete.c:369:  me = E->parallel.me;
Regional_obsolete.c:373:    for (i=1;i<E->parallel.nprocxy;i++)
Regional_obsolete.c:374:      RG[i] = ( float *)malloc((E->sphere.nsf+1)*sizeof(float));
Regional_obsolete.c:378:  for (i=1;i<=E->parallel.nprocxy;i++)  {
Regional_obsolete.c:379:    to_everyone = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Regional_obsolete.c:384:      MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Regional_obsolete.c:391:  for (i=1;i<=E->parallel.nprocxy;i++)  {
Regional_obsolete.c:392:    from_proc = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Regional_obsolete.c:396:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Regional_obsolete.c:402:  for (i=1;i<E->parallel.nprocxy;i++)
Regional_obsolete.c:403:    for (j=1;j<=E->sphere.nsf; j++)  {
Regional_obsolete.c:431:  nox=E->lmesh.nox;
Regional_obsolete.c:432:  noz=E->lmesh.noz;
Regional_obsolete.c:433:  noy=E->lmesh.noy;
Regional_obsolete.c:434:  lev=E->mesh.levmax;
Regional_obsolete.c:446:  if(E->advection.timesteps>1)  {
Regional_obsolete.c:447:    fxx1=fxx1+E->advection.timestep*vxx1;
Regional_obsolete.c:448:    fxx2=fxx2+E->advection.timestep*vxx1;
Regional_obsolete.c:458:  if (E->parallel.me_loc[3] == E->parallel.nprocz-1 ) {
Regional_obsolete.c:462:	fyy=E->SX[lev][1][1][nodel];
Regional_obsolete.c:464:	  E->sphere.cap[1].VB[1][nodel]=0.0;
Regional_obsolete.c:465:	  E->sphere.cap[1].VB[2][nodel]=-vvc;
Regional_obsolete.c:466:	  E->sphere.cap[1].VB[3][nodel]=0.0;
Regional_obsolete.c:469:	  if (E->SX[lev][1][2][nodel]>=0.00 && E->SX[lev][1][2][nodel]<= fxx1) {
Regional_obsolete.c:470:	    E->sphere.cap[1].VB[1][nodel]=0.0;
Regional_obsolete.c:471:	    E->sphere.cap[1].VB[2][nodel]=vvo;
Regional_obsolete.c:472:	    E->sphere.cap[1].VB[3][nodel]=0.0;
Regional_obsolete.c:474:	  else if ( E->SX[lev][1][2][nodel]>fxx1 && E->SX[lev][1][2][nodel]<fxx2) {
Regional_obsolete.c:475:	    E->sphere.cap[1].VB[1][nodel]=0.0;
Regional_obsolete.c:476:	    E->sphere.cap[1].VB[2][nodel]=vxx1;
Regional_obsolete.c:477:	    E->sphere.cap[1].VB[3][nodel]=0.0;
Regional_obsolete.c:479:	  else if ( E->SX[lev][1][2][nodel]>=fxx2) {
Regional_obsolete.c:480:	    E->sphere.cap[1].VB[1][nodel]=0.0;
Regional_obsolete.c:481:	    E->sphere.cap[1].VB[2][nodel]=vvc;
Regional_obsolete.c:482:	    E->sphere.cap[1].VB[3][nodel]=0.0;
Regional_obsolete.c:487:  }    /* end of E->parallel.me_loc[3]   */
Regional_obsolete.c:507:  size2= (E->lmesh.nno+1)*sizeof(float);
Regional_obsolete.c:509:  sprintf(output_file,"%s.%05d.SZZ",E->control.data_file,file_number);
Regional_obsolete.c:532:  if (E->parallel.me==proc_loc)  {
Regional_obsolete.c:534:    sprintf(output_file,"%s.%s_intp",E->control.data_file,filen);
Regional_obsolete.c:537:      fprintf(E->fp,"(Output.c #7) Cannot open %s\n",output_file);
Regional_obsolete.c:540:    for (i=E->sphere.nox;i>=1;i--)
Regional_obsolete.c:541:      for (j=1;j<=E->sphere.noy;j++)  {
Regional_obsolete.c:542:        node = i + (j-1)*E->sphere.nox;
Regional_obsolete.c:543:        t = 90-E->sphere.sx[1][node]*rad;
Regional_obsolete.c:544:        f = E->sphere.sx[2][node]*rad;
Regional_obsolete.c:550:    fprintf(E->fp,"lmaxx=%.4e lminx=%.4e for %s\n",maxx,minx,filen);
Regional_obsolete.c:553:    sprintf(output_file,"%s.%s_sharm",E->control.data_file,filen);
Regional_obsolete.c:556:      fprintf(E->fp,"(Output.c #8) Cannot open %s\n",output_file);
Regional_obsolete.c:561:    for (ll=0;ll<=E->output.llmax;ll++)
Regional_obsolete.c:563:        i = E->sphere.hindex[ll][mm];
Regional_obsolete.c:590:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)      {
Regional_obsolete.c:591:    sprintf(output_file,"%s.surf.%d.%d",E->control.data_file,E->parallel.me,cycles);
Regional_obsolete.c:594:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Regional_obsolete.c:595:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Regional_obsolete.c:596:      for(i=1;i<=E->lmesh.nsf;i++)   {
Regional_obsolete.c:597:	s = i*E->lmesh.noz;
Regional_obsolete.c:598:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpg[j][i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Regional_obsolete.c:605:  if (E->parallel.me_loc[3]==0)      {
Regional_obsolete.c:606:    sprintf(output_file,"%s.botm.%d.%d",E->control.data_file,E->parallel.me,cycles);
Regional_obsolete.c:609:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Regional_obsolete.c:610:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Regional_obsolete.c:611:      for(i=1;i<=E->lmesh.nsf;i++)  {
Regional_obsolete.c:612:	s = (i-1)*E->lmesh.noz + 1;
Regional_obsolete.c:613:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Regional_obsolete.c:620:/*    if (E->parallel.me<E->parallel.nprocz)  { */
Regional_obsolete.c:621:/*      sprintf(output_file,"%s.ave_r.%d.%d",E->control.data_file,E->parallel.me,cycles); */
Regional_obsolete.c:624:/*            fprintf(E->fp,"(Output.c #6) Cannot open %s\n",output_file); */
Regional_obsolete.c:627:/*      for(j=1;j<=E->lmesh.noz;j++)  { */
Regional_obsolete.c:628:/*          fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]); */
Regional_obsolete.c:656:  const int lev = E->mesh.levmax;
Regional_obsolete.c:657:  const int nsd = E->mesh.nsd;
Regional_obsolete.c:663:  // E->sphere.caps_per_proc. Later, when elemental viscosity is written
Regional_obsolete.c:670:  int size2 = (E->lmesh.nel+1)*sizeof(float);
Regional_obsolete.c:673:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:674:    VN[m]=(float *)malloc((1+E->lmesh.nel*vpts)*sizeof(float));
Regional_obsolete.c:679:  for(i=1;i<=E->lmesh.nel;i++)
Regional_obsolete.c:686:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:701:  sprintf(output_file,"%s.visc.%d.%d",E->control.data_file,E->parallel.me,cycles);
Regional_obsolete.c:704:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:705:    VE[m]=(float *)malloc((1+E->lmesh.nno)*sizeof(float));
Regional_obsolete.c:710:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Regional_obsolete.c:711:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Regional_obsolete.c:712:    for(i=1;i<=E->lmesh.nno;i++)
Regional_obsolete.c:716:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:740:    record_h = E->control.record_every/10;  */
Regional_obsolete.c:741:    record_h = E->control.record_every;
Regional_obsolete.c:744:/*    if ( ((ii % record_h) == 0) || E->control.DIRECTII)    { */
Regional_obsolete.c:746:    if ( (ii == 0) || ((ii % record_h) == 0) || E->control.DIRECTII)    {
Regional_obsolete.c:752:/*    if ( ((ii % E->control.record_every) == 0) || E->control.DIRECTII)  { */
Regional_obsolete.c:753:    if ( ((ii == 0) || ((ii % E->control.record_every) == 0))
Regional_obsolete.c:754:		|| E->control.DIRECTII)     {
Regional_obsolete.c:777:    if ( (ii == 0) || ((ii % E->control.record_every) == 0)
Regional_obsolete.c:778:		|| E->control.DIRECTII)     {
Regional_obsolete.c:779:      get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,ii);
Regional_obsolete.c:798:  const int dims=E->mesh.nsd;
Regional_obsolete.c:800:  const int nno=E->lmesh.nno;
Regional_obsolete.c:802:  lev = E->mesh.levmax;
Regional_obsolete.c:804:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Regional_obsolete.c:806:      if (node%E->lmesh.noz==0)   {
Regional_obsolete.c:807:        i = node/E->lmesh.noz;
Regional_obsolete.c:808:        SV[(i-1)*2+1] = E->sphere.cap[m].V[1][node];
Regional_obsolete.c:809:        SV[(i-1)*2+2] = E->sphere.cap[m].V[2][node];
Regional_parallel_related.c:54:  me = E->parallel.me;
Regional_parallel_related.c:56:  surf_proc_per_cap = E->parallel.nprocx * E->parallel.nprocy;
Regional_parallel_related.c:57:  proc_per_cap = surf_proc_per_cap * E->parallel.nprocz;
Regional_parallel_related.c:58:  total_proc = E->sphere.caps * proc_per_cap;
Regional_parallel_related.c:59:  E->parallel.total_surf_proc = E->sphere.caps * surf_proc_per_cap;
Regional_parallel_related.c:61:  if ( total_proc != E->parallel.nproc ) {
Regional_parallel_related.c:62:    if (E->parallel.me==0) fprintf(stderr,"!!!! # of requested CPU is incorrect \n");
Regional_parallel_related.c:68:  j = me % E->parallel.nprocz;
Regional_parallel_related.c:69:  E->parallel.me_loc[3] = j;
Regional_parallel_related.c:72:  k = (me - j)/E->parallel.nprocz % E->parallel.nprocx;
Regional_parallel_related.c:73:  E->parallel.me_loc[1] = k;
Regional_parallel_related.c:76:  i = ((me - j)/E->parallel.nprocz - k)/E->parallel.nprocx % E->parallel.nprocy;
Regional_parallel_related.c:77:  E->parallel.me_loc[2] = i;
Regional_parallel_related.c:79:  E->sphere.caps_per_proc = 1;
Regional_parallel_related.c:82:  pid_surf = me/E->parallel.nprocz;
Regional_parallel_related.c:83:  i = cases[E->sphere.caps_per_proc];
Regional_parallel_related.c:85:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Regional_parallel_related.c:86:    E->sphere.capid[j] = 1;
Regional_parallel_related.c:90:  E->parallel.loc2proc_map = (int ****) malloc(E->sphere.caps*sizeof(int ***));
Regional_parallel_related.c:91:  for (m=0;m<E->sphere.caps;m++)  {
Regional_parallel_related.c:92:    E->parallel.loc2proc_map[m] = (int ***) malloc(E->parallel.nprocx*sizeof(int **));
Regional_parallel_related.c:93:    for (i=0;i<E->parallel.nprocx;i++) {
Regional_parallel_related.c:94:      E->parallel.loc2proc_map[m][i] = (int **) malloc(E->parallel.nprocy*sizeof(int *));
Regional_parallel_related.c:95:      for (j=0;j<E->parallel.nprocy;j++)
Regional_parallel_related.c:96:	E->parallel.loc2proc_map[m][i][j] = (int *) malloc(E->parallel.nprocz*sizeof(int));
Regional_parallel_related.c:100:  for (m=0;m<E->sphere.caps;m++)
Regional_parallel_related.c:101:    for (i=0;i<E->parallel.nprocx;i++)
Regional_parallel_related.c:102:      for (j=0;j<E->parallel.nprocy;j++)
Regional_parallel_related.c:103:	for (k=0;k<E->parallel.nprocz;k++) {
Regional_parallel_related.c:104:	    E->parallel.loc2proc_map[m][i][j][k] = m*proc_per_cap
Regional_parallel_related.c:105:	      + j*E->parallel.nprocx*E->parallel.nprocz
Regional_parallel_related.c:106:	      + i*E->parallel.nprocz + k;
Regional_parallel_related.c:109:  if (E->control.verbose) {
Regional_parallel_related.c:110:    fprintf(E->fp_out,"me=%d loc1=%d loc2=%d loc3=%d\n",me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3]);
Regional_parallel_related.c:111:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Regional_parallel_related.c:112:      fprintf(E->fp_out,"capid[%d]=%d \n",j,E->sphere.capid[j]);
Regional_parallel_related.c:114:    for (m=0;m<E->sphere.caps;m++)
Regional_parallel_related.c:115:      for (j=0;j<E->parallel.nprocy;j++)
Regional_parallel_related.c:116:	for (i=0;i<E->parallel.nprocx;i++)
Regional_parallel_related.c:117:	  for (k=0;k<E->parallel.nprocz;k++)
Regional_parallel_related.c:118:	    fprintf(E->fp_out,"loc2proc_map[cap=%d][x=%d][y=%d][z=%d] = %d\n",
Regional_parallel_related.c:119:		    m,i,j,k,E->parallel.loc2proc_map[m][i][j][k]);
Regional_parallel_related.c:121:    fflush(E->fp_out);
Regional_parallel_related.c:127:  E->exchange_node_d = exchange_node_d;
Regional_parallel_related.c:128:  E->exchange_node_f = exchange_node_f;
Regional_parallel_related.c:140:  processors = (int *) malloc((E->parallel.total_surf_proc+1)*sizeof(int));
Regional_parallel_related.c:142:  k = E->parallel.me_loc[3];
Regional_parallel_related.c:144:  for (m=0;m<E->sphere.caps;m++)
Regional_parallel_related.c:145:    for (i=0;i<E->parallel.nprocx;i++)
Regional_parallel_related.c:146:      for (j=0;j<E->parallel.nprocy;j++) {
Regional_parallel_related.c:147:	processors[n] = E->parallel.loc2proc_map[m][i][j][k];
Regional_parallel_related.c:151:  if (E->control.verbose) {
Regional_parallel_related.c:152:    fprintf(E->fp_out,"horizontal group of me=%d loc3=%d\n",E->parallel.me,E->parallel.me_loc[3]);
Regional_parallel_related.c:153:    for (j=0;j<E->parallel.total_surf_proc;j++) {
Regional_parallel_related.c:154:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Regional_parallel_related.c:156:    fflush(E->fp_out);
Regional_parallel_related.c:159:  MPI_Comm_group(E->parallel.world, &world_g);
Regional_parallel_related.c:160:  MPI_Group_incl(world_g, E->parallel.total_surf_proc, processors, &horizon_g);
Regional_parallel_related.c:161:  MPI_Comm_create(E->parallel.world, horizon_g, &(E->parallel.horizontal_comm));
Regional_parallel_related.c:178:  processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_parallel_related.c:182:  m = E->sphere.capid[1] - 1;  /* assume 1 cap per proc. */
Regional_parallel_related.c:183:  i = E->parallel.me_loc[1];
Regional_parallel_related.c:184:  j = E->parallel.me_loc[2];
Regional_parallel_related.c:186:  for (k=0;k<E->parallel.nprocz;k++) {
Regional_parallel_related.c:187:      processors[k] = E->parallel.loc2proc_map[m][i][j][k];
Regional_parallel_related.c:190:  if (E->control.verbose) {
Regional_parallel_related.c:191:    fprintf(E->fp_out,"vertical group of me=%d loc1=%d loc2=%d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2]);
Regional_parallel_related.c:192:    for (k=0;k<E->parallel.nprocz;k++) {
Regional_parallel_related.c:193:      fprintf(E->fp_out,"%d proc=%d\n",k,processors[k]);
Regional_parallel_related.c:195:    fflush(E->fp_out);
Regional_parallel_related.c:198:  MPI_Comm_group(E->parallel.world, &world_g);
Regional_parallel_related.c:199:  MPI_Group_incl(world_g, E->parallel.nprocz, processors, &vertical_g);
Regional_parallel_related.c:200:  MPI_Comm_create(E->parallel.world, vertical_g, &(E->parallel.vertical_comm));
Regional_parallel_related.c:218:  me = E->parallel.me;
Regional_parallel_related.c:220:  E->lmesh.elx = E->mesh.elx/E->parallel.nprocx;
Regional_parallel_related.c:221:  E->lmesh.elz = E->mesh.elz/E->parallel.nprocz;
Regional_parallel_related.c:222:  E->lmesh.ely = E->mesh.ely/E->parallel.nprocy;
Regional_parallel_related.c:223:  E->lmesh.nox = E->lmesh.elx + 1;
Regional_parallel_related.c:224:  E->lmesh.noz = E->lmesh.elz + 1;
Regional_parallel_related.c:225:  E->lmesh.noy = E->lmesh.ely + 1;
Regional_parallel_related.c:227:  E->lmesh.exs = E->parallel.me_loc[1]*E->lmesh.elx;
Regional_parallel_related.c:228:  E->lmesh.eys = E->parallel.me_loc[2]*E->lmesh.ely;
Regional_parallel_related.c:229:  E->lmesh.ezs = E->parallel.me_loc[3]*E->lmesh.elz;
Regional_parallel_related.c:230:  E->lmesh.nxs = E->parallel.me_loc[1]*E->lmesh.elx+1;
Regional_parallel_related.c:231:  E->lmesh.nys = E->parallel.me_loc[2]*E->lmesh.ely+1;
Regional_parallel_related.c:232:  E->lmesh.nzs = E->parallel.me_loc[3]*E->lmesh.elz+1;
Regional_parallel_related.c:234:  E->lmesh.nno = E->lmesh.noz*E->lmesh.nox*E->lmesh.noy;
Regional_parallel_related.c:235:  E->lmesh.nel = E->lmesh.ely*E->lmesh.elx*E->lmesh.elz;
Regional_parallel_related.c:236:  E->lmesh.npno = E->lmesh.nel;
Regional_parallel_related.c:238:  E->lmesh.nsf = E->lmesh.nno/E->lmesh.noz;
Regional_parallel_related.c:239:  E->lmesh.snel = E->lmesh.elx*E->lmesh.ely;
Regional_parallel_related.c:242:  for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)   {
Regional_parallel_related.c:244:     if (E->control.NMULTIGRID)  {
Regional_parallel_related.c:245:        nox = E->mesh.mgunitx * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:246:        noy = E->mesh.mgunity * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:247:        noz = E->lmesh.elz/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Regional_parallel_related.c:248:        E->parallel.redundant[i]=0;
Regional_parallel_related.c:251:        { noz = E->lmesh.noz;
Regional_parallel_related.c:252:          noy = E->mesh.mgunity * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:253:          nox = E->mesh.mgunitx * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:254:          if(i<E->mesh.levmax) noz=2;
Regional_parallel_related.c:257:     E->lmesh.ELX[i] = nox-1;
Regional_parallel_related.c:258:     E->lmesh.ELY[i] = noy-1;
Regional_parallel_related.c:259:     E->lmesh.ELZ[i] = noz-1;
Regional_parallel_related.c:260:     E->lmesh.NOZ[i] = noz;
Regional_parallel_related.c:261:     E->lmesh.NOY[i] = noy;
Regional_parallel_related.c:262:     E->lmesh.NOX[i] = nox;
Regional_parallel_related.c:263:     E->lmesh.NNO[i] = nox * noz * noy;
Regional_parallel_related.c:264:     E->lmesh.NNOV[i] = E->lmesh.NNO[i];
Regional_parallel_related.c:265:     E->lmesh.SNEL[i] = E->lmesh.ELX[i]*E->lmesh.ELY[i];
Regional_parallel_related.c:267:     E->lmesh.NEL[i] = (nox-1) * (noz-1) * (noy-1);
Regional_parallel_related.c:268:     E->lmesh.NPNO[i] = E->lmesh.NEL[i] ;
Regional_parallel_related.c:270:     E->lmesh.NEQ[i] = E->mesh.nsd * E->lmesh.NNOV[i] ;
Regional_parallel_related.c:272:     E->lmesh.EXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i];
Regional_parallel_related.c:273:     E->lmesh.EYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i];
Regional_parallel_related.c:274:     E->lmesh.EZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i];
Regional_parallel_related.c:275:     E->lmesh.NXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i]+1;
Regional_parallel_related.c:276:     E->lmesh.NYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i]+1;
Regional_parallel_related.c:277:     E->lmesh.NZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i]+1;
Regional_parallel_related.c:282:fprintf(stderr,"b %d %d %d %d %d %d %d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3],E->lmesh.nzs,E->lmesh.nys,E->lmesh.noy);
Regional_parallel_related.c:308:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)   {
Regional_parallel_related.c:309:    for(m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_parallel_related.c:310:      nel = E->lmesh.NEL[lev];
Regional_parallel_related.c:311:      elx = E->lmesh.ELX[lev];
Regional_parallel_related.c:312:      elz = E->lmesh.ELZ[lev];
Regional_parallel_related.c:313:      ely = E->lmesh.ELY[lev];
Regional_parallel_related.c:314:      nox = E->lmesh.NOX[lev];
Regional_parallel_related.c:315:      noy = E->lmesh.NOY[lev];
Regional_parallel_related.c:316:      noz = E->lmesh.NOZ[lev];
Regional_parallel_related.c:317:      nno = E->lmesh.NNO[lev];
Regional_parallel_related.c:325:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Regional_parallel_related.c:326:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:329:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:337:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Regional_parallel_related.c:338:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:341:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:350:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Regional_parallel_related.c:351:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:354:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:361:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Regional_parallel_related.c:362:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:365:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:374:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Regional_parallel_related.c:375:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:378:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:385:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Regional_parallel_related.c:386:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:389:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:393:    if (E->parallel.me_loc[1]!=E->parallel.nprocx-1)
Regional_parallel_related.c:394:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[2];lnode++) {
Regional_parallel_related.c:395:        node = E->parallel.NODE[lev][m][lnode].bound[2];
Regional_parallel_related.c:396:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Regional_parallel_related.c:399:    if (E->parallel.me_loc[2]!=E->parallel.nprocy-1)
Regional_parallel_related.c:400:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[4];lnode++) {
Regional_parallel_related.c:401:        node = E->parallel.NODE[lev][m][lnode].bound[4];
Regional_parallel_related.c:402:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Regional_parallel_related.c:405:    if (E->parallel.me_loc[3]!=E->parallel.nprocz-1)
Regional_parallel_related.c:406:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[6];lnode++) {
Regional_parallel_related.c:407:        node = E->parallel.NODE[lev][m][lnode].bound[6];
Regional_parallel_related.c:408:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Regional_parallel_related.c:415:if (E->control.verbose) {
Regional_parallel_related.c:416: fprintf(E->fp_out,"output_shared_nodes %d \n",E->parallel.me);
Regional_parallel_related.c:417: for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Regional_parallel_related.c:418:   for (m=1;m<=E->sphere.caps_per_proc;m++)      {
Regional_parallel_related.c:419:    fprintf(E->fp_out,"lev=%d  me=%d capid=%d m=%d \n",lev,E->parallel.me,E->sphere.capid[m],m);
Regional_parallel_related.c:421:      for (i=1;i<=E->parallel.NUM_NNO[lev][m].bound[ii];i++)
Regional_parallel_related.c:422:        fprintf(E->fp_out,"ii=%d   %d %d \n",ii,i,E->parallel.NODE[lev][m][i].bound[ii]);
Regional_parallel_related.c:425:    for (node=1;node<=E->lmesh.NNO[lev];node++)
Regional_parallel_related.c:426:      if((E->NODE[lev][m][node] & SKIP)) {
Regional_parallel_related.c:428:        fprintf(E->fp_out,"skip %d %d \n",lnode,node);
Regional_parallel_related.c:431: fflush(E->fp_out);
Regional_parallel_related.c:458:  const int dims=E->mesh.nsd;
Regional_parallel_related.c:460:  me = E->parallel.me;
Regional_parallel_related.c:461:  nproczl = E->parallel.nprocz;
Regional_parallel_related.c:462:  nprocyl = E->parallel.nprocy;
Regional_parallel_related.c:463:  nprocxl = E->parallel.nprocx;
Regional_parallel_related.c:464:  lx = E->parallel.me_loc[1];
Regional_parallel_related.c:465:  ly = E->parallel.me_loc[2];
Regional_parallel_related.c:466:  lz = E->parallel.me_loc[3];
Regional_parallel_related.c:469:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Regional_parallel_related.c:470:    nox = E->lmesh.NOX[lev];
Regional_parallel_related.c:471:    noz = E->lmesh.NOZ[lev];
Regional_parallel_related.c:472:    noy = E->lmesh.NOY[lev];
Regional_parallel_related.c:477:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:478:      cap = E->sphere.capid[m] - 1;  /* which cap I am in (0~11) */
Regional_parallel_related.c:483:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Regional_parallel_related.c:484:        if(E->parallel.me_loc[1]==0 && i==1)
Regional_parallel_related.c:485:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:486:        else if(E->parallel.me_loc[1]==nprocxl-1 && i==2)
Regional_parallel_related.c:487:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:489:        if (E->parallel.NUM_PASS[lev][m].bound[ii] == 1)  {
Regional_parallel_related.c:493:          /*E->parallel.PROCESSOR[lev][m].pass[kkk]=me-((i==1)?1:-1)*nproczl; */
Regional_parallel_related.c:495:          E->parallel.PROCESSOR[lev][m].pass[kkk]=E->parallel.loc2proc_map[cap][lx-dir][ly][lz];
Regional_parallel_related.c:497:              E->parallel.NUM_NODE[lev][m].pass[kkk] = E->parallel.NUM_NNO[lev][m].bound[ii];
Regional_parallel_related.c:499:          for (k=1;k<=E->parallel.NUM_NODE[lev][m].pass[kkk];k++)   {
Regional_parallel_related.c:501:            node = E->parallel.NODE[lev][m][lnode].bound[ii];
Regional_parallel_related.c:502:            E->parallel.EXCHANGE_NODE[lev][m][k].pass[kkk] = node;
Regional_parallel_related.c:506:                         E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkk] = E->ID[lev][m][node].doff[doff];
Regional_parallel_related.c:509:              E->parallel.NUM_NEQ[lev][m].pass[kkk] = jj;
Regional_parallel_related.c:517:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Regional_parallel_related.c:518:        if(E->parallel.me_loc[2]==0 && k==1)
Regional_parallel_related.c:519:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:520:        else if(E->parallel.me_loc[2]==nprocyl-1 && k==2)
Regional_parallel_related.c:521:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:523:        if(E->parallel.NUM_PASS[lev][m].bound[ii] == 1)  {
Regional_parallel_related.c:528:          /*E->parallel.PROCESSOR[lev][m].pass[kkk]=me-((k==1)?1:-1)*nprocxl*nproczl; */
Regional_parallel_related.c:530:          E->parallel.PROCESSOR[lev][m].pass[kkk]=E->parallel.loc2proc_map[cap][lx][ly-dir][lz];
Regional_parallel_related.c:532:          E->parallel.NUM_NODE[lev][m].pass[kkk] = E->parallel.NUM_NNO[lev][m].bound[ii];
Regional_parallel_related.c:535:          for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[kkk];kk++)   {
Regional_parallel_related.c:537:            node = E->parallel.NODE[lev][m][lnode].bound[ii];
Regional_parallel_related.c:538:            E->parallel.EXCHANGE_NODE[lev][m][kk].pass[kkk] = node;
Regional_parallel_related.c:541:                         E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkk] = E->ID[lev][m][node].doff[doff];
Regional_parallel_related.c:544:              E->parallel.NUM_NEQ[lev][m].pass[kkk] = jj;
Regional_parallel_related.c:553:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Regional_parallel_related.c:554:        if(E->parallel.me_loc[3]==0 && j==1)
Regional_parallel_related.c:555:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:556:        else if(E->parallel.me_loc[3]==nproczl-1 && j==2)
Regional_parallel_related.c:557:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:559:        if(E->parallel.NUM_PASS[lev][m].bound[ii] == 1)  {
Regional_parallel_related.c:563:          /*E->parallel.PROCESSOR[lev][m].pass[kkk]=me-((j==1)?1:-1);*/
Regional_parallel_related.c:565:          E->parallel.PROCESSOR[lev][m].pass[kkk]=E->parallel.loc2proc_map[cap][lx][ly][lz-dir];
Regional_parallel_related.c:567:          E->parallel.NUM_NODE[lev][m].pass[kkk] = E->parallel.NUM_NNO[lev][m].bound[ii];
Regional_parallel_related.c:570:          for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[kkk];kk++)   {
Regional_parallel_related.c:572:            node = E->parallel.NODE[lev][m][lnode].bound[ii];
Regional_parallel_related.c:573:            E->parallel.EXCHANGE_NODE[lev][m][kk].pass[kkk] = node;
Regional_parallel_related.c:576:                         E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkk] = E->ID[lev][m][node].doff[doff];
Regional_parallel_related.c:579:              E->parallel.NUM_NEQ[lev][m].pass[kkk] = jj;
Regional_parallel_related.c:586:      E->parallel.TNUM_PASS[lev][m] = kkk;
Regional_parallel_related.c:593:  if(E->control.verbose) {
Regional_parallel_related.c:594:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Regional_parallel_related.c:595:      fprintf(E->fp_out,"output_communication route surface for lev=%d \n",lev);
Regional_parallel_related.c:596:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Regional_parallel_related.c:597:    fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",E->parallel.me,E->sphere.capid[m],E->parallel.TNUM_PASS[lev][m]);
Regional_parallel_related.c:598:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Regional_parallel_related.c:599:      fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d eqn and %d node\n",E->parallel.me,k,E->parallel.PROCESSOR[lev][m].pass[k],E->parallel.NUM_NEQ[lev][m].pass[k],E->parallel.NUM_NODE[lev][m].pass[k]);
Regional_parallel_related.c:600:/*    fprintf(E->fp_out,"Eqn:\n");  */
Regional_parallel_related.c:601:/*    for (ii=1;ii<=E->parallel.NUM_NEQ[lev][m].pass[k];ii++)  */
Regional_parallel_related.c:602:/*      fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_ID[lev][m][ii].pass[k]);  */
Regional_parallel_related.c:603:/*    fprintf(E->fp_out,"Node:\n");  */
Regional_parallel_related.c:604:/*    for (ii=1;ii<=E->parallel.NUM_NODE[lev][m].pass[k];ii++)  */
Regional_parallel_related.c:605:/*      fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_NODE[lev][m][ii].pass[k]);  */
Regional_parallel_related.c:610:    fflush(E->fp_out);
Regional_parallel_related.c:634:  const int dims=E->mesh.nsd;
Regional_parallel_related.c:636:  me = E->parallel.me;
Regional_parallel_related.c:637:  nprocz = E->parallel.nprocz;
Regional_parallel_related.c:639:  nprocxl = E->parallel.nprocx;
Regional_parallel_related.c:640:  nprocyl = E->parallel.nprocy;
Regional_parallel_related.c:641:  nproczl = E->parallel.nprocz;
Regional_parallel_related.c:645:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Regional_parallel_related.c:646:    nox = E->lmesh.NOX[lev];
Regional_parallel_related.c:647:    noz = E->lmesh.NOZ[lev];
Regional_parallel_related.c:648:    noy = E->lmesh.NOY[lev];
Regional_parallel_related.c:652:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:657:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Regional_parallel_related.c:658:        if(E->parallel.me_loc[1]==0 && i==1)
Regional_parallel_related.c:659:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:660:        else if(E->parallel.me_loc[1]==nprocxl-1 && i==2)
Regional_parallel_related.c:661:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:663:        for (p=1;p<=E->parallel.NUM_PASS[lev][m].bound[ii];p++)  {
Regional_parallel_related.c:667:          E->parallel.sPROCESSOR[lev][m].pass[kkk]=me-((i==1)?1:-1)*nproczl;
Regional_parallel_related.c:669:              E->parallel.NUM_sNODE[lev][m].pass[kkk] =
Regional_parallel_related.c:670:                          E->parallel.NUM_NNO[lev][m].bound[ii]/noz;
Regional_parallel_related.c:671:          for (k=1;k<=E->parallel.NUM_sNODE[lev][m].pass[kkk];k++)   {
Regional_parallel_related.c:673:            node = (E->parallel.NODE[lev][m][lnode].bound[ii]-1)/noz+1;
Regional_parallel_related.c:674:            E->parallel.EXCHANGE_sNODE[lev][m][k].pass[kkk] = node;
Regional_parallel_related.c:684:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Regional_parallel_related.c:685:        if(E->parallel.me_loc[2]==0 && k==1)
Regional_parallel_related.c:686:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:687:        else if(E->parallel.me_loc[2]==nprocyl-1 && k==2)
Regional_parallel_related.c:688:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:690:        for (p=1;p<=E->parallel.NUM_PASS[lev][m].bound[ii];p++)  {
Regional_parallel_related.c:695:          E->parallel.sPROCESSOR[lev][m].pass[kkk]=me-((k==1)?1:-1)*nprocxl*nproczl;
Regional_parallel_related.c:697:              E->parallel.NUM_sNODE[lev][m].pass[kkk] =
Regional_parallel_related.c:698:                          E->parallel.NUM_NNO[lev][m].bound[ii]/noz;
Regional_parallel_related.c:700:          for (kk=1;kk<=E->parallel.NUM_sNODE[lev][m].pass[kkk];kk++)   {
Regional_parallel_related.c:702:            node = (E->parallel.NODE[lev][m][lnode].bound[ii]-1)/noz+1;
Regional_parallel_related.c:703:            E->parallel.EXCHANGE_sNODE[lev][m][kk].pass[kkk] = node;
Regional_parallel_related.c:711:    E->parallel.sTNUM_PASS[lev][m] = kkk;
Regional_parallel_related.c:726:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:727:     for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:729:       sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Regional_parallel_related.c:756: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:757:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:758:     sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Regional_parallel_related.c:764: for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_parallel_related.c:765:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:767:     for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Regional_parallel_related.c:768:       S[k][j-1] = U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ];
Regional_parallel_related.c:770:     MPI_Sendrecv(S[k],E->parallel.NUM_NEQ[lev][m].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:771:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:772:		  R[k],E->parallel.NUM_NEQ[lev][m].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:773:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:774:		  E->parallel.world,&status);
Regional_parallel_related.c:776:     for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Regional_parallel_related.c:777:       U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c:782: for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_parallel_related.c:783: for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:806: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:807:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:808:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(double);
Regional_parallel_related.c:814: for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Regional_parallel_related.c:815:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Regional_parallel_related.c:817:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Regional_parallel_related.c:818:       S[k][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Regional_parallel_related.c:820:     MPI_Sendrecv(S[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:821:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:822:		  R[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:823:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:824:		  E->parallel.world,&status);
Regional_parallel_related.c:826:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Regional_parallel_related.c:827:       U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c:831: for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_parallel_related.c:832: for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:855: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:856:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:857:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(float);
Regional_parallel_related.c:864: for (m=1;m<=E->sphere.caps_per_proc;m++)     {
Regional_parallel_related.c:865:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Regional_parallel_related.c:867:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Regional_parallel_related.c:868:       S[k][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Regional_parallel_related.c:870:     MPI_Sendrecv(S[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Regional_parallel_related.c:871:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:872:		  R[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Regional_parallel_related.c:873:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:874:		  E->parallel.world,&status);
Regional_parallel_related.c:876:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Regional_parallel_related.c:877:       U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c:882: for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_parallel_related.c:883: for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:904: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:905:   for (k=1;k<=E->parallel.sTNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:906:     sizeofk = (1+2*E->parallel.NUM_sNODE[lev][m].pass[k])*sizeof(float);
Regional_parallel_related.c:912: for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_parallel_related.c:913:   for (k=1;k<=E->parallel.sTNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:915:     for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)  {
Regional_parallel_related.c:916:       S[k][j-1] = U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Regional_parallel_related.c:917:       S[k][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]]
Regional_parallel_related.c:918:	 = U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Regional_parallel_related.c:921:     MPI_Sendrecv(S[k],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Regional_parallel_related.c:922:		  E->parallel.sPROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:923:		  R[k],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Regional_parallel_related.c:924:		  E->parallel.sPROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:925:		  E->parallel.world,&status);
Regional_parallel_related.c:927:     for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)   {
Regional_parallel_related.c:928:       U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c:929:       U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] +=
Regional_parallel_related.c:930:	 R[k][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]];
Regional_parallel_related.c:936: for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_parallel_related.c:937: for (k=1;k<=E->parallel.sTNUM_PASS[lev][m];k++)  {
Regional_read_input_from_files.c:57:    const int dims=E->mesh.nsd;
Regional_read_input_from_files.c:66:    /*if( E->parallel.me == 0)  
Regional_read_input_from_files.c:69:    nox=E->mesh.nox;
Regional_read_input_from_files.c:70:    noy=E->mesh.noy;
Regional_read_input_from_files.c:71:    noz=E->mesh.noz;
Regional_read_input_from_files.c:73:    nox1=E->lmesh.nox;
Regional_read_input_from_files.c:74:    noz1=E->lmesh.noz;
Regional_read_input_from_files.c:75:    noy1=E->lmesh.noy;
Regional_read_input_from_files.c:78:    elx=E->lmesh.elx;
Regional_read_input_from_files.c:79:    elz=E->lmesh.elz;
Regional_read_input_from_files.c:80:    ely=E->lmesh.ely;
Regional_read_input_from_files.c:82:    emax=E->mesh.elx*E->mesh.elz*E->mesh.ely;
Regional_read_input_from_files.c:102:      if(!E->control.ggrd.vtop_control){	/* regular input */
Regional_read_input_from_files.c:104:      sprintf(output_file1,"%s%0.0f",E->control.velocity_boundary_file,newage1);
Regional_read_input_from_files.c:105:      sprintf(output_file2,"%s%0.0f",E->control.velocity_boundary_file,newage2);
Regional_read_input_from_files.c:108:          fprintf(E->fp,"(Problem_related #4) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:114:          fprintf(E->fp,"(Problem_related #5) Cannot open %s\n",output_file2);
Regional_read_input_from_files.c:118:      if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:119:         fprintf(E->fp,"Velocity: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:120:         fprintf(E->fp,"Velocity: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:122:           fprintf(E->fp,"Velocity: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:124:           fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:133:      if(!E->control.ggrd.age_control){	/* regular input */
Regional_read_input_from_files.c:135:        sprintf(output_file1,"%s%0.0f",E->control.lith_age_file,newage1);
Regional_read_input_from_files.c:136:        sprintf(output_file2,"%s%0.0f",E->control.lith_age_file,newage2);
Regional_read_input_from_files.c:139:          fprintf(E->fp,"(Problem_related #6) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:145:            fprintf(E->fp,"(Problem_related #7) Cannot open %s\n",output_file2);            exit(8);
Regional_read_input_from_files.c:148:        if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:149:          fprintf(E->fp,"Age: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:150:          fprintf(E->fp,"Age: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:152:            fprintf(E->fp,"Age: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:154:            fprintf(E->fp,"Age: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:163:	if(E->control.ggrd.mat_control == 0 ){
Regional_read_input_from_files.c:165:        sprintf(output_file1,"%s%0.0f.0",E->control.mat_file,newage1);
Regional_read_input_from_files.c:166:        sprintf(output_file2,"%s%0.0f.0",E->control.mat_file,newage2);
Regional_read_input_from_files.c:169:          fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:175:            fprintf(E->fp,"(Problem_related #9) Cannot open %s\n",output_file2);
Regional_read_input_from_files.c:179:        if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:180:          fprintf(E->fp,"Mat: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:181:          fprintf(E->fp,"Mat: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:183:            fprintf(E->fp,"Mat: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:185:            fprintf(E->fp,"Mat: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:196:        sprintf(output_file1,"%s%0.0f",E->control.temperature_boundary_file,newage1);
Regional_read_input_from_files.c:197:        sprintf(output_file2,"%s%0.0f",E->control.temperature_boundary_file,newage2);
Regional_read_input_from_files.c:200:            fprintf(E->fp,"(Problem_related #10) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:206:            fprintf(E->fp,"(Problem_related #11) Cannot open %s\n",output_file2);
Regional_read_input_from_files.c:210:        if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:211:           fprintf(E->fp,"Surface Temperature: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:212:           fprintf(E->fp,"Surface Temperature: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:214:             fprintf(E->fp,"Surface Temperature: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:216:             fprintf(E->fp,"Surface Temperature: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:230:      if(!E->control.ggrd.vtop_control){ /* grd control is called from boundary condition file */
Regional_read_input_from_files.c:242:         VB1[1][i]=E->data.timedir*VB1[1][i];
Regional_read_input_from_files.c:243:         VB1[2][i]=E->data.timedir*VB1[2][i];
Regional_read_input_from_files.c:249:             VB2[1][i]=E->data.timedir*VB2[1][i];
Regional_read_input_from_files.c:250:             VB2[2][i]=E->data.timedir*VB2[2][i];
Regional_read_input_from_files.c:256:      if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Regional_read_input_from_files.c:259:                nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Regional_read_input_from_files.c:262:                    E->sphere.cap[1].VB[1][nodel] = (VB1[1][nodeg] + (VB2[1][nodeg]-VB1[1][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Regional_read_input_from_files.c:263:                    E->sphere.cap[1].VB[2][nodel] = (VB1[2][nodeg] + (VB2[2][nodeg]-VB1[2][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Regional_read_input_from_files.c:264:                    E->sphere.cap[1].VB[3][nodel] = 0.0;
Regional_read_input_from_files.c:267:                    E->sphere.cap[1].VB[1][nodel] = VB1[1][nodeg]*E->data.scalev;
Regional_read_input_from_files.c:268:                    E->sphere.cap[1].VB[2][nodel] = VB1[2][nodeg]*E->data.scalev;
Regional_read_input_from_files.c:269:                    E->sphere.cap[1].VB[3][nodel] = 0.0;
Regional_read_input_from_files.c:272:      }   /* end of E->parallel.me_loc[3]==E->parallel.nprocz-1   */
Regional_read_input_from_files.c:286:	if(E->control.ggrd.age_control){
Regional_read_input_from_files.c:302:              E->age_t[node] = (inputage1 + (inputage2-inputage1)/(newage2-newage1)*(age-newage1))/E->data.scalet;
Regional_read_input_from_files.c:305:              E->age_t[node] = inputage1;
Regional_read_input_from_files.c:317:	if(E->control.ggrd.mat_control != 0){
Regional_read_input_from_files.c:328:            nodea = E->ien[1][el].node[2];
Regional_read_input_from_files.c:331:              E->mat[1][el] = llayer;
Regional_read_input_from_files.c:353:                el = j + (i-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Regional_read_input_from_files.c:354:                elg = E->lmesh.ezs+j + (E->lmesh.exs+i-1)*E->mesh.elz + (E->lmesh.eys+k-1)*E->mesh.elz*E->mesh.elx;
Regional_read_input_from_files.c:356:                    E->VIP[1][el] = VIP1[elg]+(VIP2[elg]-VIP1[elg])/(newage2-newage1)*(age-newage1);
Regional_read_input_from_files.c:359:                    E->VIP[1][el] = VIP1[elg];
Regional_read_input_from_files.c:362:                /* E->mat[1][el] = LL1[elg]; */ /*use the mat numbers base on radius*/
Regional_read_input_from_files.c:378:      if(E->control.ggrd.ray_control)
Regional_read_input_from_files.c:395:         /* if( E->parallel.me == 0)  
Regional_read_input_from_files.c:407:      if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Regional_read_input_from_files.c:410:                nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Regional_read_input_from_files.c:413:                    E->sphere.cap[1].TB[1][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Regional_read_input_from_files.c:414:                    E->sphere.cap[1].TB[2][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Regional_read_input_from_files.c:415:                    E->sphere.cap[1].TB[3][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Regional_read_input_from_files.c:418:                    E->sphere.cap[1].TB[1][nodel] = TB1[nodeg];
Regional_read_input_from_files.c:419:                    E->sphere.cap[1].TB[2][nodel] = TB1[nodeg];
Regional_read_input_from_files.c:420:                    E->sphere.cap[1].TB[3][nodel] = TB1[nodeg];
Regional_read_input_from_files.c:423:      }   /* end of E->parallel.me_loc[3]==E->parallel.nprocz-1   */
Regional_solver.c:65:    E->solver.velocity_boundary_conditions = regional_velocity_boundary_conditions;
Regional_solver.c:66:    E->solver.temperature_boundary_conditions = regional_temperature_boundary_conditions;
Regional_solver.c:69:    E->solver.set_2dc_defaults = regional_set_2dc_defaults;
Regional_solver.c:70:    E->solver.set_2pt5dc_defaults = regional_set_2pt5dc_defaults;
Regional_solver.c:71:    E->solver.set_3dc_defaults = regional_set_3dc_defaults;
Regional_solver.c:72:    E->solver.set_3dsphere_defaults = regional_set_3dsphere_defaults;
Regional_solver.c:75:    E->solver.lith_age_read_files = regional_lith_age_read_files;
Regional_solver.c:78:    E->solver.parallel_processor_setup = regional_parallel_processor_setup;
Regional_solver.c:79:    E->solver.parallel_domain_decomp0 = regional_parallel_domain_decomp0;
Regional_solver.c:80:    E->solver.parallel_domain_boundary_nodes = regional_parallel_domain_boundary_nodes;
Regional_solver.c:81:    E->solver.parallel_communication_routs_v = regional_parallel_communication_routs_v;
Regional_solver.c:82:    E->solver.parallel_communication_routs_s = regional_parallel_communication_routs_s;
Regional_solver.c:83:    E->solver.exchange_id_d = regional_exchange_id_d;
Regional_solver.c:86:    E->solver.read_input_files_for_timesteps = regional_read_input_files_for_timesteps;
Regional_solver.c:89:    E->solver.node_locations = regional_node_locations;
Regional_solver.c:90:    E->solver.construct_boundary = regional_construct_boundary;
Regional_sphere_related.c:61:  gnox=E->mesh.nox;
Regional_sphere_related.c:62:  gnoy=E->mesh.noy;
Regional_sphere_related.c:63:  gnoz=E->mesh.noz;
Regional_sphere_related.c:64:  nox=E->lmesh.nox;
Regional_sphere_related.c:65:  noy=E->lmesh.noy;
Regional_sphere_related.c:66:  noz=E->lmesh.noz;
Regional_sphere_related.c:68:  nprocxl=E->parallel.nprocx;
Regional_sphere_related.c:69:  nprocyl=E->parallel.nprocy;
Regional_sphere_related.c:70:  nproczl=E->parallel.nprocz;
Regional_sphere_related.c:72:  temp = max(E->mesh.NOY[E->mesh.levmax],E->mesh.NOX[E->mesh.levmax]);
Regional_sphere_related.c:75:  E->sphere.cap[1].theta[1] = E->control.theta_min;
Regional_sphere_related.c:76:  E->sphere.cap[1].theta[2] = E->control.theta_max;
Regional_sphere_related.c:77:  E->sphere.cap[1].theta[3] = E->control.theta_max;
Regional_sphere_related.c:78:  E->sphere.cap[1].theta[4] = E->control.theta_min;
Regional_sphere_related.c:79:  E->sphere.cap[1].fi[1] = E->control.fi_min;
Regional_sphere_related.c:80:  E->sphere.cap[1].fi[2] = E->control.fi_min;
Regional_sphere_related.c:81:  E->sphere.cap[1].fi[3] = E->control.fi_max;
Regional_sphere_related.c:82:  E->sphere.cap[1].fi[4] = E->control.fi_max;
Regional_sphere_related.c:84:  if(E->control.coor==1) {
Regional_sphere_related.c:88:    for(i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)  {
Regional_sphere_related.c:93:    temp = E->mesh.NOY[E->mesh.levmax]*E->mesh.NOX[E->mesh.levmax];
Regional_sphere_related.c:95:    sprintf(output_file,"%s",E->control.coor_file);
Regional_sphere_related.c:98:      fprintf(E->fp,"(Sphere_related #1) Cannot open %s\n",output_file);
Regional_sphere_related.c:104:        if(fscanf(fp,"%d %e",&nn,&theta1[E->mesh.gridmax][i]) != 2) {
Regional_sphere_related.c:105:            fprintf(E->fp,"Error while reading coor_file '%s'\n",output_file);
Regional_sphere_related.c:109:    E->control.theta_min = theta1[E->mesh.gridmax][1];
Regional_sphere_related.c:110:    E->control.theta_max = theta1[E->mesh.gridmax][gnox];
Regional_sphere_related.c:114:        if(fscanf(fp,"%d %e",&nn,&fi1[E->mesh.gridmax][i]) != 2) {
Regional_sphere_related.c:115:            fprintf(E->fp,"Error while reading coor_file '%s'\n",output_file);
Regional_sphere_related.c:119:    E->control.fi_min = fi1[E->mesh.gridmax][1];
Regional_sphere_related.c:120:    E->control.fi_max = fi1[E->mesh.gridmax][gnoy];
Regional_sphere_related.c:125:    E->sphere.cap[1].theta[1] = E->control.theta_min;
Regional_sphere_related.c:126:    E->sphere.cap[1].theta[2] = E->control.theta_max;
Regional_sphere_related.c:127:    E->sphere.cap[1].theta[3] = E->control.theta_max;
Regional_sphere_related.c:128:    E->sphere.cap[1].theta[4] = E->control.theta_min;
Regional_sphere_related.c:129:    E->sphere.cap[1].fi[1] = E->control.fi_min;
Regional_sphere_related.c:130:    E->sphere.cap[1].fi[2] = E->control.fi_min;
Regional_sphere_related.c:131:    E->sphere.cap[1].fi[3] = E->control.fi_max;
Regional_sphere_related.c:132:    E->sphere.cap[1].fi[4] = E->control.fi_max;
Regional_sphere_related.c:134:    for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Regional_sphere_related.c:136:      if (E->control.NMULTIGRID)
Regional_sphere_related.c:137:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Regional_sphere_related.c:141:      for (i=1;i<=E->mesh.NOX[lev];i++)
Regional_sphere_related.c:142:	theta1[lev][i] = theta1[E->mesh.gridmax][(i-1)*step+1];
Regional_sphere_related.c:144:      for (i=1;i<=E->mesh.NOY[lev];i++)
Regional_sphere_related.c:145:	fi1[lev][i] = fi1[E->mesh.gridmax][(i-1)*step+1];
Regional_sphere_related.c:150:  for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Regional_sphere_related.c:151:     elx = E->lmesh.ELX[lev];
Regional_sphere_related.c:152:     ely = E->lmesh.ELY[lev];
Regional_sphere_related.c:153:     nox = E->lmesh.NOX[lev];
Regional_sphere_related.c:154:     noy = E->lmesh.NOY[lev];
Regional_sphere_related.c:155:     noz = E->lmesh.NOZ[lev];
Regional_sphere_related.c:162:             nodesx = E->lmesh.NXS[lev]+j-1;
Regional_sphere_related.c:163:             nodesy = E->lmesh.NYS[lev]+k-1;
Regional_sphere_related.c:169:                E->SX[lev][m][1][node] = theta1[lev][nodesx];
Regional_sphere_related.c:170:                E->SX[lev][m][2][node] = fi1[lev][nodesy];
Regional_sphere_related.c:171:                E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Regional_sphere_related.c:174:                E->X[lev][m][1][node] =
Regional_sphere_related.c:175:                            E->sphere.R[lev][i]*sin(theta1[lev][nodesx])*cos(fi1[lev][nodesy]);
Regional_sphere_related.c:176:                E->X[lev][m][2][node] =
Regional_sphere_related.c:177:                            E->sphere.R[lev][i]*sin(theta1[lev][nodesx])*sin(fi1[lev][nodesy]);
Regional_sphere_related.c:178:                E->X[lev][m][3][node] =
Regional_sphere_related.c:179:                            E->sphere.R[lev][i]*cos(theta1[lev][nodesx]);
Regional_sphere_related.c:187:  for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Regional_sphere_related.c:194: else if((E->control.coor==0) || (E->control.coor==2)|| (E->control.coor==3))   {
Regional_sphere_related.c:198:  x[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Regional_sphere_related.c:199:  y[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Regional_sphere_related.c:200:  z[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Regional_sphere_related.c:206:  temp = E->lmesh.NOY[E->mesh.levmax]*E->lmesh.NOX[E->mesh.levmax];
Regional_sphere_related.c:212:     tt[1] = E->sphere.cap[m].theta[1]+(E->sphere.cap[m].theta[2] -E->sphere.cap[m].theta[1])/nprocxl*(E->parallel.me_loc[1]);
Regional_sphere_related.c:213:     tt[2] = E->sphere.cap[m].theta[1]+(E->sphere.cap[m].theta[2] -E->sphere.cap[m].theta[1])/nprocxl*(E->parallel.me_loc[1]+1);
Regional_sphere_related.c:216:     ff[1] = E->sphere.cap[m].fi[1]+(E->sphere.cap[m].fi[4] -E->sphere.cap[1].fi[1])/nprocyl*(E->parallel.me_loc[2]);
Regional_sphere_related.c:218:     ff[3] = E->sphere.cap[m].fi[1]+(E->sphere.cap[m].fi[4] -E->sphere.cap[1].fi[1])/nprocyl*(E->parallel.me_loc[2]+1);
Regional_sphere_related.c:222:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Regional_sphere_related.c:224:     elx = E->lmesh.ELX[lev];
Regional_sphere_related.c:225:     ely = E->lmesh.ELY[lev];
Regional_sphere_related.c:226:     nox = E->lmesh.NOX[lev];
Regional_sphere_related.c:227:     noy = E->lmesh.NOY[lev];
Regional_sphere_related.c:228:     noz = E->lmesh.NOZ[lev];
Regional_sphere_related.c:252:                E->SX[lev][m][1][node] = SX[0][nodes];
Regional_sphere_related.c:253:                E->SX[lev][m][2][node] = SX[1][nodes];
Regional_sphere_related.c:254:                E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Regional_sphere_related.c:257:                E->X[lev][m][1][node] =
Regional_sphere_related.c:258:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*cos(SX[1][nodes]);
Regional_sphere_related.c:259:                E->X[lev][m][2][node] =
Regional_sphere_related.c:260:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*sin(SX[1][nodes]);
Regional_sphere_related.c:261:                E->X[lev][m][3][node] =
Regional_sphere_related.c:262:                            E->sphere.R[lev][i]*cos(SX[0][nodes]);
Regional_tracer_advection.c:71:    if (E->sphere.caps_per_proc>1) {
Regional_tracer_advection.c:79:    sprintf(output_file,"%s.tracer_log.%d",E->control.data_file,E->parallel.me);
Regional_tracer_advection.c:80:    E->trace.fpt=fopen(output_file,"w");
Regional_tracer_advection.c:85:    E->trace.istat_isend=0;
Regional_tracer_advection.c:86:    E->trace.istat_iempty=0;
Regional_tracer_advection.c:87:    E->trace.istat_elements_checked=0;
Regional_tracer_advection.c:88:    E->trace.istat1=0;
Regional_tracer_advection.c:93:    E->trace.box_cushion=0.00001;
Regional_tracer_advection.c:98:    E->trace.number_of_basic_quantities=12;
Regional_tracer_advection.c:103:    E->trace.number_of_extra_quantities = 0;
Regional_tracer_advection.c:104:    if (E->trace.nflavors > 0)
Regional_tracer_advection.c:105:        E->trace.number_of_extra_quantities += 1;
Regional_tracer_advection.c:108:    E->trace.number_of_tracer_quantities =
Regional_tracer_advection.c:109:        E->trace.number_of_basic_quantities +
Regional_tracer_advection.c:110:        E->trace.number_of_extra_quantities;
Regional_tracer_advection.c:121:    if (E->trace.number_of_basic_quantities>99) {
Regional_tracer_advection.c:122:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of basic in tracer_defs.h\n");
Regional_tracer_advection.c:123:        fflush(E->trace.fpt);
Regional_tracer_advection.c:126:    if (E->trace.number_of_extra_quantities>99) {
Regional_tracer_advection.c:127:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of extraq in tracer_defs.h\n");
Regional_tracer_advection.c:128:        fflush(E->trace.fpt);
Regional_tracer_advection.c:131:    if (E->trace.number_of_tracer_quantities>99) {
Regional_tracer_advection.c:132:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of rlater in tracer_defs.h\n");
Regional_tracer_advection.c:133:        fflush(E->trace.fpt);
Regional_tracer_advection.c:144:    if (E->composition.on)
Regional_tracer_advection.c:147:    fprintf(E->trace.fpt, "Tracer intiailization takes %f seconds.\n",
Regional_tracer_advection.c:159:    fprintf(E->trace.fpt,"\nTracing Activated! (proc: %d)\n",E->parallel.me);
Regional_tracer_advection.c:160:    fprintf(E->trace.fpt,"   Allen K. McNamara 12-2003\n\n");
Regional_tracer_advection.c:162:    if (E->trace.ic_method==0) {
Regional_tracer_advection.c:163:        fprintf(E->trace.fpt,"Generating New Tracer Array\n");
Regional_tracer_advection.c:164:        fprintf(E->trace.fpt,"Tracers per element: %d\n",E->trace.itperel);
Regional_tracer_advection.c:166:    if (E->trace.ic_method==1) {
Regional_tracer_advection.c:167:        fprintf(E->trace.fpt,"Reading tracer file %s\n",E->trace.tracer_file);
Regional_tracer_advection.c:169:    if (E->trace.ic_method==2) {
Regional_tracer_advection.c:170:        fprintf(E->trace.fpt,"Read individual tracer files\n");
Regional_tracer_advection.c:173:    fprintf(E->trace.fpt,"Number of tracer flavors: %d\n", E->trace.nflavors);
Regional_tracer_advection.c:175:    if (E->trace.nflavors && E->trace.ic_method==0) {
Regional_tracer_advection.c:176:        fprintf(E->trace.fpt,"Initialized tracer flavors by: %d\n", E->trace.ic_method_for_flavors);
Regional_tracer_advection.c:177:        if (E->trace.ic_method_for_flavors == 0) {
Regional_tracer_advection.c:178:            fprintf(E->trace.fpt,"Layered tracer flavors\n");
Regional_tracer_advection.c:179:            for (i=0; i<E->trace.nflavors-1; i++)
Regional_tracer_advection.c:180:                fprintf(E->trace.fpt,"Interface Height: %d %f\n",i,E->trace.z_interface[i]);
Regional_tracer_advection.c:183:	else if((E->trace.ic_method_for_flavors == 1)||(E->trace.ic_method_for_flavors == 99)) {
Regional_tracer_advection.c:186:          fprintf(E->trace.fpt,"ggrd not implemented et for regional, flavor method= %d\n",
Regional_tracer_advection.c:187:		  E->trace.ic_method_for_flavors);
Regional_tracer_advection.c:188:	  fflush(E->trace.fpt);
Regional_tracer_advection.c:193:            fprintf(E->trace.fpt,"Sorry-This IC methods for Flavors are Unavailable %d\n",E->trace.ic_method_for_flavors);
Regional_tracer_advection.c:194:            fflush(E->trace.fpt);
Regional_tracer_advection.c:199:    for (i=0; i<E->trace.nflavors-2; i++) {
Regional_tracer_advection.c:200:        if (E->trace.z_interface[i] < E->trace.z_interface[i+1]) {
Regional_tracer_advection.c:201:            fprintf(E->trace.fpt,"Sorry - The %d-th z_interface is smaller than the next one.\n", i);
Regional_tracer_advection.c:202:            fflush(E->trace.fpt);
Regional_tracer_advection.c:211:    fprintf(E->trace.fpt,"Box Cushion: %f\n",E->trace.box_cushion);
Regional_tracer_advection.c:212:    fprintf(E->trace.fpt,"Number of Basic Quantities: %d\n",
Regional_tracer_advection.c:213:            E->trace.number_of_basic_quantities);
Regional_tracer_advection.c:214:    fprintf(E->trace.fpt,"Number of Extra Quantities: %d\n",
Regional_tracer_advection.c:215:            E->trace.number_of_extra_quantities);
Regional_tracer_advection.c:216:    fprintf(E->trace.fpt,"Total Number of Tracer Quantities: %d\n",
Regional_tracer_advection.c:217:            E->trace.number_of_tracer_quantities);
Regional_tracer_advection.c:221:    if (E->trace.itracer_warnings==0) {
Regional_tracer_advection.c:222:        fprintf(E->trace.fpt,"\n WARNING EXITS ARE TURNED OFF! TURN THEM ON!\n");
Regional_tracer_advection.c:224:        fflush(E->trace.fpt);
Regional_tracer_advection.c:239:    nox=E->lmesh.nox;
Regional_tracer_advection.c:240:    noy=E->lmesh.noy;
Regional_tracer_advection.c:241:    noz=E->lmesh.noz;
Regional_tracer_advection.c:243:    E->trace.x_space=(double*) malloc(nox*sizeof(double));
Regional_tracer_advection.c:244:    E->trace.y_space=(double*) malloc(noy*sizeof(double));
Regional_tracer_advection.c:245:    E->trace.z_space=(double*) malloc(noz*sizeof(double));
Regional_tracer_advection.c:251:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Regional_tracer_advection.c:253:	    E->trace.x_space[i]=E->sx[m][1][i*noz+1];
Regional_tracer_advection.c:256:	    E->trace.y_space[j]=E->sx[m][2][j*nox*noz+1];
Regional_tracer_advection.c:259:	    E->trace.z_space[k]=E->sx[m][3][k+1];
Regional_tracer_advection.c:266:	fprintf(E->trace.fpt, "i=%d x=%e\n", i, E->trace.x_space[i]);
Regional_tracer_advection.c:268:	fprintf(E->trace.fpt, "j=%d y=%e\n", j, E->trace.y_space[j]);
Regional_tracer_advection.c:270:	fprintf(E->trace.fpt, "k=%d z=%e\n", k, E->trace.z_space[k]);
Regional_tracer_advection.c:272:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 0));
Regional_tracer_advection.c:273:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 1));
Regional_tracer_advection.c:274:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 2));
Regional_tracer_advection.c:275:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 3));
Regional_tracer_advection.c:276:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 4));
Regional_tracer_advection.c:278:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.56, 0));
Regional_tracer_advection.c:279:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.56, 1));
Regional_tracer_advection.c:280:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.56, 2));
Regional_tracer_advection.c:282:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.99, 2));
Regional_tracer_advection.c:283:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.99, 3));
Regional_tracer_advection.c:284:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.99, 4));
Regional_tracer_advection.c:286:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.5));
Regional_tracer_advection.c:287:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 1.1));
Regional_tracer_advection.c:288:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.55));
Regional_tracer_advection.c:289:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 1.0));
Regional_tracer_advection.c:290:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.551));
Regional_tracer_advection.c:291:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.99));
Regional_tracer_advection.c:292:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.7));
Regional_tracer_advection.c:293:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.75));
Regional_tracer_advection.c:294:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.775));
Regional_tracer_advection.c:295:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.7750001));
Regional_tracer_advection.c:319:    elx = E->lmesh.elx;
Regional_tracer_advection.c:320:    ely = E->lmesh.ely;
Regional_tracer_advection.c:321:    elz = E->lmesh.elz;
Regional_tracer_advection.c:333:	ii = isearch_neighbors(E->trace.x_space, elx+1, theta, i);
Regional_tracer_advection.c:334:	jj = isearch_neighbors(E->trace.y_space, ely+1, phi, j);
Regional_tracer_advection.c:335:	kk = isearch_neighbors(E->trace.z_space, elz+1, rad, k);
Regional_tracer_advection.c:343:    ii = isearch_all(E->trace.x_space, elx+1, theta);
Regional_tracer_advection.c:344:    jj = isearch_all(E->trace.y_space, ely+1, phi);
Regional_tracer_advection.c:345:    kk = isearch_all(E->trace.z_space, elz+1, rad);
Regional_tracer_advection.c:418:    theta_min = E->trace.theta_cap[icap][2];
Regional_tracer_advection.c:419:    theta_max = E->trace.theta_cap[icap][4];
Regional_tracer_advection.c:421:    phi_min = E->trace.phi_cap[icap][2];
Regional_tracer_advection.c:422:    phi_max = E->trace.phi_cap[icap][4];
Regional_tracer_advection.c:443:    elx = E->lmesh.elx;
Regional_tracer_advection.c:444:    ely = E->lmesh.ely;
Regional_tracer_advection.c:445:    elz = E->lmesh.elz;
Regional_tracer_advection.c:465:    tr_dx = theta - E->trace.x_space[i];
Regional_tracer_advection.c:466:    dx = E->trace.x_space[i+1] - E->trace.x_space[i];
Regional_tracer_advection.c:468:    tr_dy = phi - E->trace.y_space[j];
Regional_tracer_advection.c:469:    dy = E->trace.y_space[j+1] - E->trace.y_space[j];
Regional_tracer_advection.c:471:    tr_dz = rad - E->trace.z_space[k];
Regional_tracer_advection.c:472:    dz = E->trace.z_space[k+1] - E->trace.z_space[k];
Regional_tracer_advection.c:495:    fprintf(E->trace.fpt, "dr=(%e,%e,%e)  tr_dr=(%e,%e,%e)\n",
Regional_tracer_advection.c:497:    fprintf(E->trace.fpt, "shp: %e %e %e %e %e %e %e %e\n",
Regional_tracer_advection.c:499:    fprintf(E->trace.fpt, "sum(shp): %e\n",
Regional_tracer_advection.c:501:    fflush(E->trace.fpt);
Regional_tracer_advection.c:557:        fprintf(E->trace.fpt, "VV: %e %e %e %e %e %e %e %e: %e\n",
Regional_tracer_advection.c:565:        tmp += E->sx[m][1][E->ien[m][nelem].node[n]] * shp[n];
Regional_tracer_advection.c:567:    fprintf(E->trace.fpt, "THETA: %e -> %e\n", theta, tmp);
Regional_tracer_advection.c:569:    fflush(E->trace.fpt);
Regional_tracer_advection.c:583:    if (*theta > E->control.theta_max - E->trace.box_cushion) {
Regional_tracer_advection.c:584:        *theta = E->control.theta_max - E->trace.box_cushion;
Regional_tracer_advection.c:588:    if (*theta < E->control.theta_min + E->trace.box_cushion) {
Regional_tracer_advection.c:589:        *theta = E->control.theta_min + E->trace.box_cushion;
Regional_tracer_advection.c:593:    if (*phi > E->control.fi_max - E->trace.box_cushion) {
Regional_tracer_advection.c:594:        *phi = E->control.fi_max - E->trace.box_cushion;
Regional_tracer_advection.c:598:    if (*phi < E->control.fi_min + E->trace.box_cushion) {
Regional_tracer_advection.c:599:        *phi = E->control.fi_min + E->trace.box_cushion;
Regional_tracer_advection.c:603:    if (*rad > E->sphere.ro - E->trace.box_cushion) {
Regional_tracer_advection.c:604:        *rad = E->sphere.ro - E->trace.box_cushion;
Regional_tracer_advection.c:608:    if (*rad < E->sphere.ri + E->trace.box_cushion) {
Regional_tracer_advection.c:609:        *rad = E->sphere.ri + E->trace.box_cushion;
Regional_tracer_advection.c:623:    /* This part only works if E->sphere.caps_per_proc==1 */
Regional_tracer_advection.c:625:    int lev = E->mesh.levmax;
Regional_tracer_advection.c:647:    E->trace.istat_isend = E->trace.ilater[j];
Regional_tracer_advection.c:650:    for (d=0; d<E->mesh.nsd; d++) {
Regional_tracer_advection.c:651:        bounds[d][0] = E->sx[j][d+1][1];
Regional_tracer_advection.c:652:        bounds[d][1] = E->sx[j][d+1][E->lmesh.nno];
Regional_tracer_advection.c:659:        if (E->parallel.NUM_PASS[lev][j].bound[kk] == 1) {
Regional_tracer_advection.c:660:            ngbr_rank[kk] = E->parallel.PROCESSOR[lev][j].pass[ipass];
Regional_tracer_advection.c:669:    for (kk=1; kk<=E->trace.istat_isend; kk++) {
Regional_tracer_advection.c:670:        fprintf(E->trace.fpt, "tracer#=%d xx=(%g,%g,%g)\n", kk,
Regional_tracer_advection.c:671:                E->trace.rlater[j][0][kk],
Regional_tracer_advection.c:672:                E->trace.rlater[j][1][kk],
Regional_tracer_advection.c:673:                E->trace.rlater[j][2][kk]);
Regional_tracer_advection.c:676:    for (d=0; d<E->mesh.nsd; d++) {
Regional_tracer_advection.c:677:        fprintf(E->trace.fpt, "bounds(dim=%d) = (%e, %e)\n",
Regional_tracer_advection.c:682:        fprintf(E->trace.fpt, "pass=%d  neighbor_rank=%d\n",
Regional_tracer_advection.c:685:    fflush(E->trace.fpt);
Regional_tracer_advection.c:691:    max_send_size = max(2*E->trace.ilater[j], E->trace.ntracers[j]/100);
Regional_tracer_advection.c:692:    itemp_size = max_send_size * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:696:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (u388)\n");
Regional_tracer_advection.c:697:        fflush(E->trace.fpt);
Regional_tracer_advection.c:702:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (u389)\n");
Regional_tracer_advection.c:703:        fflush(E->trace.fpt);
Regional_tracer_advection.c:708:    for (d=0; d<E->mesh.nsd; d++) {
Regional_tracer_advection.c:709:        int original_size = E->trace.ilater[j];
Regional_tracer_advection.c:717:        while (kk<=E->trace.ilater[j]) {
Regional_tracer_advection.c:721:            coord = E->trace.rlater[j][d][kk];
Regional_tracer_advection.c:739:                itemp_size = isize * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:744:                    fprintf(E->trace.fpt,"Error(lost souls)-no memory (s4)\n");
Regional_tracer_advection.c:745:                    fflush(E->trace.fpt);
Regional_tracer_advection.c:751:                    fprintf(E->trace.fpt,"Error(lost souls)-no memory (s5)\n");
Regional_tracer_advection.c:752:                    fflush(E->trace.fpt);
Regional_tracer_advection.c:756:                fprintf(E->trace.fpt,"Expanding physical memory of send to "
Regional_tracer_advection.c:768:        if ((isend[0] + isend[1] + E->trace.ilater[j]) != original_size) {
Regional_tracer_advection.c:769:            fprintf(E->trace.fpt, "original_size: %d, rlater_size: %d, "
Regional_tracer_advection.c:771:                    original_size, E->trace.ilater[j], kk);
Regional_tracer_advection.c:778:                fprintf(E->trace.fpt, "dim:%d side:%d kk=%d coord[kk]=%e\n",
Regional_tracer_advection.c:780:                        send[i][kk*E->trace.number_of_tracer_quantities+d]);
Regional_tracer_advection.c:783:        fflush(E->trace.fpt);
Regional_tracer_advection.c:797:                          11, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:800:                          11, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:818:                fprintf(E->trace.fpt, "%d: %d send %d to proc %d\n",
Regional_tracer_advection.c:820:                fprintf(E->trace.fpt, "%d: %d recv %d from proc %d\n",
Regional_tracer_advection.c:829:            isize = irecv[i] * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:834:                fprintf(E->trace.fpt, "Error(lost souls)-no memory (c721)\n");
Regional_tracer_advection.c:835:                fflush(E->trace.fpt);
Regional_tracer_advection.c:848:                isize = isend[i] * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:850:                          12, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:852:                isize = irecv[i] * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:854:                          12, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:867:                fprintf(E->trace.fpt, "recv: %d %e %e %e\n",
Regional_tracer_advection.c:869:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities],
Regional_tracer_advection.c:870:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities+1],
Regional_tracer_advection.c:871:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities+2]);
Regional_tracer_advection.c:874:        fflush(E->trace.fpt);
Regional_tracer_advection.c:891:    if (E->trace.ilater[j] > 0) {
Regional_tracer_advection.c:892:        fprintf(E->trace.fpt, "Error(regional_lost_souls) lost tracers\n");
Regional_tracer_advection.c:893:        for (kk=1; kk<=E->trace.ilater[j]; kk++) {
Regional_tracer_advection.c:894:            fprintf(E->trace.fpt, "lost #%d xx=(%e, %e, %e)\n", kk,
Regional_tracer_advection.c:895:                    E->trace.rlater[j][0][kk],
Regional_tracer_advection.c:896:                    E->trace.rlater[j][1][kk],
Regional_tracer_advection.c:897:                    E->trace.rlater[j][2][kk]);
Regional_tracer_advection.c:899:        fflush(E->trace.fpt);
Regional_tracer_advection.c:909:    E->trace.lost_souls_time += CPU_time0() - begin_time;
Regional_tracer_advection.c:922:    isend_position = (*send_size) * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:924:    for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++) {
Regional_tracer_advection.c:926:        send[ipos] = E->trace.rlater[j][pp][kk];
Regional_tracer_advection.c:931:    ilast_tracer = E->trace.ilater[j];
Regional_tracer_advection.c:932:    for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++) {
Regional_tracer_advection.c:933:        E->trace.rlater[j][pp][kk] = E->trace.rlater[j][pp][ilast_tracer];
Regional_tracer_advection.c:935:    E->trace.ilater[j]--;
Regional_tracer_advection.c:958:        ipos = kk * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:972:        fprintf(E->trace.fpt, "kk=%d, inside=%d, xx=(%e, %e, %e)\n",
Regional_tracer_advection.c:974:        fprintf(E->trace.fpt, "before: %d %d\n",
Regional_tracer_advection.c:975:                E->trace.ilater[j], E->trace.ntracers[j]);
Regional_tracer_advection.c:980:            E->trace.ntracers[j]++;
Regional_tracer_advection.c:981:            ilast = E->trace.ntracers[j];
Regional_tracer_advection.c:983:            if (E->trace.ntracers[j] > (E->trace.max_ntracers[j]-5))
Regional_tracer_advection.c:986:            for (pp=0; pp<E->trace.number_of_basic_quantities; pp++)
Regional_tracer_advection.c:987:                E->trace.basicq[j][pp][ilast] = recv[ipos+pp];
Regional_tracer_advection.c:989:            ipos += E->trace.number_of_basic_quantities;
Regional_tracer_advection.c:990:            for (pp=0; pp<E->trace.number_of_extra_quantities; pp++)
Regional_tracer_advection.c:991:                E->trace.extraq[j][pp][ilast] = recv[ipos+pp];
Regional_tracer_advection.c:998:                fprintf(E->trace.fpt, "Error(regional lost souls) - "
Regional_tracer_advection.c:1000:                fprintf(E->trace.fpt, "theta, phi, rad: %f %f %f\n",
Regional_tracer_advection.c:1002:                fflush(E->trace.fpt);
Regional_tracer_advection.c:1006:            E->trace.ielement[j][ilast] = iel;
Regional_tracer_advection.c:1010:            if (E->trace.ilatersize[j]==0) {
Regional_tracer_advection.c:1012:                E->trace.ilatersize[j]=E->trace.max_ntracers[j]/5;
Regional_tracer_advection.c:1014:                for (kk=0;kk<E->trace.number_of_tracer_quantities;kk++) {
Regional_tracer_advection.c:1015:                    if ((E->trace.rlater[j][kk]=(double *)malloc(E->trace.ilatersize[j]*sizeof(double)))==NULL) {
Regional_tracer_advection.c:1016:                        fprintf(E->trace.fpt,"AKM(put_found_tracers)-no memory (%d)\n",kk);
Regional_tracer_advection.c:1017:                        fflush(E->trace.fpt);
Regional_tracer_advection.c:1023:            E->trace.ilater[j]++;
Regional_tracer_advection.c:1024:            ilast = E->trace.ilater[j];
Regional_tracer_advection.c:1026:            if (E->trace.ilater[j] > (E->trace.ilatersize[j]-5))
Regional_tracer_advection.c:1029:            for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++)
Regional_tracer_advection.c:1030:                E->trace.rlater[j][pp][ilast] = recv[ipos+pp];
Regional_tracer_advection.c:1034:        fprintf(E->trace.fpt, "after: %d %d\n",
Regional_tracer_advection.c:1035:                E->trace.ilater[j], E->trace.ntracers[j]);
Regional_tracer_advection.c:1036:        fflush(E->trace.fpt);
Regional_version_dependent.c:63:  rr = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Regional_version_dependent.c:64:  RR = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Regional_version_dependent.c:65:  nox=E->mesh.nox;
Regional_version_dependent.c:66:  noy=E->mesh.noy;
Regional_version_dependent.c:67:  noz=E->mesh.noz;
Regional_version_dependent.c:70:  switch(E->control.coor)    {	
Regional_version_dependent.c:73:    dr = (E->sphere.ro-E->sphere.ri)/(E->mesh.noz-1);
Regional_version_dependent.c:74:    for (k=1;k<=E->mesh.noz;k++)  {
Regional_version_dependent.c:75:      rr[k] = E->sphere.ri + (k-1)*dr;
Regional_version_dependent.c:80:    sprintf(output_file,"%s",E->control.coor_file);
Regional_version_dependent.c:83:      fprintf(E->fp,"(Nodal_mesh.c #1) Cannot open %s\n",output_file);
Regional_version_dependent.c:96:    for (k=1;k<=E->mesh.noz;k++)  {
Regional_version_dependent.c:103:    E->sphere.ri = rr[1];
Regional_version_dependent.c:104:    E->sphere.ro = rr[E->mesh.noz];
Regional_version_dependent.c:122:  for (i=1;i<=E->mesh.noz;i++)  {
Regional_version_dependent.c:123:      E->sphere.gr[i] = rr[i];
Regional_version_dependent.c:124:      /* if(E->parallel.me==0) fprintf(stderr, "%d %f\n", i, E->sphere.gr[i]); */
Regional_version_dependent.c:127:  for (i=1;i<=E->lmesh.noz;i++)  {
Regional_version_dependent.c:128:      k = E->lmesh.nzs+i-1;
Regional_version_dependent.c:132:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Regional_version_dependent.c:134:    if (E->control.NMULTIGRID)
Regional_version_dependent.c:135:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Regional_version_dependent.c:139:      for (i=1;i<=E->lmesh.NOZ[lev];i++)
Regional_version_dependent.c:140:         E->sphere.R[lev][i] = RR[(i-1)*step+1];
Regional_version_dependent.c:145:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Regional_version_dependent.c:150:  if (E->control.verbose) {
Regional_version_dependent.c:151:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Regional_version_dependent.c:152:    fprintf(E->fp_out,"output_coordinates before rotation %d \n",lev);
Regional_version_dependent.c:153:    for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Regional_version_dependent.c:154:      fprintf(E->fp_out,"output_coordinates for cap %d %d\n",j,E->lmesh.NNO[lev]);
Regional_version_dependent.c:155:      for (i=1;i<=E->lmesh.NNO[lev];i++)
Regional_version_dependent.c:156:        if(i%E->lmesh.NOZ[lev]==1)
Regional_version_dependent.c:157:             fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Regional_version_dependent.c:160:    fflush(E->fp_out);
Regional_version_dependent.c:165:  if(E->data.use_ellipse)
Regional_version_dependent.c:168:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Regional_version_dependent.c:169:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Regional_version_dependent.c:170:      for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Regional_version_dependent.c:171:        E->SinCos[lev][j][0][i] = sin(E->SX[lev][j][1][i]);
Regional_version_dependent.c:172:        E->SinCos[lev][j][1][i] = sin(E->SX[lev][j][2][i]);
Regional_version_dependent.c:173:        E->SinCos[lev][j][2][i] = cos(E->SX[lev][j][1][i]);
Regional_version_dependent.c:174:        E->SinCos[lev][j][3][i] = cos(E->SX[lev][j][2][i]);
Regional_version_dependent.c:178:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Regional_version_dependent.c:179:    sprintf(output_file,"coord.%d",E->parallel.me);
Regional_version_dependent.c:182:          fprintf(E->fp,"(Nodal_mesh.c #2) Cannot open %s\n",output_file);
Regional_version_dependent.c:185:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Regional_version_dependent.c:186:      for(i=1;i<=E->lmesh.noy;i++) {
Regional_version_dependent.c:187:        for(j=1;j<=E->lmesh.nox;j++)  {
Regional_version_dependent.c:188:           node=1+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz;
Regional_version_dependent.c:189:           t1 = 90.0-E->sx[m][1][node]/M_PI*180.0;
Regional_version_dependent.c:190:           f1 = E->sx[m][2][node]/M_PI*180.0;
Regional_version_dependent.c:195:      for(j=1;j<=E->lmesh.nox;j++)  {
Regional_version_dependent.c:196:        for(i=1;i<=E->lmesh.noy;i++) {
Regional_version_dependent.c:197:           node=1+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz;
Regional_version_dependent.c:198:           t1 = 90.0-E->sx[m][1][node]/M_PI*180.0;
Regional_version_dependent.c:199:           f1 = E->sx[m][2][node]/M_PI*180.0;
Regional_version_dependent.c:210:  if (E->control.verbose) {
Regional_version_dependent.c:211:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Regional_version_dependent.c:212:    fprintf(E->fp_out,"output_coordinates after rotation %d \n",lev);
Regional_version_dependent.c:213:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Regional_version_dependent.c:214:      for (i=1;i<=E->lmesh.NNO[lev];i++)
Regional_version_dependent.c:215:        if(i%E->lmesh.NOZ[lev]==1)
Regional_version_dependent.c:216:             fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Regional_version_dependent.c:218:    fflush(E->fp_out);
Regional_version_dependent.c:232:  const int dims=E->mesh.nsd;
Regional_version_dependent.c:239:  int max_size = E->lmesh.elx*E->lmesh.ely*E->lmesh.elz
Regional_version_dependent.c:240:    - (E->lmesh.elx-2)*(E->lmesh.ely-2)*(E->lmesh.elz-2) + 1;
Regional_version_dependent.c:242:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_version_dependent.c:243:    E->boundary.element[m] = (int *)malloc(max_size*sizeof(int));
Regional_version_dependent.c:246:      E->boundary.normal[m][d] = (int *)malloc(max_size*sizeof(int));
Regional_version_dependent.c:250:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_version_dependent.c:252:    for(k=1; k<=E->lmesh.ely; k++)
Regional_version_dependent.c:253:      for(j=1; j<=E->lmesh.elx; j++)
Regional_version_dependent.c:254:	for(i=1; i<=E->lmesh.elz; i++) {
Regional_version_dependent.c:260:	  if((E->parallel.me_loc[1] == 0) && (j == 1)) {
Regional_version_dependent.c:265:	  if((E->parallel.me_loc[1] == E->parallel.nprocx - 1)
Regional_version_dependent.c:266:	     && (j == E->lmesh.elx)) {
Regional_version_dependent.c:271:	  if((E->parallel.me_loc[2] == 0) && (k == 1)) {
Regional_version_dependent.c:276:	  if((E->parallel.me_loc[2] == E->parallel.nprocy - 1)
Regional_version_dependent.c:277:	     && (k == E->lmesh.ely)) {
Regional_version_dependent.c:282:	  if((E->parallel.me_loc[3] == 0) && (i == 1)) {
Regional_version_dependent.c:287:	  if((E->parallel.me_loc[3] == E->parallel.nprocz - 1)
Regional_version_dependent.c:288:	     && (i == E->lmesh.elz)) {
Regional_version_dependent.c:294:	    el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Regional_version_dependent.c:295:	    E->boundary.element[m][count] = el;
Regional_version_dependent.c:297:	      E->boundary.normal[m][d][count] = normalFlag[d];
Regional_version_dependent.c:304:    E->boundary.nel = count - 1;
Shape_functions.c:54:    { E->N.vpt[i] = 0.0; 
Shape_functions.c:55:      E->Nx.vpt[i] = 0.0;
Shape_functions.c:56:      E->Nx.vpt[GNVI+i] = 0.0;
Shape_functions.c:57:      E->Nx.vpt[2*GNVI+i] = 0.0; 
Shape_functions.c:61:    { E->N.ppt[i] = 0.0; 
Shape_functions.c:62:      E->Nx.ppt[i] = 0.0;
Shape_functions.c:63:      E->Nx.ppt[GNPI+i] = 0.0;
Shape_functions.c:64:      E->Nx.ppt[2*GNPI+i] = 0.0; 
Shape_functions.c:68:    { E->M.vpt[i] = 0.0; 
Shape_functions.c:69:      E->Mx.vpt[i] = 0.0;
Shape_functions.c:70:      E->Mx.vpt[GN1VI+i] = 0.0;
Shape_functions.c:74:    { E->M.ppt[i] = 0.0; 
Shape_functions.c:75:      E->Mx.ppt[i] = 0.0;
Shape_functions.c:76:      E->Mx.ppt[GN1PI+i] = 0.0;
Shape_functions.c:80:    { E->L.vpt[i] = 0.0; 
Shape_functions.c:81:      E->Lx.vpt[i] = 0.0;
Shape_functions.c:82:      E->Lx.vpt[GN1VI+i] = 0.0;
Shape_functions.c:86:    { E->NM.vpt[i] = 0.0; 
Shape_functions.c:87:      E->NMx.vpt[i] = 0.0;
Shape_functions.c:88:      E->NMx.vpt[GNVI+i] = 0.0;
Shape_functions.c:89:      E->NMx.vpt[2*GNVI+i] = 0.0; 
Shape_functions.c:92:  for(i=1;i<=enodes[E->mesh.nsd];i++)   {
Shape_functions.c:95:      for(j=1;j<=vpoints[E->mesh.nsd];j++)  { 
Shape_functions.c:98:         E->N.vpt[GNVINDEX(i,j)] = 1.0;
Shape_functions.c:99:         for(d=1;d<=E->mesh.nsd;d++)   
Shape_functions.c:100:             E->N.vpt[GNVINDEX(i,j)] *=  
Shape_functions.c:103:         for(dd=1;dd<=E->mesh.nsd;dd++) {
Shape_functions.c:104:             E->Nx.vpt[GNVXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],g_point[j].x[dd-1]);
Shape_functions.c:105:             for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:107:                   E->Nx.vpt[GNVXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],g_point[j].x[d-1]);
Shape_functions.c:112:      for(j=1;j<=ppoints[E->mesh.nsd];j++)  {
Shape_functions.c:114:         E->N.ppt[GNPINDEX(i,j)] = 1.0;
Shape_functions.c:115:         for(d=1;d<=E->mesh.nsd;d++) 
Shape_functions.c:116:            E->N.ppt[GNPINDEX(i,j)] *=  
Shape_functions.c:119:         for(dd=1;dd<=E->mesh.nsd;dd++) {
Shape_functions.c:120:            E->Nx.ppt[GNPXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],p_point[j].x[dd-1]);
Shape_functions.c:121:            for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:123:                  E->Nx.ppt[GNPXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],p_point[j].x[d-1]); 
Shape_functions.c:129:  for(j=1;j<=onedvpoints[E->mesh.nsd];j++)
Shape_functions.c:130:    for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Shape_functions.c:131:       E->M.vpt[GMVINDEX(j,k)] = 1.0;
Shape_functions.c:132:       E->L.vpt[GMVINDEX(j,k)] = 1.0;
Shape_functions.c:133:       for(d=1;d<=E->mesh.nsd-1;d++) {
Shape_functions.c:134:          E->M.vpt[GMVINDEX(j,k)] *= lpoly(bb[d-1][j],s_point[k].x[d-1]);
Shape_functions.c:135:          E->L.vpt[GMVINDEX(j,k)] *= lpoly(bb[d-1][j],l_1d[k].x[d-1]);
Shape_functions.c:137:       for(dd=1;dd<=E->mesh.nsd-1;dd++) {
Shape_functions.c:138:          E->Mx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(bb[dd-1][j],s_point[k].x[d-1]);
Shape_functions.c:139:          E->Lx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(bb[dd-1][j],l_1d[k].x[d-1]);
Shape_functions.c:140:          for(d=1;d<=E->mesh.nsd-1;d++)
Shape_functions.c:142:                E->Mx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(bb[d-1][j],s_point[k].x[d-1]);
Shape_functions.c:143:                E->Lx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(bb[d-1][j],l_1d[k].x[d-1]);
Shape_functions.c:152:  for(i=1;i<=enodes[E->mesh.nsd];i++)   {
Shape_functions.c:153:      for(j=1;j<=vpoints[E->mesh.nsd];j++)   {
Shape_functions.c:155:         E->NM.vpt[GNVINDEX(i,j)] = 1.0;
Shape_functions.c:156:         for(d=1;d<=E->mesh.nsd;d++)   
Shape_functions.c:157:             E->NM.vpt[GNVINDEX(i,j)] *=  
Shape_functions.c:160:         for(dd=1;dd<=E->mesh.nsd;dd++)                 {
Shape_functions.c:161:            E->NMx.vpt[GNVXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],s_point[j].x[dd-1]);
Shape_functions.c:162:            for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:164:                  E->NMx.vpt[GNVXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],s_point[j].x[d-1]); 
Size_does_matter.c:87:    const int dims = E->mesh.nsd;
Size_does_matter.c:102:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:103:                    * E->N.vpt[GNVINDEX(i,k)];
Size_does_matter.c:108:                    dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:109:                        * E->Nx.vpt[GNVXINDEX(d-1,i,k)];
Size_does_matter.c:111:        jacobian = determinant(dxda, E->mesh.nsd);
Size_does_matter.c:112:        E->GDA[lev][m][el].vpt[k] = jacobian;
Size_does_matter.c:124:                        E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Size_does_matter.c:131:                E->GNX[lev][m][el].vpt[GNVXINDEX(d-1,j,k)]
Size_does_matter.c:147:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:148:                    * E->N.ppt[GNPINDEX(i,k)];
Size_does_matter.c:153:                    dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:154:                        * E->Nx.ppt[GNPXINDEX(d-1,i,k)];
Size_does_matter.c:156:        jacobian = determinant(dxda,E->mesh.nsd);
Size_does_matter.c:157:        E->GDA[lev][m][el].ppt[k] = jacobian;
Size_does_matter.c:161:                cof[d][e]=cofactor(dxda,d,e,E->mesh.nsd);
Size_does_matter.c:169:                        E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Size_does_matter.c:174:                E->GNX[lev][m][el].ppt[GNPXINDEX(d-1,j,k)]
Size_does_matter.c:191:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Size_does_matter.c:192:        for(lev=E->mesh.levmax; lev>=E->mesh.levmin; lev--)
Size_does_matter.c:193:            for(el=1; el<=E->lmesh.NEL[lev]; el++) {
Size_does_matter.c:214:    const int dims = E->mesh.nsd;
Size_does_matter.c:224:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:225:                    * E->N.vpt[GNVINDEX(i,k)];
Size_does_matter.c:244:    const int dims = E->mesh.nsd;
Size_does_matter.c:254:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:255:                    * E->N.ppt[GNPINDEX(i,k)];
Size_does_matter.c:271:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:274:  to = theta_g(E->eco[m][el].centre[1],E);
Size_does_matter.c:276:  to = E->eco[m][el].centre[1];	
Size_does_matter.c:279:  fo = E->eco[m][el].centre[2];
Size_does_matter.c:293:    node = E->ien[m][el].node[s];
Size_does_matter.c:294:    xx[1][i] = E->x[m][1][node]*dxdy[1][1]
Size_does_matter.c:295:             + E->x[m][2][node]*dxdy[1][2]
Size_does_matter.c:296:             + E->x[m][3][node]*dxdy[1][3];
Size_does_matter.c:297:    xx[2][i] = E->x[m][1][node]*dxdy[2][1]
Size_does_matter.c:298:             + E->x[m][2][node]*dxdy[2][2]
Size_does_matter.c:299:             + E->x[m][3][node]*dxdy[2][3];
Size_does_matter.c:300:    xx[3][i] = E->x[m][1][node]*dxdy[3][1]
Size_does_matter.c:301:             + E->x[m][2][node]*dxdy[3][2]
Size_does_matter.c:302:             + E->x[m][3][node]*dxdy[3][3];
Size_does_matter.c:319:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:323:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:325:      E->surf_det[m][k] = (double *)malloc((1+E->lmesh.snel)*sizeof(double));
Size_does_matter.c:328:  for (m=1;m<=E->sphere.caps_per_proc;m++) {
Size_does_matter.c:329:  r2 = 1.0 / (E->sx[m][3][E->lmesh.elz+1] * E->sx[m][3][E->lmesh.elz+1]);
Size_does_matter.c:331:  for (es=1;es<=E->lmesh.snel;es++)   {
Size_does_matter.c:332:    el = es * E->lmesh.elz;
Size_does_matter.c:336:      for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:337:        for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:341:        for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:342:          for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:343:             dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:345:      jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:348:      E->surf_det[m][k][es] = jacobian * r2;
Size_does_matter.c:369:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:373:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:376:	E->boundary.det[m][side][d] = (double *)malloc((1+E->boundary.nel)*sizeof(double));
Size_does_matter.c:378:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:379:    for (es=1;es<=E->boundary.nel;es++) {
Size_does_matter.c:380:      el = E->boundary.element[m][es];
Size_does_matter.c:387:	  for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:388:	    for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:392:	    for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:393:	      for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:394:		dxda[d][e] += xx[sidedim[side][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:396:	  jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:397:	  E->boundary.det[m][side][k][es] = jacobian;
Size_does_matter.c:402:	      E->boundary.det[m][side][1][es],
Size_does_matter.c:403:	      E->boundary.det[m][side][2][es],
Size_does_matter.c:404:	      E->boundary.det[m][side][3][es],
Size_does_matter.c:405:	      E->boundary.det[m][side][4][es],
Size_does_matter.c:406:	      E->boundary.det[m][side][1][es]+
Size_does_matter.c:407:	      E->boundary.det[m][side][2][es]+
Size_does_matter.c:408:	      E->boundary.det[m][side][3][es]+
Size_does_matter.c:409:	      E->boundary.det[m][side][4][es]);
Size_does_matter.c:432:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:441:      for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:442:	for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:446:	for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:447:	  for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:448:	    dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:450:      jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:471:    const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:476:    to = theta_g(E->eco[m][el].centre[1],E);
Size_does_matter.c:478:    to = E->eco[m][el].centre[1]; 
Size_does_matter.c:480:    fo = E->eco[m][el].centre[2];
Size_does_matter.c:496:            node = E->ien[m][el].node[e];
Size_does_matter.c:497:            xx[1][i] = E->x[m][1][node]*dxdy[1][1]
Size_does_matter.c:498:                + E->x[m][2][node]*dxdy[1][2]
Size_does_matter.c:499:                + E->x[m][3][node]*dxdy[1][3];
Size_does_matter.c:500:            xx[2][i] = E->x[m][1][node]*dxdy[2][1]
Size_does_matter.c:501:                + E->x[m][2][node]*dxdy[2][2]
Size_does_matter.c:502:                + E->x[m][3][node]*dxdy[2][3];
Size_does_matter.c:503:            xx[3][i] = E->x[m][1][node]*dxdy[3][1]
Size_does_matter.c:504:                + E->x[m][2][node]*dxdy[3][2]
Size_does_matter.c:505:                + E->x[m][3][node]*dxdy[3][3];
Size_does_matter.c:510:            for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:511:                for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:515:                for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:516:                    for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:517:                        dxda[d][e] += xx[e][i]*E->Lx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:519:            jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:542:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:549:    for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:550:      for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:554:      for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:555:	for(e=1;e<=E->mesh.nsd-1;e++) {
Size_does_matter.c:556:	  dxda[d][e] += xx[sidedim[side][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:560:    jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:578:  const int dims=E->mesh.nsd;
Size_does_matter.c:590:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Size_does_matter.c:591:                   *E->N.vpt[GNVINDEX(a,k)];
Size_does_matter.c:618:          tt = E->SX[lev][m][1][E->IEN[lev][m][el].node[a]];
Size_does_matter.c:619:          ff = E->SX[lev][m][2][E->IEN[lev][m][el].node[a]];
Size_does_matter.c:651:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Size_does_matter.c:652:                   *E->N.ppt[GNPINDEX(a,k)];
Size_does_matter.c:680:	  lnode = E->IEN[lev][m][el].node[a];
Size_does_matter.c:681:	  sintt = E->SinCos[lev][m][0][lnode];
Size_does_matter.c:682:	  sinff = E->SinCos[lev][m][1][lnode];
Size_does_matter.c:683:	  costt = E->SinCos[lev][m][2][lnode];
Size_does_matter.c:684:	  cosff = E->SinCos[lev][m][3][lnode];
Size_does_matter.c:720:  const int dims=E->mesh.nsd;
Size_does_matter.c:732:	  x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Size_does_matter.c:733:	    *E->M.vpt[GMVINDEX(aa,k)];
Size_does_matter.c:765:	lnode = E->IEN[lev][m][el].node[a];
Size_does_matter.c:766:	sintt = E->SinCos[lev][m][0][lnode];
Size_does_matter.c:767:	sinff = E->SinCos[lev][m][1][lnode];
Size_does_matter.c:768:	costt = E->SinCos[lev][m][2][lnode];
Size_does_matter.c:769:	cosff = E->SinCos[lev][m][3][lnode];
Size_does_matter.c:790:      for(d=1;d<=E->mesh.nsd;d++)
Size_does_matter.c:794:       	x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[aa]]
Size_does_matter.c:795:       	  *E->M.ppt[GMPINDEX(a,k)];
Size_does_matter.c:824:	lnode = E->IEN[lev][m][el].node[aa];
Size_does_matter.c:825:	sintt = E->SinCos[lev][m][0][lnode];
Size_does_matter.c:826:	sinff = E->SinCos[lev][m][1][lnode];
Size_does_matter.c:827:	costt = E->SinCos[lev][m][2][lnode];
Size_does_matter.c:828:	cosff = E->SinCos[lev][m][3][lnode];
Size_does_matter.c:834:	for (i=1;i<=E->mesh.nsd;i++) {
Size_does_matter.c:835:	  for (j=1;j<=E->mesh.nsd;j++) {
Size_does_matter.c:861:  const int dims=E->mesh.nsd;
Size_does_matter.c:866: for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Size_does_matter.c:867:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Size_does_matter.c:868:    nel_surface = E->lmesh.NEL[lev]/E->lmesh.ELZ[lev];
Size_does_matter.c:871:      el = es*E->lmesh.ELZ[lev];
Size_does_matter.c:879:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Size_does_matter.c:880:                   *E->N.vpt[GNVINDEX(a,k)];
Size_does_matter.c:908:	  lnode = E->IEN[lev][m][el].node[a];
Size_does_matter.c:909:	  sintt = E->SinCos[lev][m][0][lnode];
Size_does_matter.c:910:	  sinff = E->SinCos[lev][m][1][lnode];
Size_does_matter.c:911:	  costt = E->SinCos[lev][m][2][lnode];
Size_does_matter.c:912:	  cosff = E->SinCos[lev][m][3][lnode];
Size_does_matter.c:920:              E->CC[lev][m][es].vpt[BVINDEX(i,j,a,k)] =
Size_does_matter.c:922:              E->CCX[lev][m][es].vpt[BVXINDEX(i,j,1,a,k)] =
Size_does_matter.c:924:              E->CCX[lev][m][es].vpt[BVXINDEX(i,j,2,a,k)] =
Size_does_matter.c:937:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Size_does_matter.c:938:                   *E->N.ppt[GNPINDEX(a,k)];
Size_does_matter.c:966:	  lnode = E->IEN[lev][m][el].node[a];
Size_does_matter.c:967:	  sintt = E->SinCos[lev][m][0][lnode];
Size_does_matter.c:968:	  sinff = E->SinCos[lev][m][1][lnode];
Size_does_matter.c:969:	  costt = E->SinCos[lev][m][2][lnode];
Size_does_matter.c:970:	  cosff = E->SinCos[lev][m][3][lnode];
Size_does_matter.c:979:              E->CC[lev][m][es].ppt[BPINDEX(i,j,a,k)] =
Size_does_matter.c:981:              E->CCX[lev][m][es].ppt[BPXINDEX(i,j,1,a,k)] =
Size_does_matter.c:983:              E->CCX[lev][m][es].ppt[BPXINDEX(i,j,2,a,k)] =
Size_does_matter.c:1014:    const int vpts=vpoints[E->mesh.nsd];
Size_does_matter.c:1018:    for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Size_does_matter.c:1019:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Size_does_matter.c:1021:            for(node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:1022:                E->MASS[lev][m][node] = 0.0;
Size_does_matter.c:1024:            for(e=1;e<=E->lmesh.NEL[lev];e++)  {
Size_does_matter.c:1028:                for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:1029:                    n[node] = E->IEN[lev][m][e].node[node];
Size_does_matter.c:1031:                for(i=1;i<=E->mesh.nsd;i++)  {
Size_does_matter.c:1032:                    for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:1033:                        centre[i] += E->X[lev][m][i][n[node]];
Size_does_matter.c:1035:                    centre[i] = centre[i]/enodes[E->mesh.nsd];
Size_does_matter.c:1044:                E->ECO[lev][m][e].centre[1] = dx1;
Size_does_matter.c:1045:                E->ECO[lev][m][e].centre[2] = dx2;
Size_does_matter.c:1046:                E->ECO[lev][m][e].centre[3] = dx3;
Size_does_matter.c:1049:                dx1 = max( fabs(E->SX[lev][m][1][n[3]]-E->SX[lev][m][1][n[1]]),
Size_does_matter.c:1050:                           fabs(E->SX[lev][m][1][n[2]]-E->SX[lev][m][1][n[4]]) );
Size_does_matter.c:1053:                E->ECO[lev][m][e].size[1] = dx1*E->ECO[lev][m][e].centre[3];
Size_does_matter.c:1056:                dx1 = fabs(E->SX[lev][m][2][n[3]]-E->SX[lev][m][2][n[1]]);
Size_does_matter.c:1058:                    dx1 = min(E->SX[lev][m][2][n[3]],E->SX[lev][m][2][n[1]]) + 2.0*M_PI -
Size_does_matter.c:1059:                        max(E->SX[lev][m][2][n[3]],E->SX[lev][m][2][n[1]]) ;
Size_does_matter.c:1061:                dx2 = fabs(E->SX[lev][m][2][n[2]]-E->SX[lev][m][2][n[4]]);
Size_does_matter.c:1063:                    dx2 = min(E->SX[lev][m][2][n[2]],E->SX[lev][m][2][n[4]]) + 2.0*M_PI -
Size_does_matter.c:1064:                        max(E->SX[lev][m][2][n[2]],E->SX[lev][m][2][n[4]]) ;
Size_does_matter.c:1069:                E->ECO[lev][m][e].size[2] = dx2*E->ECO[lev][m][e].centre[3]
Size_does_matter.c:1070:                    *sin(E->ECO[lev][m][e].centre[1]);
Size_does_matter.c:1073:                dx3 = 0.25*(fabs(E->SX[lev][m][3][n[5]]+E->SX[lev][m][3][n[6]]
Size_does_matter.c:1074:                                 +E->SX[lev][m][3][n[7]]+E->SX[lev][m][3][n[8]]
Size_does_matter.c:1075:                                 -E->SX[lev][m][3][n[1]]-E->SX[lev][m][3][n[2]]
Size_does_matter.c:1076:                                 -E->SX[lev][m][3][n[3]]-E->SX[lev][m][3][n[4]]));
Size_does_matter.c:1079:                E->ECO[lev][m][e].size[3] = dx3;
Size_does_matter.c:1083:                    area += g_point[nint].weight[E->mesh.nsd-1] * E->GDA[lev][m][e].vpt[nint];
Size_does_matter.c:1084:                E->ECO[lev][m][e].area = area;
Size_does_matter.c:1086:                for(node=1;node<=enodes[E->mesh.nsd];node++)  {
Size_does_matter.c:1089:                        temp[node] += E->GDA[lev][m][e].vpt[nint]*g_point[nint].weight[E->mesh.nsd-1]
Size_does_matter.c:1090:                            *E->N.vpt[GNVINDEX(node,nint)];       /* int Na dV */
Size_does_matter.c:1093:                for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:1094:                    E->MASS[lev][m][E->IEN[lev][m][e].node[node]] += temp[node];
Size_does_matter.c:1097:                for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:1098:                    E->TWW[lev][m][e].node[node] = temp[node];
Size_does_matter.c:1105:        if(lev == E->mesh.levmax)
Size_does_matter.c:1106:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:1107:                for(node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:1108:                    E->NMass[m][node] = E->MASS[lev][m][node];
Size_does_matter.c:1110:        if (E->control.NMULTIGRID||E->mesh.levmax==lev)
Size_does_matter.c:1111:            (E->exchange_node_d)(E,E->MASS[lev],lev);
Size_does_matter.c:1113:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:1114:            for(node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:1115:                E->MASS[lev][m][node] = 1.0/E->MASS[lev][m][node];
Size_does_matter.c:1120:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
Size_does_matter.c:1122:        for(node=1;node<=E->lmesh.nno;node++)
Size_does_matter.c:1123:            E->TMass[m][node] = 0.0;
Size_does_matter.c:1125:        for(e=1;e<=E->lmesh.nel;e++)  {
Size_does_matter.c:1126:            for(node=1;node<=enodes[E->mesh.nsd];node++) {
Size_does_matter.c:1128:                nz = ((E->ien[m][e].node[node]-1) % E->lmesh.noz) + 1;
Size_does_matter.c:1130:                    temp[node] += E->refstate.rho[nz]
Size_does_matter.c:1131:                        * E->refstate.heat_capacity[nz]
Size_does_matter.c:1132:                        * E->gDA[m][e].vpt[nint]
Size_does_matter.c:1133:                        * g_point[nint].weight[E->mesh.nsd-1]
Size_does_matter.c:1134:                        * E->N.vpt[GNVINDEX(node,nint)];
Size_does_matter.c:1138:            for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:1139:                E->TMass[m][E->ien[m][e].node[node]] += temp[node];
Size_does_matter.c:1144:    (E->exchange_node_d)(E,E->TMass,E->mesh.levmax);
Size_does_matter.c:1145:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:1146:        for(node=1;node<=E->lmesh.nno;node++)
Size_does_matter.c:1147:            E->TMass[m][node] = 1.0 / E->TMass[m][node];
Size_does_matter.c:1151:    E->lmesh.volume = 0;
Size_does_matter.c:1152:    E->mesh.volume = 0;
Size_does_matter.c:1154:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:1155:        for(e=1;e<=E->lmesh.nel;e++)
Size_does_matter.c:1156:            E->lmesh.volume += E->eco[m][e].area;
Size_does_matter.c:1158:    MPI_Allreduce(&E->lmesh.volume, &E->mesh.volume, 1, MPI_DOUBLE,
Size_does_matter.c:1159:                  MPI_SUM, E->parallel.world);
Size_does_matter.c:1162:    if (E->control.verbose)  {
Size_does_matter.c:1163:        fprintf(E->fp_out, "rank=%d my_volume=%e total_volume=%e\n",
Size_does_matter.c:1164:                E->parallel.me, E->lmesh.volume, E->mesh.volume);
Size_does_matter.c:1166:        for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Size_does_matter.c:1167:            fprintf(E->fp_out,"output_mass lev=%d\n",lev);
Size_does_matter.c:1168:            for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Size_does_matter.c:1169:                fprintf(E->fp_out,"m=%d %d \n",E->sphere.capid[m],m);
Size_does_matter.c:1170:                for(e=1;e<=E->lmesh.NEL[lev];e++)
Size_does_matter.c:1171:                    fprintf(E->fp_out,"%d %g \n",e,E->ECO[lev][m][e].area);
Size_does_matter.c:1172:                for (node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:1173:                    fprintf(E->fp_out,"Mass[%d]= %g \n",node,E->MASS[lev][m][node]);
Size_does_matter.c:1177:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Size_does_matter.c:1178:            fprintf(E->fp_out,"m=%d %d \n",E->sphere.capid[m],m);
Size_does_matter.c:1179:            for (node=1;node<=E->lmesh.nno;node++)
Size_does_matter.c:1180:                fprintf(E->fp_out,"TMass[%d]= %g \n",node,E->TMass[m][node]);
Size_does_matter.c:1182:        fflush(E->fp_out);
Solver_conj_grad.c:37:  E->control.CONJ_GRAD = 1;
Solver_conj_grad.c:38:  E->build_forcing_term =   assemble_forces_iterative;
Solver_conj_grad.c:39:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Solver_conj_grad.c:40:  E->solver_allocate_vars = cg_allocate_vars;
Solver_conj_grad.c:66:  strip_bcs_from_residual(E,E->F,E->mesh.levmax);
Solver_multigrid.c:41:  E->control.NMULTIGRID = 1;
Solver_multigrid.c:42:  E->build_forcing_term =   assemble_forces_iterative;
Solver_multigrid.c:43:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Solver_multigrid.c:44:  E->solver_allocate_vars = mg_allocate_vars;
Solver_multigrid.c:72:    const int dims = E->mesh.nsd;
Solver_multigrid.c:75:    if(start_lev == E->mesh.levmin)   {
Solver_multigrid.c:76:        fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Solver_multigrid.c:83:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:84:      for(el=1;el<=E->lmesh.NEL[sl_minus];el++)
Solver_multigrid.c:86:          node_coarse = E->IEN[sl_minus][m][el].node[i];
Solver_multigrid.c:87:          node_fine=E->IEN[start_lev][m][E->EL[sl_minus][m][el].sub[i]].node[i];
Solver_multigrid.c:102:    const int dims = E->mesh.nsd;
Solver_multigrid.c:107:    if(start_lev == E->mesh.levmin)   {
Solver_multigrid.c:108:        fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Solver_multigrid.c:114:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:115:      for(el=1;el<=E->lmesh.NEL[sl_minus];el++)
Solver_multigrid.c:117:          node_coarse = E->IEN[sl_minus][m][el].node[i];
Solver_multigrid.c:118:          node_fine=E->IEN[start_lev][m][E->EL[sl_minus][m][el].sub[i]].node[i];
Solver_multigrid.c:120:            eqn_fine   = E->ID[start_lev][m][node_fine].doff[j];
Solver_multigrid.c:121:            eqn_coarse = E->ID[sl_minus][m][node_coarse].doff[j];
Solver_multigrid.c:147:    const int dims = E->mesh.nsd;
Solver_multigrid.c:150:    const int neq = E->lmesh.NEQ[sl_plus];
Solver_multigrid.c:151:    const int nels = E->lmesh.NEL[start_lev];
Solver_multigrid.c:153:    assert(start_lev != E->mesh.levmax  /* un_injection */);
Solver_multigrid.c:155:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:159:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:162:          node = E->IEN[start_lev][m][el].node[i];
Solver_multigrid.c:163:	  node_plus=E->IEN[sl_plus][m][E->EL[start_lev][m][el].sub[i]].node[i];
Solver_multigrid.c:165:	  eqn1 = E->ID[start_lev][m][node].doff[1];
Solver_multigrid.c:166:	  eqn2 = E->ID[start_lev][m][node].doff[2];
Solver_multigrid.c:167:	  eqn3 = E->ID[start_lev][m][node].doff[3];
Solver_multigrid.c:168:	  eqn_plus1 = E->ID[sl_plus][m][node_plus].doff[1];
Solver_multigrid.c:169:	  eqn_plus2 = E->ID[sl_plus][m][node_plus].doff[2];
Solver_multigrid.c:170:	  eqn_plus3 = E->ID[sl_plus][m][node_plus].doff[3];
Solver_multigrid.c:206:    const int dims =E->mesh.nsd;
Solver_multigrid.c:209:    const int nox = E->lmesh.NOX[level];
Solver_multigrid.c:210:    const int noz = E->lmesh.NOZ[level];
Solver_multigrid.c:211:    const int noy = E->lmesh.NOY[level];
Solver_multigrid.c:212:    const int high_eqn = E->lmesh.NEQ[level];
Solver_multigrid.c:214:    if (start_lev==E->mesh.levmax) return;
Solver_multigrid.c:217:    un_inject_vector(E,start_lev,AU,E->temp); /*  information from lower level */
Solver_multigrid.c:218:    fill_in_gaps(E,E->temp,level);
Solver_multigrid.c:219:    from_xyz_to_rtf(E,level,E->temp,AU);      /* get back to rtf coordinates */
Solver_multigrid.c:246:    const int nsd=E->mesh.nsd;
Solver_multigrid.c:251:  lv = E->mesh.levmax;
Solver_multigrid.c:253:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Solver_multigrid.c:254:    viscU[m]=(float *)malloc((1+E->lmesh.NNO[lv])*sizeof(float));
Solver_multigrid.c:255:    viscD[m]=(float *)malloc((1+vpts*E->lmesh.NEL[lv-1])*sizeof(float));
Solver_multigrid.c:259:  if(E->viscosity.allow_anisotropic_viscosity){
Solver_multigrid.c:260:    for(lv=E->mesh.levmax;lv>E->mesh.levmin;lv--)     {
Solver_multigrid.c:262:      if (E->viscosity.smooth_cycles==1)  {
Solver_multigrid.c:263:	visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);	/* isotropic */
Solver_multigrid.c:265:	visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:267:	visc_from_gint_to_nodes(E,E->EVI2[lv],viscU,lv);project_scalar(E,lv,viscU,viscD);visc_from_nodes_to_gint(E,viscD,E->EVI2[sl_minus],sl_minus);
Solver_multigrid.c:268:	visc_from_gint_to_nodes(E,E->EVIn1[lv],viscU,lv);project_scalar(E,lv,viscU,viscD);visc_from_nodes_to_gint(E,viscD,E->EVIn1[sl_minus],sl_minus);
Solver_multigrid.c:269:	visc_from_gint_to_nodes(E,E->EVIn2[lv],viscU,lv);project_scalar(E,lv,viscU,viscD);visc_from_nodes_to_gint(E,viscD,E->EVIn2[sl_minus],sl_minus);
Solver_multigrid.c:270:	visc_from_gint_to_nodes(E,E->EVIn3[lv],viscU,lv);project_scalar(E,lv,viscU,viscD);visc_from_nodes_to_gint(E,viscD,E->EVIn3[sl_minus],sl_minus);
Solver_multigrid.c:272:      else if (E->viscosity.smooth_cycles==2)   {
Solver_multigrid.c:273:	visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv); /* isotropic */
Solver_multigrid.c:274:	inject_scalar_e(E,lv,viscU,E->EVI[sl_minus]);
Solver_multigrid.c:276:	visc_from_gint_to_ele(E,E->EVI2[lv],viscU,lv);inject_scalar_e(E,lv,viscU,E->EVI2[sl_minus]);
Solver_multigrid.c:277:	visc_from_gint_to_ele(E,E->EVIn1[lv],viscU,lv);inject_scalar_e(E,lv,viscU,E->EVIn1[sl_minus]);
Solver_multigrid.c:278:	visc_from_gint_to_ele(E,E->EVIn2[lv],viscU,lv);inject_scalar_e(E,lv,viscU,E->EVIn2[sl_minus]);
Solver_multigrid.c:279:	visc_from_gint_to_ele(E,E->EVIn3[lv],viscU,lv);inject_scalar_e(E,lv,viscU,E->EVIn3[sl_minus]);
Solver_multigrid.c:281:      else if (E->viscosity.smooth_cycles==3)   {
Solver_multigrid.c:282:	visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);/* isotropic */
Solver_multigrid.c:284:	visc_from_ele_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:286:	visc_from_gint_to_ele(E,E->EVI2[lv],viscU,lv);project_scalar_e(E,lv,viscU,viscD);visc_from_ele_to_gint(E,viscD,E->EVI2[sl_minus],sl_minus);
Solver_multigrid.c:287:	visc_from_gint_to_ele(E,E->EVIn1[lv],viscU,lv);project_scalar_e(E,lv,viscU,viscD);visc_from_ele_to_gint(E,viscD,E->EVIn1[sl_minus],sl_minus);
Solver_multigrid.c:288:	visc_from_gint_to_ele(E,E->EVIn2[lv],viscU,lv);project_scalar_e(E,lv,viscU,viscD);visc_from_ele_to_gint(E,viscD,E->EVIn2[sl_minus],sl_minus);
Solver_multigrid.c:289:	visc_from_gint_to_ele(E,E->EVIn3[lv],viscU,lv);project_scalar_e(E,lv,viscU,viscD);visc_from_ele_to_gint(E,viscD,E->EVIn3[sl_minus],sl_minus);
Solver_multigrid.c:291:      else if (E->viscosity.smooth_cycles==0)  {
Solver_multigrid.c:292:	inject_scalar(E,lv,E->VI[lv],E->VI[sl_minus]);/* isotropic */
Solver_multigrid.c:293:	visc_from_nodes_to_gint(E,E->VI[sl_minus],E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:295:	inject_scalar(E,lv,E->VI2[lv],E->VI2[sl_minus]);visc_from_nodes_to_gint(E,E->VI2[sl_minus],E->EVI2[sl_minus],sl_minus);
Solver_multigrid.c:296:	inject_scalar(E,lv,E->VIn1[lv],E->VIn1[sl_minus]);visc_from_nodes_to_gint(E,E->VIn1[sl_minus],E->EVIn1[sl_minus],sl_minus);
Solver_multigrid.c:297:	inject_scalar(E,lv,E->VIn2[lv],E->VIn2[sl_minus]);visc_from_nodes_to_gint(E,E->VIn2[sl_minus],E->EVIn2[sl_minus],sl_minus);
Solver_multigrid.c:298:	inject_scalar(E,lv,E->VIn3[lv],E->VIn3[sl_minus]);visc_from_nodes_to_gint(E,E->VIn3[sl_minus],E->EVIn3[sl_minus],sl_minus);
Solver_multigrid.c:300:      normalize_director_at_gint(E,E->EVIn1[sl_minus],E->EVIn2[sl_minus],E->EVIn3[sl_minus],sl_minus);      
Solver_multigrid.c:305:    for(lv=E->mesh.levmax;lv>E->mesh.levmin;lv--)     {
Solver_multigrid.c:309:      if (E->viscosity.smooth_cycles==1)  {
Solver_multigrid.c:310:	visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:312:	visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:314:      else if (E->viscosity.smooth_cycles==2)   {
Solver_multigrid.c:315:	visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:316:	inject_scalar_e(E,lv,viscU,E->EVI[sl_minus]);
Solver_multigrid.c:318:      else if (E->viscosity.smooth_cycles==3)   {
Solver_multigrid.c:319:	visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:321:	visc_from_ele_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:323:      else if (E->viscosity.smooth_cycles==0)  {
Solver_multigrid.c:324:	/*      visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:326:		visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus); */
Solver_multigrid.c:328:	inject_scalar(E,lv,E->VI[lv],E->VI[sl_minus]);
Solver_multigrid.c:329:	visc_from_nodes_to_gint(E,E->VI[sl_minus],E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:333:/*        for(m=1;m<=E->sphere.caps_per_proc;m++) {
Solver_multigrid.c:334:            for (i=1;i<=E->lmesh.NEL[lv-1];i++)
Solver_multigrid.c:335:               fprintf (E->fp_out,"%d %g\n",i,viscD[m][i]);
Solver_multigrid.c:336:            for (i=1;i<=E->lmesh.NEL[lv];i++)
Solver_multigrid.c:337:               fprintf (E->fp_out,"%d %g\n",i,viscU[m][i]);
Solver_multigrid.c:344:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Solver_multigrid.c:365:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:366:    const int dims=E->mesh.nsd;
Solver_multigrid.c:367:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:368:    const int vpts=vpoints[E->mesh.nsd];
Solver_multigrid.c:372: for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:376:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:379:                e = E->EL[sl_minus][m][el].sub[i];
Solver_multigrid.c:399:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:400:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:401:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:403:    const int vpts=vpoints[E->mesh.nsd];
Solver_multigrid.c:407: for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:412:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:416:                e = E->EL[sl_minus][m][el].sub[i];
Solver_multigrid.c:438:    const int nno_minus=E->lmesh.NNO[start_lev-1];
Solver_multigrid.c:439:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:440:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:441:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:445: for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:449:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:453:                node1 = E->EL[sl_minus][m][el].sub[i];
Solver_multigrid.c:455:                    node=E->IEN[start_lev][m][node1].node[j];
Solver_multigrid.c:461:                node= E->IEN[sl_minus][m][el].node[i];
Solver_multigrid.c:463:                AD[m][node] += w * E->TWW[sl_minus][m][el].node[i];
Solver_multigrid.c:466:   (E->exchange_node_f)(E,AD,sl_minus);
Solver_multigrid.c:468:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:470:       AD[m][i] *= E->MASS[sl_minus][m][i];
Solver_multigrid.c:498:    const int neq_minus=E->lmesh.NEQ[start_lev-1];
Solver_multigrid.c:499:    const int nno_minus=E->lmesh.NNO[start_lev-1];
Solver_multigrid.c:500:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:501:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:502:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:510:   if (start_lev==E->mesh.levmin) return;
Solver_multigrid.c:513:      from_rtf_to_xyz(E,start_lev,AU,E->temp);
Solver_multigrid.c:515:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:517:        E->temp1[m][i] = 0.0;
Solver_multigrid.c:520:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:523:                node= E->IEN[sl_minus][m][el].node[i];
Solver_multigrid.c:525:		e1 = E->EL[sl_minus][m][el].sub[i];
Solver_multigrid.c:527:		    node1=E->IEN[start_lev][m][e1].node[j];
Solver_multigrid.c:528:		    average1 += E->temp[m][E->ID[start_lev][m][node1].doff[1]];
Solver_multigrid.c:529:		    average2 += E->temp[m][E->ID[start_lev][m][node1].doff[2]];
Solver_multigrid.c:530:		    average3 += E->temp[m][E->ID[start_lev][m][node1].doff[3]];
Solver_multigrid.c:532:		w = weight*E->TWW[sl_minus][m][el].node[i];
Solver_multigrid.c:534:		E->temp1[m][E->ID[sl_minus][m][node].doff[1]] += w * average1;
Solver_multigrid.c:535:		E->temp1[m][E->ID[sl_minus][m][node].doff[2]] += w * average2;
Solver_multigrid.c:536:	 	E->temp1[m][E->ID[sl_minus][m][node].doff[3]] += w * average3;
Solver_multigrid.c:540:   (E->solver.exchange_id_d)(E, E->temp1, sl_minus);
Solver_multigrid.c:542:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:544:       E->temp1[m][E->ID[sl_minus][m][i].doff[1]] *= E->MASS[sl_minus][m][i];
Solver_multigrid.c:545:       E->temp1[m][E->ID[sl_minus][m][i].doff[2]] *= E->MASS[sl_minus][m][i];
Solver_multigrid.c:546:       E->temp1[m][E->ID[sl_minus][m][i].doff[3]] *= E->MASS[sl_minus][m][i];
Solver_multigrid.c:550:   from_xyz_to_rtf(E,sl_minus,E->temp1,AD);
Solver_multigrid.c:565: for (m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:566:   for (i=1;i<=E->lmesh.NNO[level];i++)  {
Solver_multigrid.c:567:     eqn1 = E->ID[level][m][i].doff[1];
Solver_multigrid.c:568:     eqn2 = E->ID[level][m][i].doff[2];
Solver_multigrid.c:569:     eqn3 = E->ID[level][m][i].doff[3];
Solver_multigrid.c:570:     sint = E->SinCos[level][m][0][i];
Solver_multigrid.c:571:     sinf = E->SinCos[level][m][1][i];
Solver_multigrid.c:572:     cost = E->SinCos[level][m][2][i];
Solver_multigrid.c:573:     cosf = E->SinCos[level][m][3][i];
Solver_multigrid.c:597: for (m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:598:   for (i=1;i<=E->lmesh.NNO[level];i++)  {
Solver_multigrid.c:599:     eqn1 = E->ID[level][m][i].doff[1];
Solver_multigrid.c:600:     eqn2 = E->ID[level][m][i].doff[2];
Solver_multigrid.c:601:     eqn3 = E->ID[level][m][i].doff[3];
Solver_multigrid.c:602:     sint = E->SinCos[level][m][0][i];
Solver_multigrid.c:603:     sinf = E->SinCos[level][m][1][i];
Solver_multigrid.c:604:     cost = E->SinCos[level][m][2][i];
Solver_multigrid.c:605:     cosf = E->SinCos[level][m][3][i];
Solver_multigrid.c:633:    const int dims =E->mesh.nsd;
Solver_multigrid.c:636:    const int nox = E->lmesh.NOX[level];
Solver_multigrid.c:637:    const int noz = E->lmesh.NOZ[level];
Solver_multigrid.c:638:    const int noy = E->lmesh.NOY[level];
Solver_multigrid.c:641:  for(m=1;m<=E->sphere.caps_per_proc;m++)       {
Solver_multigrid.c:653:	      eqn0=E->ID[level][m][node0].doff[1];
Solver_multigrid.c:654:	      eqn1=E->ID[level][m][node1].doff[1];
Solver_multigrid.c:655:	      eqn2=E->ID[level][m][node2].doff[1];
Solver_multigrid.c:658:	      eqn0=E->ID[level][m][node0].doff[2];
Solver_multigrid.c:659:	      eqn1=E->ID[level][m][node1].doff[2];
Solver_multigrid.c:660:	      eqn2=E->ID[level][m][node2].doff[2];
Solver_multigrid.c:663:	      eqn0=E->ID[level][m][node0].doff[3];
Solver_multigrid.c:664:	      eqn1=E->ID[level][m][node1].doff[3];
Solver_multigrid.c:665:	      eqn2=E->ID[level][m][node2].doff[3];
Solver_multigrid.c:677:	        eqn0=E->ID[level][m][node0].doff[1];
Solver_multigrid.c:678:	        eqn1=E->ID[level][m][node1].doff[1];
Solver_multigrid.c:679:	        eqn2=E->ID[level][m][node2].doff[1];
Solver_multigrid.c:682:	        eqn0=E->ID[level][m][node0].doff[2];
Solver_multigrid.c:683:	        eqn1=E->ID[level][m][node1].doff[2];
Solver_multigrid.c:684:	        eqn2=E->ID[level][m][node2].doff[2];
Solver_multigrid.c:687:	        eqn0=E->ID[level][m][node0].doff[3];
Solver_multigrid.c:688:	        eqn1=E->ID[level][m][node1].doff[3];
Solver_multigrid.c:689:	        eqn2=E->ID[level][m][node2].doff[3];
Solver_multigrid.c:695:       x1 = E->sphere.R[level][j] - E->sphere.R[level][j-1];
Solver_multigrid.c:696:       x2 = E->sphere.R[level][j+1] - E->sphere.R[level][j];
Solver_multigrid.c:705:	        eqn0=E->ID[level][m][node0].doff[1];
Solver_multigrid.c:706:	        eqn1=E->ID[level][m][node1].doff[1];
Solver_multigrid.c:707:	        eqn2=E->ID[level][m][node2].doff[1];
Solver_multigrid.c:710:	        eqn0=E->ID[level][m][node0].doff[2];
Solver_multigrid.c:711:	        eqn1=E->ID[level][m][node1].doff[2];
Solver_multigrid.c:712:	        eqn2=E->ID[level][m][node2].doff[2];
Solver_multigrid.c:715:	        eqn0=E->ID[level][m][node0].doff[3];
Solver_multigrid.c:716:	        eqn1=E->ID[level][m][node1].doff[3];
Solver_multigrid.c:717:	        eqn2=E->ID[level][m][node2].doff[3];
Sphere_harmonics.c:22:    for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:24:            E->sphere.hindex[ll][mm] = i;
Sphere_harmonics.c:28:    E->sphere.hindice = i;
Sphere_harmonics.c:33:        E->sphere.harm_geoid[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:34:        E->sphere.harm_geoid_from_bncy[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:35:        E->sphere.harm_geoid_from_bncy_botm[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:36:        E->sphere.harm_geoid_from_tpgt[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:37:        E->sphere.harm_geoid_from_tpgb[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:39:        E->sphere.harm_tpgt[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:40:        E->sphere.harm_tpgb[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:110:    for (i=0;i<E->sphere.hindice;i++)    {
Sphere_harmonics.c:115:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Sphere_harmonics.c:116:        for (es=1;es<=E->lmesh.snel;es++)   {
Sphere_harmonics.c:118:            for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:121:                    p = E->sphere.hindex[ll][mm];
Sphere_harmonics.c:123:                    for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Sphere_harmonics.c:124:                        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)   {
Sphere_harmonics.c:125:                            j = E->sien[m][es].node[d];
Sphere_harmonics.c:126:                            sphc[p] += TG[m][E->sien[m][es].node[d]]
Sphere_harmonics.c:127:                                * E->sphere.tablesplm[m][j][p]
Sphere_harmonics.c:128:                                * E->sphere.tablescosf[m][j][mm]
Sphere_harmonics.c:129:                                * E->M.vpt[GMVINDEX(d,nint)]
Sphere_harmonics.c:130:                                * E->surf_det[m][nint][es];
Sphere_harmonics.c:131:                            sphs[p] += TG[m][E->sien[m][es].node[d]]
Sphere_harmonics.c:132:                                * E->sphere.tablesplm[m][j][p]
Sphere_harmonics.c:133:                                * E->sphere.tablessinf[m][j][mm]
Sphere_harmonics.c:134:                                * E->M.vpt[GMVINDEX(d,nint)]
Sphere_harmonics.c:135:                                * E->surf_det[m][nint][es];
Sphere_harmonics.c:158:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Sphere_harmonics.c:159:        TT[m] = (float *) malloc ((E->lmesh.nsf+1)*sizeof(float));
Sphere_harmonics.c:162:    sph_harm[0] = (float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:164:    sph_harm[1] = (float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:166:    for(k=1;k<=E->lmesh.noz;k++)  {
Sphere_harmonics.c:167:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Sphere_harmonics.c:168:            for(i=1;i<=E->lmesh.noy;i++)
Sphere_harmonics.c:169:                for(j=1;j<=E->lmesh.nox;j++)  {
Sphere_harmonics.c:170:                    node= k + (j-1)*E->lmesh.noz + (i-1)*E->lmesh.nox*E->lmesh.noz;
Sphere_harmonics.c:171:                    p = j + (i-1)*E->lmesh.nox;
Sphere_harmonics.c:172:                    TT[m][p] = E->T[m][node];
Sphere_harmonics.c:179:        if(E->parallel.me < E->parallel.nprocz) {
Sphere_harmonics.c:180:            for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:182:                    p = E->sphere.hindex[ll][mm];
Sphere_harmonics.c:184:                            k+E->lmesh.nzs-1, ll, mm,
Sphere_harmonics.c:205:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Sphere_harmonics.c:206:        E->sphere.tablesplm[m]   = (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Sphere_harmonics.c:207:        E->sphere.tablescosf[m] = (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Sphere_harmonics.c:208:        E->sphere.tablessinf[m] = (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Sphere_harmonics.c:210:        for (i=1;i<=E->lmesh.nsf;i++)   {
Sphere_harmonics.c:211:            E->sphere.tablesplm[m][i]= (double *)malloc((E->sphere.hindice)*sizeof(double));
Sphere_harmonics.c:212:            E->sphere.tablescosf[m][i]= (double *)malloc((E->output.llmax+1)*sizeof(double));
Sphere_harmonics.c:213:            E->sphere.tablessinf[m][i]= (double *)malloc((E->output.llmax+1)*sizeof(double));
Sphere_harmonics.c:217:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Sphere_harmonics.c:218:        for (j=1;j<=E->lmesh.nsf;j++)  {
Sphere_harmonics.c:219:            node = j*E->lmesh.noz;
Sphere_harmonics.c:220:            f=E->sx[m][2][node];
Sphere_harmonics.c:221:            t=E->sx[m][1][node];
Sphere_harmonics.c:222:            for (mm=0;mm<=E->output.llmax;mm++)   {
Sphere_harmonics.c:224:                E->sphere.tablescosf[m][j][mm] = cos( mmf );
Sphere_harmonics.c:225:                E->sphere.tablessinf[m][j][mm] = sin( mmf );
Sphere_harmonics.c:228:            for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:230:                    p = E->sphere.hindex[ll][mm];
Sphere_harmonics.c:231:                    E->sphere.tablesplm[m][j][p] = modified_plgndr_a(ll,mm,t) ;
Sphere_util.c:76:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Sphere_util.c:78:        ia[2] = E->lmesh.noz*E->lmesh.nox-E->lmesh.noz+1;
Sphere_util.c:79:        ia[3] = E->lmesh.nno-E->lmesh.noz+1;
Sphere_util.c:80:        ia[4] = ia[3]-E->lmesh.noz*(E->lmesh.nox-1);
Sphere_util.c:83:            xx[1][i] = E->x[m][1][ia[i]]/E->sx[m][3][ia[1]];
Sphere_util.c:84:            xx[2][i] = E->x[m][2][ia[i]]/E->sx[m][3][ia[1]];
Sphere_util.c:85:            xx[3][i] = E->x[m][3][ia[i]]/E->sx[m][3][ia[1]];
Sphere_util.c:91:            E->sphere.angle[m][i] = angle[i];
Sphere_util.c:93:        E->sphere.area[m] = area_sphere_cap(angle);
Sphere_util.c:95:        for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)
Sphere_util.c:96:            for (es=1;es<=E->lmesh.SNEL[lev];es++)              {
Sphere_util.c:97:                el = (es-1)*E->lmesh.ELZ[lev]+1;
Sphere_util.c:99:                    ia[i] = E->IEN[lev][m][el].node[i];
Sphere_util.c:102:                    xx[1][i] = E->X[lev][m][1][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:103:                    xx[2][i] = E->X[lev][m][2][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:104:                    xx[3][i] = E->X[lev][m][3][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:110:                    E->sphere.angle1[lev][m][i][es] = angle[i];
Sphere_util.c:112:                E->sphere.area1[lev][m][es] = area_sphere_cap(angle);
Sphere_util.c:114:/*              fprintf(E->fp_out,"lev%d %d %.6e %.6e %.6e %.6e %.6e\n",lev,es,angle[1],angle[2],angle[3],angle[4],E->sphere.area1[lev][m][es]); */
Sphere_util.c:189:        ia[i] = E->IEN[lev][m][el].node[i];
Sphere_util.c:191:    es = (el-1)/E->lmesh.ELZ[lev]+1;
Sphere_util.c:194:        xx[1] = E->X[lev][m][1][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:195:        xx[2] = E->X[lev][m][2][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:196:        xx[3] = E->X[lev][m][3][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:198:        angle1[i]= E->sphere.angle1[lev][m][i][es];
Stokes_flow_Incomp.c:70:    cycles=E->control.p_iterations;
Stokes_flow_Incomp.c:74:    solve_Ahat_p_fhat(E,E->U,E->P,E->F,E->control.accuracy,&cycles);
Stokes_flow_Incomp.c:76:    if(E->control.pseudo_free_surf)
Stokes_flow_Incomp.c:81:    p_to_nodes(E,E->P,E->NP,E->mesh.levmax);
Stokes_flow_Incomp.c:93:     * This norm is ~= E->monitor.momentum_residual */
Stokes_flow_Incomp.c:102:    const int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:103:    const int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:105:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:111:    assemble_grad_p(E, P, E->u1, lev);
Stokes_flow_Incomp.c:113:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:115:            r2[m][i] = F[m][i] - E->u1[m][i] - r1[m][i];
Stokes_flow_Incomp.c:121:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:138:    fprintf(E->fp, "(%03d) %5.1f s v=%e p=%e "
Stokes_flow_Incomp.c:141:            E->monitor.solution_cycles);
Stokes_flow_Incomp.c:145:            E->monitor.solution_cycles);
Stokes_flow_Incomp.c:156:    if(E->control.check_continuity_convergence)
Stokes_flow_Incomp.c:157:        return (E->monitor.incompressibility > acc) ||
Stokes_flow_Incomp.c:160:        return (E->monitor.incompressibility > acc) &&
Stokes_flow_Incomp.c:169:    if(E->control.inv_gruneisen == 0)
Stokes_flow_Incomp.c:172:        if(strcmp(E->control.uzawa, "cg") == 0)
Stokes_flow_Incomp.c:174:        else if(strcmp(E->control.uzawa, "bicg") == 0)
Stokes_flow_Incomp.c:218:    inner_imp = imp * E->control.inner_accuracy_scale; /* allow for different innner loop accuracy */
Stokes_flow_Incomp.c:220:    npno = E->lmesh.npno;
Stokes_flow_Incomp.c:221:    neq = E->lmesh.neq;
Stokes_flow_Incomp.c:222:    lev = E->mesh.levmax;
Stokes_flow_Incomp.c:224:    for (m=1; m<=E->sphere.caps_per_proc; m++)   {
Stokes_flow_Incomp.c:236:    v_res = E->monitor.fdotf;
Stokes_flow_Incomp.c:240:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:246:    if(E->control.inv_gruneisen != 0) {
Stokes_flow_Incomp.c:247:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:258:    if(E->control.inv_gruneisen == 0)
Stokes_flow_Incomp.c:267:    if(E->control.inv_gruneisen != 0)
Stokes_flow_Incomp.c:268:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:273:    E->monitor.vdotv = global_v_norm2(E, V);
Stokes_flow_Incomp.c:274:    E->monitor.incompressibility = sqrt(global_div_norm2(E, r1)
Stokes_flow_Incomp.c:275:                                        / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:277:    v_norm = sqrt(E->monitor.vdotv);
Stokes_flow_Incomp.c:278:    p_norm = sqrt(E->monitor.pdotp);
Stokes_flow_Incomp.c:283:    if (E->control.print_convergence && E->parallel.me==0)  {
Stokes_flow_Incomp.c:287:                                   E->monitor.incompressibility);
Stokes_flow_Incomp.c:297:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:299:                z1[m][j] = E->BPI[lev][m][j] * r1[m][j];
Stokes_flow_Incomp.c:308:            for (m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:314:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:321:        valid = solve_del2_u(E, E->u1, F, inner_imp*v_res, lev);
Stokes_flow_Incomp.c:322:        if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:324:            fputs("Warning: solver not converging! 1\n", E->fp);
Stokes_flow_Incomp.c:326:        strip_bcs_from_residual(E, E->u1, lev);
Stokes_flow_Incomp.c:330:        assemble_div_u(E, E->u1, F, lev);
Stokes_flow_Incomp.c:338:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:344:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:350:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:352:                V[m][j] -= alpha * E->u1[m][j];
Stokes_flow_Incomp.c:356:        E->monitor.vdotv = global_v_norm2(E, V);
Stokes_flow_Incomp.c:357:        E->monitor.pdotp = global_p_norm2(E, P);
Stokes_flow_Incomp.c:358:        v_norm = sqrt(E->monitor.vdotv);
Stokes_flow_Incomp.c:359:        p_norm = sqrt(E->monitor.pdotp);
Stokes_flow_Incomp.c:360:        dvelocity = alpha * sqrt(global_v_norm2(E, E->u1) / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:361:        dpressure = alpha * sqrt(global_p_norm2(E, s2) / (1e-32 + E->monitor.pdotp));
Stokes_flow_Incomp.c:366:        if(E->control.inv_gruneisen != 0)
Stokes_flow_Incomp.c:367:            for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:371:        E->monitor.incompressibility = sqrt(global_div_norm2(E, z1)
Stokes_flow_Incomp.c:372:                                            / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:377:        if (E->control.print_convergence && E->parallel.me==0)  {
Stokes_flow_Incomp.c:381:                                       E->monitor.incompressibility);
Stokes_flow_Incomp.c:389:            if(E->control.check_pressure_convergence) {
Stokes_flow_Incomp.c:406:        for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:418:	if((E->sphere.caps == 12) && (E->control.inner_remove_rigid_rotation)){
Stokes_flow_Incomp.c:421:	  if(E->control.pseudo_free_surf) /* move from U to V */
Stokes_flow_Incomp.c:431:    if(E->control.inv_gruneisen != 0)
Stokes_flow_Incomp.c:432:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:438:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:490:    inner_imp = imp * E->control.inner_accuracy_scale; /* allow for different innner loop accuracy */
Stokes_flow_Incomp.c:492:    npno = E->lmesh.npno;
Stokes_flow_Incomp.c:493:    neq = E->lmesh.neq;
Stokes_flow_Incomp.c:494:    lev = E->mesh.levmax;
Stokes_flow_Incomp.c:496:    for (m=1; m<=E->sphere.caps_per_proc; m++)   {
Stokes_flow_Incomp.c:514:    v_res = E->monitor.fdotf;
Stokes_flow_Incomp.c:518:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:530:    E->monitor.vdotv = global_v_norm2(E, V);
Stokes_flow_Incomp.c:531:    E->monitor.incompressibility = sqrt(global_div_norm2(E, r1)
Stokes_flow_Incomp.c:532:                                        / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:534:    v_norm = sqrt(E->monitor.vdotv);
Stokes_flow_Incomp.c:535:    p_norm = sqrt(E->monitor.pdotp);
Stokes_flow_Incomp.c:541:    if (E->control.print_convergence && E->parallel.me==0)  {
Stokes_flow_Incomp.c:545:                                   E->monitor.incompressibility);
Stokes_flow_Incomp.c:550:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:565:            fprintf(E->fp, "BiCGstab method failed!!\n");
Stokes_flow_Incomp.c:573:            for (m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:579:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:587:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:589:                pt[m][j] = E->BPI[lev][m][j] * p2[m][j];
Stokes_flow_Incomp.c:595:        if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:597:            fputs("Warning: solver not converging! 1\n", E->fp);
Stokes_flow_Incomp.c:611:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:617:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:619:                st[m][j] = E->BPI[lev][m][j] * s0[m][j];
Stokes_flow_Incomp.c:624:        valid = solve_del2_u(E, E->u1, F, inner_imp*v_res, lev);
Stokes_flow_Incomp.c:625:        if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:627:            fputs("Warning: solver not converging! 2\n", E->fp);
Stokes_flow_Incomp.c:629:        strip_bcs_from_residual(E, E->u1, lev);
Stokes_flow_Incomp.c:633:        assemble_div_rho_u(E, E->u1, t0, lev);
Stokes_flow_Incomp.c:641:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:647:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:651:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:657:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:659:                F[m][j] = alpha * u0[m][j] + omega * E->u1[m][j];
Stokes_flow_Incomp.c:661:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:667:        E->monitor.vdotv = global_v_norm2(E, V);
Stokes_flow_Incomp.c:668:        E->monitor.pdotp = global_p_norm2(E, P);
Stokes_flow_Incomp.c:669:        v_norm = sqrt(E->monitor.vdotv);
Stokes_flow_Incomp.c:670:        p_norm = sqrt(E->monitor.pdotp);
Stokes_flow_Incomp.c:671:        dvelocity = sqrt(global_v_norm2(E, F) / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:672:        dpressure = sqrt(global_p_norm2(E, s0) / (1e-32 + E->monitor.pdotp));
Stokes_flow_Incomp.c:678:        E->monitor.incompressibility = sqrt(global_div_norm2(E, t0)
Stokes_flow_Incomp.c:679:                                            / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:686:        if(E->control.print_convergence && E->parallel.me==0) {
Stokes_flow_Incomp.c:690:                                       E->monitor.incompressibility);
Stokes_flow_Incomp.c:698:            if(E->control.check_pressure_convergence) {
Stokes_flow_Incomp.c:715:        for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:731:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:767:    const int npno = E->lmesh.npno;
Stokes_flow_Incomp.c:768:    const int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:769:    const int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:775:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Stokes_flow_Incomp.c:782:    cycles = E->control.p_iterations;
Stokes_flow_Incomp.c:785:                         imp * E->control.inner_accuracy_scale * E->monitor.fdotf);
Stokes_flow_Incomp.c:794:          (num_of_loop <= E->control.compress_iter_maxstep)) {
Stokes_flow_Incomp.c:796:        for (m=1;m<=E->sphere.caps_per_proc;m++) {
Stokes_flow_Incomp.c:804:        assemble_div_rho_u(E, V, E->u1, lev);
Stokes_flow_Incomp.c:805:        div_res = sqrt(global_div_norm2(E, E->u1) / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:807:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:811:                               (1.0e-32 + E->monitor.vdotv) );
Stokes_flow_Incomp.c:813:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:817:                               (1.0e-32 + E->monitor.pdotp) );
Stokes_flow_Incomp.c:819:        if(E->parallel.me == 0) {
Stokes_flow_Incomp.c:821:            fprintf(E->fp, "itercg -- div(rho*v)/v=%.2e dv/v=%.2e and dp/p=%.2e loop %d\n\n", div_res, relative_err_v, relative_err_p, num_of_loop);
Stokes_flow_Incomp.c:828:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Stokes_flow_Incomp.c:848:    int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:849:    int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:853:    assemble_grad_p(E, P, E->u1, lev);
Stokes_flow_Incomp.c:854:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:856:            F[m][i] = F[m][i] - E->u1[m][i];
Stokes_flow_Incomp.c:858:    assemble_del2_u(E, V, E->u1, lev, 1);
Stokes_flow_Incomp.c:859:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:861:            F[m][i] = F[m][i] - E->u1[m][i];
Stokes_flow_Incomp.c:867:    valid = solve_del2_u(E, E->u1, F, acc, lev);
Stokes_flow_Incomp.c:868:    if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:870:        fputs("Warning: solver not converging! 0\n", E->fp);
Stokes_flow_Incomp.c:872:    strip_bcs_from_residual(E, E->u1, lev);
Stokes_flow_Incomp.c:876:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:878:            V[m][i] += E->u1[m][i];
Topo_gravity.c:88:    //if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Topo_gravity.c:94:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:95:     for(snode=1;snode<=E->lmesh.nsf;snode++)   {
Topo_gravity.c:96:        node = E->surf_node[m][snode];
Topo_gravity.c:98:        tpgb[m][snode] =  2*SZZ[m][node-E->lmesh.noz+1]- SZZ[m][node-E->lmesh.noz+2];
Topo_gravity.c:116:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Topo_gravity.c:117:                for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:118:                        for(snode=1;snode<=E->lmesh.nsf;snode++) {
Topo_gravity.c:119:                                node = E->surf_node[m][snode];
Topo_gravity.c:120:                                /*freesurf[m][snode] += 0.5*(E->sphere.cap[m].V[3][node]+E->sphere.cap[m].Vprev[3][node])*E->advection.timestep;*/
Topo_gravity.c:121:                                freesurf[m][snode] += E->sphere.cap[m].V[3][node]*E->advection.timestep;
Topo_gravity.c:134:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Topo_gravity.c:135:    SXX[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:136:    SYY[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:137:    SXY[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:138:    SXZ[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:139:    SZY[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:140:    SZZ[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:141:    divv[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:142:    vorv[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:145:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Topo_gravity.c:146:    for(i=1;i<=E->lmesh.nno;i++) {
Topo_gravity.c:167:  for(m=1;m<=E->sphere.caps_per_proc;m++)        {
Topo_gravity.c:186:/*   stride = E->lmesh.nsf*6; */
Topo_gravity.c:188:/*   for(m=1;m<=E->sphere.caps_per_proc;m++) */
Topo_gravity.c:189:/*     for (node=1;node<=E->lmesh.nno;node++) */
Topo_gravity.c:190:/*       if ( (node%E->lmesh.noz)==0 )  { */
Topo_gravity.c:191:/*         i = node/E->lmesh.noz; */
Topo_gravity.c:192:/*         E->stress[m][(i-1)*6+1] = SXX[m][node]; */
Topo_gravity.c:193:/*         E->stress[m][(i-1)*6+2] = SYY[m][node]; */
Topo_gravity.c:194:/*         E->stress[m][(i-1)*6+3] = SZZ[m][node]; */
Topo_gravity.c:195:/*         E->stress[m][(i-1)*6+4] = SXY[m][node]; */
Topo_gravity.c:196:/*         E->stress[m][(i-1)*6+5] = SXZ[m][node]; */
Topo_gravity.c:197:/*         E->stress[m][(i-1)*6+6] = SZY[m][node]; */
Topo_gravity.c:199:/*      else if ( ((node+1)%E->lmesh.noz)==0 )  { */
Topo_gravity.c:200:/*         i = (node+1)/E->lmesh.noz; */
Topo_gravity.c:201:/*         E->stress[m][stride+(i-1)*6+1] = SXX[m][node]; */
Topo_gravity.c:202:/*         E->stress[m][stride+(i-1)*6+2] = SYY[m][node]; */
Topo_gravity.c:203:/*         E->stress[m][stride+(i-1)*6+3] = SZZ[m][node]; */
Topo_gravity.c:204:/*         E->stress[m][stride+(i-1)*6+4] = SXY[m][node]; */
Topo_gravity.c:205:/*         E->stress[m][stride+(i-1)*6+5] = SXZ[m][node]; */
Topo_gravity.c:206:/*         E->stress[m][stride+(i-1)*6+6] = SZY[m][node]; */
Topo_gravity.c:241:  const int lev = E->mesh.levmax;
Topo_gravity.c:242:  const int dims = E->mesh.nsd;
Topo_gravity.c:243:  const int nel = E->lmesh.nel;
Topo_gravity.c:247:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Topo_gravity.c:263:      dOmega = &(E->gDA[m][e]);	/* Jacobian at integration points */
Topo_gravity.c:264:      GNx = &(E->gNX[m][e]);	/* derivatives of shape functions at
Topo_gravity.c:278:	/* E->EVi[j] = E->EVI[E->mesh.levmax][j]; */
Topo_gravity.c:279:        pre[j] =  E->EVi[m][(e-1)*vpts+j]*dOmega->vpt[j];
Topo_gravity.c:296:          tww[i] += dOmega->vpt[j] * g_point[j].weight[E->mesh.nsd-1]
Topo_gravity.c:297:            * E->N.vpt[GNVINDEX(i,j)];
Topo_gravity.c:299:      if (E->control.precise_strain_rate){
Topo_gravity.c:304:	if ((e-1)%E->lmesh.elz==0) {
Topo_gravity.c:305:	  construct_c3x3matrix_el(E,e,&E->element_Cc,&E->element_Ccx,lev,m,0);
Topo_gravity.c:308:	get_ba(&(E->N), GNx, &E->element_Cc, &E->element_Ccx,rtf, dims, ba);
Topo_gravity.c:322:				     + VV[1][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])/sin(rtf[1][j])
Topo_gravity.c:326:		+ VV[2][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])
Topo_gravity.c:339:			  + VV[3][i]*E->N.vpt[GNVINDEX(i,j)] )*rtf[3][j];
Topo_gravity.c:341:			   + VV[1][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j]))/sin(rtf[1][j])
Topo_gravity.c:342:			  + VV[3][i]*E->N.vpt[GNVINDEX(i,j)] )*rtf[3][j];
Topo_gravity.c:346:			   - VV[2][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j]))/sin(rtf[1][j])
Topo_gravity.c:349:									 *GNx->vpt[GNVXINDEX(0,i,j)]-VV[1][i]*E->N.vpt[GNVINDEX(i,j)]);
Topo_gravity.c:351:									 *GNx->vpt[GNVXINDEX(1,i,j)]/sin(rtf[1][j])-VV[2][i]*E->N.vpt[GNVINDEX(i,j)]);
Topo_gravity.c:354:				     + VV[1][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])/sin(rtf[1][j])
Topo_gravity.c:358:		+ VV[2][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])
Topo_gravity.c:364:      if(E->control.inv_gruneisen != 0) { /* isotropic component */
Topo_gravity.c:369:    if(E->viscosity.allow_anisotropic_viscosity){ /* general anisotropic */
Topo_gravity.c:378:			 E->EVIn1[E->mesh.levmax][m][l1], 
Topo_gravity.c:379:			 E->EVIn2[E->mesh.levmax][m][l1], 
Topo_gravity.c:380:			 E->EVIn3[E->mesh.levmax][m][l1],
Topo_gravity.c:381:			 E->EVI2[E->mesh.levmax][m][l1],
Topo_gravity.c:382:			 E->avmode[E->mesh.levmax][m][l1],
Topo_gravity.c:425:      Sxx /= E->eco[m][e].area;
Topo_gravity.c:426:      Syy /= E->eco[m][e].area;
Topo_gravity.c:427:      Szz /= E->eco[m][e].area;
Topo_gravity.c:428:      Sxy /= E->eco[m][e].area;
Topo_gravity.c:429:      Sxz /= E->eco[m][e].area;
Topo_gravity.c:430:      Szy /= E->eco[m][e].area;
Topo_gravity.c:431:      div /= E->eco[m][e].area;
Topo_gravity.c:432:      vor /= E->eco[m][e].area;
Topo_gravity.c:435:      Szz -= E->P[m][e];
Topo_gravity.c:436:      Sxx -= E->P[m][e];
Topo_gravity.c:437:      Syy -= E->P[m][e];
Topo_gravity.c:440:        node = E->ien[m][e].node[i]; /* assign to global nodes */
Topo_gravity.c:454:  (E->exchange_node_f)(E,SXX,lev);
Topo_gravity.c:455:  (E->exchange_node_f)(E,SYY,lev);
Topo_gravity.c:456:  (E->exchange_node_f)(E,SZZ,lev);
Topo_gravity.c:457:  (E->exchange_node_f)(E,SXY,lev);
Topo_gravity.c:458:  (E->exchange_node_f)(E,SXZ,lev);
Topo_gravity.c:459:  (E->exchange_node_f)(E,SZY,lev);
Topo_gravity.c:460:  (E->exchange_node_f)(E,divv,lev);
Topo_gravity.c:461:  (E->exchange_node_f)(E,vorv,lev);
Topo_gravity.c:465:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:466:    for(node=1;node<=E->lmesh.nno;node++)   {
Topo_gravity.c:467:      mass_fac = E->Mass[m][node]*stress_scaling;
Topo_gravity.c:475:      mass_fac = E->Mass[m][node]*velo_scaling;
Topo_gravity.c:481:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:482:    for (node=1;node<=E->lmesh.nno;node++) {
Topo_gravity.c:483:      E->gstress[m][(node-1)*6+1] = SXX[m][node];
Topo_gravity.c:484:      E->gstress[m][(node-1)*6+2] = SYY[m][node];
Topo_gravity.c:485:      E->gstress[m][(node-1)*6+3] = SZZ[m][node];
Topo_gravity.c:486:      E->gstress[m][(node-1)*6+4] = SXY[m][node];
Topo_gravity.c:487:      E->gstress[m][(node-1)*6+5] = SXZ[m][node];
Topo_gravity.c:488:      E->gstress[m][(node-1)*6+6] = SZY[m][node];
Topo_gravity.c:509:                                   {0, 4, 2, 6}, /* E-W sides   yx yy yz */
Topo_gravity.c:514:  noxnoz = E->lmesh.nox*E->lmesh.noz;
Topo_gravity.c:516:  if(E->control.side_sbcs) {	/* side boundary conditions */
Topo_gravity.c:518:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Topo_gravity.c:519:      for(i=1; i<=E->lmesh.noy; i++)
Topo_gravity.c:520:        for(j=1; j<=E->lmesh.nox; j++)
Topo_gravity.c:521:          for(k=1; k<=E->lmesh.noz; k++) {
Topo_gravity.c:523:            n = k+(j-1)*E->lmesh.noz+(i-1)*noxnoz;
Topo_gravity.c:525:            for(d=1; d<=E->mesh.nsd; d++)
Topo_gravity.c:527:              if(E->node[m][n] & sbc_flag[d]) {
Topo_gravity.c:529:                  E->gstress[m][(n-1)*6+stress_index[d][2]] = E->sbc.SB[m][SIDE_WEST][d][ E->sbc.node[m][n] ];
Topo_gravity.c:530:                if(i==E->lmesh.noy)
Topo_gravity.c:531:                  E->gstress[m][(n-1)*6+stress_index[d][2]] = E->sbc.SB[m][SIDE_EAST][d][ E->sbc.node[m][n] ];
Topo_gravity.c:533:                  E->gstress[m][(n-1)*6+stress_index[d][1]] = E->sbc.SB[m][SIDE_NORTH][d][ E->sbc.node[m][n] ];
Topo_gravity.c:534:                if(j==E->lmesh.nox)
Topo_gravity.c:535:                  E->gstress[m][(n-1)*6+stress_index[d][1]] = E->sbc.SB[m][SIDE_SOUTH][d][ E->sbc.node[m][n] ];
Topo_gravity.c:537:                  E->gstress[m][(n-1)*6+stress_index[d][3]] = E->sbc.SB[m][SIDE_BOTTOM][d][ E->sbc.node[m][n] ];
Topo_gravity.c:538:                if(k==E->lmesh.noz)
Topo_gravity.c:539:                  E->gstress[m][(n-1)*6+stress_index[d][3]] = E->sbc.SB[m][SIDE_TOP][d][ E->sbc.node[m][n] ];
Topo_gravity.c:548:    if(E->mesh.toplayerbc != 0){
Topo_gravity.c:550:      for(m=1; m<=E->sphere.caps_per_proc; m++)
Topo_gravity.c:551:	for(i=1; i<=E->lmesh.noy; i++)
Topo_gravity.c:552:	  for(j=1; j<=E->lmesh.nox; j++)
Topo_gravity.c:553:	    for(k=1; k<=E->lmesh.noz; k++) {
Topo_gravity.c:554:	      n = k+(j-1)*E->lmesh.noz+(i-1)*noxnoz;
Topo_gravity.c:555:	      for(d=1; d<=E->mesh.nsd; d++)
Topo_gravity.c:556:		if(E->node[m][n] & sbc_flag[d]) {
Topo_gravity.c:558:		  E->gstress[m][(n-1)*6+stress_index[d][3]] = E->sphere.cap[m].VB[d][n];
Topo_gravity.c:563:      for(m=1; m<=E->sphere.caps_per_proc; m++)
Topo_gravity.c:564:	for(i=1; i<=E->lmesh.noy; i++)
Topo_gravity.c:565:	  for(j=1; j<=E->lmesh.nox; j++)
Topo_gravity.c:566:	    for(k=1; k<=E->lmesh.noz; k++) {
Topo_gravity.c:567:	      n = k+(j-1)*E->lmesh.noz+(i-1)*noxnoz;
Topo_gravity.c:568:	      for(d=1; d<=E->mesh.nsd; d++)
Topo_gravity.c:569:		if(E->node[m][n] & sbc_flag[d]) {
Topo_gravity.c:570:		  if(i==1 || i==E->lmesh.noy)
Topo_gravity.c:571:		    E->gstress[m][(n-1)*6+stress_index[d][2]] = E->sphere.cap[m].VB[d][n];
Topo_gravity.c:572:		  if(j==1 || j==E->lmesh.nox)
Topo_gravity.c:573:		    E->gstress[m][(n-1)*6+stress_index[d][1]] = E->sphere.cap[m].VB[d][n];
Topo_gravity.c:574:		  if(k==1 || k==E->lmesh.noz)
Topo_gravity.c:575:		    E->gstress[m][(n-1)*6+stress_index[d][3]] = E->sphere.cap[m].VB[d][n];
Topo_gravity.c:593:     * E->buoyancy needs to be converted to density (-therm_exp*ref_T/Ra/g)
Topo_gravity.c:603:    nxnz = E->lmesh.nox*E->lmesh.noz;
Topo_gravity.c:604:    radius_m = E->data.radius_km*1e3;
Topo_gravity.c:607:    scaling2 = -E->data.therm_exp*E->data.ref_temperature*E->data.density
Topo_gravity.c:608:      / fabs(E->control.Atemp);
Topo_gravity.c:610:    scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Topo_gravity.c:611:        / E->data.grav_acc;
Topo_gravity.c:614:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:615:        TT[m] = (float *) malloc ((E->lmesh.nsf+1)*sizeof(float));
Topo_gravity.c:618:    geoid[0] = (float*)malloc(E->sphere.hindice*sizeof(float));
Topo_gravity.c:620:    geoid[1] = (float*)malloc(E->sphere.hindice*sizeof(float));
Topo_gravity.c:623:    for (p = 0; p < E->sphere.hindice; p++) {
Topo_gravity.c:631:    for(k=1;k<E->lmesh.noz;k++)  {
Topo_gravity.c:633:        grav = 0.5 * (E->refstate.gravity[k] + E->refstate.gravity[k+1]);
Topo_gravity.c:635:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:636:            for(i=1;i<=E->lmesh.noy;i++)
Topo_gravity.c:637:                for(j=1;j<=E->lmesh.nox;j++)  {
Topo_gravity.c:638:                    node= k + (j-1)*E->lmesh.noz + (i-1)*nxnz;
Topo_gravity.c:639:                    p = j + (i-1)*E->lmesh.nox;
Topo_gravity.c:642:                    TT[m][p] = (E->buoyancy[m][node]+E->buoyancy[m][node+1])
Topo_gravity.c:650:        dlayer = (E->sx[1][3][k+1]-E->sx[1][3][k])*radius_m;
Topo_gravity.c:653:        radius = (E->sx[1][3][k+1]+E->sx[1][3][k])*0.5;
Topo_gravity.c:656:        for (ll=1;ll<=E->output.llmax;ll++) {
Topo_gravity.c:659:            conb = radius * pow(E->sphere.ri/radius, ((double)(ll)));
Topo_gravity.c:662:                p = E->sphere.hindex[ll][mm];
Topo_gravity.c:670:        //if(E->parallel.me==0)  fprintf(stderr,"layer %d %.5e %g %g %g\n",k,radius,dlayer,con1,con2);
Topo_gravity.c:679:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:693:     * E->slice.tpg is essentailly non-dimensional stress(rr) and need
Topo_gravity.c:701:    stress_scaling = E->data.ref_viscosity*E->data.therm_diff/
Topo_gravity.c:702:        (E->data.radius_km*E->data.radius_km*1e6);
Topo_gravity.c:705:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Topo_gravity.c:707:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Topo_gravity.c:710:    grav1 = E->refstate.gravity[E->lmesh.noz] * E->data.grav_acc;
Topo_gravity.c:712:    grav2 = E->refstate.gravity[1] * E->data.grav_acc;
Topo_gravity.c:719:    scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Topo_gravity.c:720:        / E->data.grav_acc;
Topo_gravity.c:722:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Topo_gravity.c:724:        sphere_expansion(E, E->slice.tpg, tpgt[0], tpgt[1]);
Topo_gravity.c:728:            for (i=0; i<E->sphere.hindice; i++) {
Topo_gravity.c:734:    if (E->parallel.me_loc[3] == 0) {
Topo_gravity.c:736:        sphere_expansion(E, E->slice.tpgb, tpgb[0], tpgb[1]);
Topo_gravity.c:740:            for (i=0; i<E->sphere.hindice; i++) {
Topo_gravity.c:747:    broadcast_vertical(E, tpgt[0], tpgt[1], E->parallel.nprocz-1);
Topo_gravity.c:771:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Topo_gravity.c:773:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Topo_gravity.c:777:    for (i = 0; i < E->sphere.hindice; i++) {
Topo_gravity.c:784:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Topo_gravity.c:786:        scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Topo_gravity.c:787:            / E->data.grav_acc;
Topo_gravity.c:791:            for (ll=2; ll<=E->output.llmax; ll++)   {
Topo_gravity.c:794:                    i = E->sphere.hindex[ll][mm];
Topo_gravity.c:801:    if (E->parallel.me_loc[3] == 0) {
Topo_gravity.c:803:        scaling = 1.0e3 * 4.0 * M_PI * E->data.radius_km * E->data.grav_const
Topo_gravity.c:804:            / (E->data.grav_acc * E->refstate.gravity[1]);
Topo_gravity.c:808:            for (ll=2; ll<=E->output.llmax; ll++)   {
Topo_gravity.c:810:                con2 = con1 * pow(E->sphere.ri, ((double)(ll+2)));
Topo_gravity.c:812:                    i = E->sphere.hindex[ll][mm];
Topo_gravity.c:820:    broadcast_vertical(E, geoid_tpgt[0], geoid_tpgt[1], E->parallel.nprocz-1);
Topo_gravity.c:846:    ri = E->sphere.ri;
Topo_gravity.c:849:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Topo_gravity.c:851:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Topo_gravity.c:854:    grav1 = E->refstate.gravity[E->lmesh.noz] * E->data.grav_acc;
Topo_gravity.c:856:    grav2 = E->refstate.gravity[1] * E->data.grav_acc;
Topo_gravity.c:863:    con4 = 4.0*M_PI*E->data.grav_const*E->data.radius_km*1000;
Topo_gravity.c:866:    for (i = 0; i < E->sphere.hindice; i++) {
Topo_gravity.c:873:    for (ll=2;ll<=E->output.llmax;ll++)   {
Topo_gravity.c:881:        a11 = den_contrast1*E->data.grav_acc - E->data.density*b1;
Topo_gravity.c:882:        a12 =                                - E->data.density*a1;
Topo_gravity.c:884:        a22 = den_contrast2*(E->data.grav_acc-a2);
Topo_gravity.c:889:            i = E->sphere.hindex[ll][mm];
Topo_gravity.c:892:            c1_0 = geoid_bncy[0][i]*E->data.density*grav1;
Topo_gravity.c:901:            c1_1 = geoid_bncy[1][i]*E->data.density*grav1;
Topo_gravity.c:929:    broadcast_vertical(E, geoid_tpgt[0], geoid_tpgt[1], E->parallel.nprocz-1);
Topo_gravity.c:941:    geoid_from_buoyancy(E, E->sphere.harm_geoid_from_bncy,
Topo_gravity.c:942:                        E->sphere.harm_geoid_from_bncy_botm);
Topo_gravity.c:944:    expand_topo_sph_harm(E, E->sphere.harm_tpgt, E->sphere.harm_tpgb);
Topo_gravity.c:946:    if(E->control.self_gravitation)
Topo_gravity.c:948:                                     E->sphere.harm_tpgt,
Topo_gravity.c:949:                                     E->sphere.harm_tpgb,
Topo_gravity.c:950:                                     E->sphere.harm_geoid_from_bncy,
Topo_gravity.c:951:                                     E->sphere.harm_geoid_from_bncy_botm,
Topo_gravity.c:952:                                     E->sphere.harm_geoid_from_tpgt,
Topo_gravity.c:953:                                     E->sphere.harm_geoid_from_tpgb);
Topo_gravity.c:955:        geoid_from_topography(E, E->sphere.harm_tpgt, E->sphere.harm_tpgb,
Topo_gravity.c:956:                              E->sphere.harm_geoid_from_tpgt,
Topo_gravity.c:957:                              E->sphere.harm_geoid_from_tpgb);
Topo_gravity.c:959:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Topo_gravity.c:961:            for (p = 0; p < E->sphere.hindice; p++) {
Topo_gravity.c:962:                E->sphere.harm_geoid[i][p]
Topo_gravity.c:963:                    = E->sphere.harm_geoid_from_bncy[i][p]
Topo_gravity.c:964:                    + E->sphere.harm_geoid_from_tpgt[i][p]
Topo_gravity.c:965:                    + E->sphere.harm_geoid_from_tpgb[i][p];
Topo_gravity.c:1017:    const int dims=E->mesh.nsd;
Topo_gravity.c:1021:    const int noz=E->lmesh.noz;
Topo_gravity.c:1022:    const int noy=E->lmesh.noy;
Topo_gravity.c:1023:    const int nno=E->lmesh.nno;
Topo_gravity.c:1026:    const int elz = E->lmesh.elz;
Topo_gravity.c:1027:    const int ely = E->lmesh.ely;
Topo_gravity.c:1028:    const int lev=E->mesh.levmax;
Topo_gravity.c:1031:    const int lnsf=E->lmesh.nsf;
Topo_gravity.c:1036:  for(j=1;j<=E->sphere.caps_per_proc;j++)          {
Topo_gravity.c:1043:  for(j=1;j<=E->sphere.caps_per_proc;j++)          {
Topo_gravity.c:1050:    for(els=1;els<=E->lmesh.snel;els++) {
Topo_gravity.c:1051:      el = E->surf_element[j][els];
Topo_gravity.c:1079:      if (E->control.augmented_Lagr) {
Topo_gravity.c:1087:           res[m]  = eltf[m]  - E->elt_del[lev][j][el].g[m][0]  * E->P[j][el];
Topo_gravity.c:1088:           resb[m] = eltfb[m] - E->elt_del[lev][j][elb].g[m][0]* E->P[j][elb];
Topo_gravity.c:1089://           res[m]  = eltf[m] - eltg[m][0]  * E->P[j][el];
Topo_gravity.c:1090://           resb[m] = eltfb[m] - eltgb[m][0]* E->P[j][elb];
Topo_gravity.c:1105:                nodes = E->sien[j][els].node[1];
Topo_gravity.c:1108:                nodes = E->sien[j][els].node[2];
Topo_gravity.c:1111:                nodes = E->sien[j][els].node[3];
Topo_gravity.c:1114:                nodes = E->sien[j][els].node[4];
Topo_gravity.c:1122:                nodes = E->sien[j][els].node[1];
Topo_gravity.c:1125:                nodes = E->sien[j][els].node[2];
Topo_gravity.c:1128:                nodes = E->sien[j][els].node[3];
Topo_gravity.c:1131:                nodes = E->sien[j][els].node[4];
Topo_gravity.c:1142:    for(els=1;els<=E->lmesh.snel;els++) {
Topo_gravity.c:1143:       el = E->surf_element[j][els];
Topo_gravity.c:1155:                * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Topo_gravity.c:1158:                * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Topo_gravity.c:1163:            SL[j][E->sien[j][els].node[m]] += eltTL[m-1];
Topo_gravity.c:1166:            SU[j][E->sien[j][els].node[m]] += eltTU[m-1];
Topo_gravity.c:1173:  if(E->parallel.me_loc[3] == 0) {
Topo_gravity.c:1174:  if(E->sphere.caps == 12)
Topo_gravity.c:1175:      full_exchange_snode_f(E,RL,SL,E->mesh.levmax);
Topo_gravity.c:1177:      regional_exchange_snode_f(E,RL,SL,E->mesh.levmax);
Topo_gravity.c:1179:  for (j=1;j<=E->sphere.caps_per_proc;j++)
Topo_gravity.c:1180:      for(i=1;i<=E->lmesh.nsf;i++)
Topo_gravity.c:1184:  if(E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Topo_gravity.c:1185:  if(E->sphere.caps == 12)
Topo_gravity.c:1186:      full_exchange_snode_f(E,RU,SU,E->mesh.levmax);
Topo_gravity.c:1188:      regional_exchange_snode_f(E,RU,SU,E->mesh.levmax);
Topo_gravity.c:1190:  for (j=1;j<=E->sphere.caps_per_proc;j++)
Topo_gravity.c:1191:      for(i=1;i<=E->lmesh.nsf;i++)
Topo_gravity.c:1196:    for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Tracer_setup.c:104:    int m=E->parallel.me;
Tracer_setup.c:107:    input_boolean("tracer",&(E->control.tracer),"off",m);
Tracer_setup.c:109:		  &(E->control.tracer_enriched),"off",m);
Tracer_setup.c:110:    if(E->control.tracer_enriched){
Tracer_setup.c:111:      if(!E->control.tracer)	/* check here so that we can get away
Tracer_setup.c:116:      input_float("Q0_enriched",&(E->control.Q0ER),"0.0",m);
Tracer_setup.c:118:	       E->control.Q0,E->control.Q0ER);
Tracer_setup.c:124:      //if(E->composition.ncomp != 1)
Tracer_setup.c:128:    if(E->control.tracer) {
Tracer_setup.c:133:        input_int("tracer_ic_method",&(E->trace.ic_method),"0,0,nomax",m);
Tracer_setup.c:135:        if (E->trace.ic_method==0){
Tracer_setup.c:136:            input_int("tracers_per_element",&(E->trace.itperel),"10,0,nomax",m);
Tracer_setup.c:138:        else if (E->trace.ic_method==1)
Tracer_setup.c:139:            input_string("tracer_file",E->trace.tracer_file,"tracer.dat",m);
Tracer_setup.c:140:        else if (E->trace.ic_method==2) {
Tracer_setup.c:155:        input_int("tracer_flavors",&(E->trace.nflavors),"0,0,nomax",m);
Tracer_setup.c:166:		  &(E->trace.ic_method_for_flavors),"0,0,nomax",m);
Tracer_setup.c:169:        if (E->trace.nflavors > 1) {
Tracer_setup.c:170:            switch(E->trace.ic_method_for_flavors){
Tracer_setup.c:174:                E->trace.z_interface = (double*) malloc((E->trace.nflavors-1)
Tracer_setup.c:176:                for(i=0; i<E->trace.nflavors-1; i++)
Tracer_setup.c:177:                    E->trace.z_interface[i] = 0.7;
Tracer_setup.c:179:                input_double_vector("z_interface", E->trace.nflavors-1,
Tracer_setup.c:180:                                    E->trace.z_interface, m);
Tracer_setup.c:190:	      input_string("ictracer_grd_file",E->trace.ggrd_file,"",m); /* file from which to read */
Tracer_setup.c:191:	      input_int("ictracer_grd_layers",&(E->trace.ggrd_layers),"2",m); /* 
Tracer_setup.c:201:                fprintf(stderr,"ic_method_for_flavors %i undefined (1 and 99 only for ggrd mode)\n",E->trace.ic_method_for_flavors);
Tracer_setup.c:208:        input_boolean("itracer_warnings",&(E->trace.itracer_warnings),"on",m);
Tracer_setup.c:211:        if(E->parallel.nprocxy == 12)
Tracer_setup.c:234:   E->trace.advection_time = 0;
Tracer_setup.c:235:   E->trace.find_tracers_time = 0;
Tracer_setup.c:236:   E->trace.lost_souls_time = 0;
Tracer_setup.c:238:   if(E->parallel.nprocxy == 1) {
Tracer_setup.c:239:       E->problem_tracer_setup = regional_tracer_setup;
Tracer_setup.c:241:       E->trace.keep_within_bounds = regional_keep_within_bounds;
Tracer_setup.c:242:       E->trace.get_velocity = regional_get_velocity;
Tracer_setup.c:243:       E->trace.iget_element = regional_iget_element;
Tracer_setup.c:246:       E->problem_tracer_setup = full_tracer_setup;
Tracer_setup.c:248:       E->trace.keep_within_bounds = full_keep_within_bounds;
Tracer_setup.c:249:       E->trace.get_velocity = full_get_velocity;
Tracer_setup.c:250:       E->trace.iget_element = full_iget_element;
Tracer_setup.c:275:    if (E->trace.nflavors > 0)
Tracer_setup.c:279:    if (E->composition.on) {
Tracer_setup.c:283:    E->trace.advection_time += CPU_time0() - begin_time;
Tracer_setup.c:300:    E->trace.istat_isend=0;
Tracer_setup.c:301:    E->trace.istat_elements_checked=0;
Tracer_setup.c:302:    E->trace.istat1=0;
Tracer_setup.c:305:    if ((E->monitor.solution_cycles % 20) == 0) {
Tracer_setup.c:306:        fprintf(E->trace.fpt, "STEP %d\n", E->monitor.solution_cycles);
Tracer_setup.c:308:        fprintf(E->trace.fpt, "Advecting tracers takes %f seconds.\n",
Tracer_setup.c:309:                E->trace.advection_time - E->trace.find_tracers_time);
Tracer_setup.c:310:        fprintf(E->trace.fpt, "Finding element takes %f seconds.\n",
Tracer_setup.c:311:                E->trace.find_tracers_time - E->trace.lost_souls_time);
Tracer_setup.c:312:        fprintf(E->trace.fpt, "Exchanging lost tracers takes %f seconds.\n",
Tracer_setup.c:313:                E->trace.lost_souls_time);
Tracer_setup.c:316:    if(E->control.verbose){
Tracer_setup.c:317:      fprintf(E->trace.fpt,"Number of times for all element search  %d\n",E->trace.istat1);
Tracer_setup.c:319:      fprintf(E->trace.fpt,"Number of tracers sent to other processors: %d\n",E->trace.istat_isend);
Tracer_setup.c:321:      fprintf(E->trace.fpt,"Number of times element columns are checked: %d \n",E->trace.istat_elements_checked);
Tracer_setup.c:325:      if (E->composition.on) {
Tracer_setup.c:326:        fprintf(E->trace.fpt,"Empty elements filled with old compositional "
Tracer_setup.c:327:                "values: %d (%f percent)\n", E->trace.istat_iempty,
Tracer_setup.c:328:                (100.0*E->trace.istat_iempty)/E->lmesh.nel);
Tracer_setup.c:329:        E->trace.istat_iempty=0;
Tracer_setup.c:334:        if (E->parallel.me==0) {
Tracer_setup.c:336:            fprintf(E->fp,"composition: %e",E->monitor.elapsed_time);
Tracer_setup.c:337:            for (i=0; i<E->composition.ncomp; i++)
Tracer_setup.c:338:                fprintf(E->fp," %e", E->composition.bulk_composition[i]);
Tracer_setup.c:339:            fprintf(E->fp,"\n");
Tracer_setup.c:341:            fprintf(E->fp,"composition_error_fraction: %e",E->monitor.elapsed_time);
Tracer_setup.c:342:            for (i=0; i<E->composition.ncomp; i++)
Tracer_setup.c:343:                fprintf(E->fp," %e", E->composition.error_fraction[i]);
Tracer_setup.c:344:            fprintf(E->fp,"\n");
Tracer_setup.c:348:      fflush(E->trace.fpt);
Tracer_setup.c:385:    dt=E->advection.timestep;
Tracer_setup.c:388:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:390:        numtracers=E->trace.ntracers[j];
Tracer_setup.c:394:            theta0=E->trace.basicq[j][0][kk];
Tracer_setup.c:395:            phi0=E->trace.basicq[j][1][kk];
Tracer_setup.c:396:            rad0=E->trace.basicq[j][2][kk];
Tracer_setup.c:397:            x0=E->trace.basicq[j][3][kk];
Tracer_setup.c:398:            y0=E->trace.basicq[j][4][kk];
Tracer_setup.c:399:            z0=E->trace.basicq[j][5][kk];
Tracer_setup.c:401:            nelem=E->trace.ielement[j][kk];
Tracer_setup.c:402:            (E->trace.get_velocity)(E,j,nelem,theta0,phi0,rad0,velocity_vector);
Tracer_setup.c:412:            (E->trace.keep_within_bounds)(E,&x_pred,&y_pred,&z_pred,&theta_pred,&phi_pred,&rad_pred);
Tracer_setup.c:416:            E->trace.basicq[j][0][kk]=theta_pred;
Tracer_setup.c:417:            E->trace.basicq[j][1][kk]=phi_pred;
Tracer_setup.c:418:            E->trace.basicq[j][2][kk]=rad_pred;
Tracer_setup.c:419:            E->trace.basicq[j][3][kk]=x_pred;
Tracer_setup.c:420:            E->trace.basicq[j][4][kk]=y_pred;
Tracer_setup.c:421:            E->trace.basicq[j][5][kk]=z_pred;
Tracer_setup.c:425:            E->trace.basicq[j][6][kk]=x0;
Tracer_setup.c:426:            E->trace.basicq[j][7][kk]=y0;
Tracer_setup.c:427:            E->trace.basicq[j][8][kk]=z0;
Tracer_setup.c:431:            E->trace.basicq[j][9][kk]=velocity_vector[1];  /* Vx */
Tracer_setup.c:432:            E->trace.basicq[j][10][kk]=velocity_vector[2];  /* Vy */
Tracer_setup.c:433:            E->trace.basicq[j][11][kk]=velocity_vector[3];  /* Vz */
Tracer_setup.c:482:    dt=E->advection.timestep;
Tracer_setup.c:485:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:486:        for (kk=1;kk<=E->trace.ntracers[j];kk++) {
Tracer_setup.c:488:            theta_pred=E->trace.basicq[j][0][kk];
Tracer_setup.c:489:            phi_pred=E->trace.basicq[j][1][kk];
Tracer_setup.c:490:            rad_pred=E->trace.basicq[j][2][kk];
Tracer_setup.c:491:            x_pred=E->trace.basicq[j][3][kk];
Tracer_setup.c:492:            y_pred=E->trace.basicq[j][4][kk];
Tracer_setup.c:493:            z_pred=E->trace.basicq[j][5][kk];
Tracer_setup.c:495:            x0=E->trace.basicq[j][6][kk];
Tracer_setup.c:496:            y0=E->trace.basicq[j][7][kk];
Tracer_setup.c:497:            z0=E->trace.basicq[j][8][kk];
Tracer_setup.c:499:            Vx0=E->trace.basicq[j][9][kk];
Tracer_setup.c:500:            Vy0=E->trace.basicq[j][10][kk];
Tracer_setup.c:501:            Vz0=E->trace.basicq[j][11][kk];
Tracer_setup.c:503:            nelem=E->trace.ielement[j][kk];
Tracer_setup.c:505:            (E->trace.get_velocity)(E,j,nelem,theta_pred,phi_pred,rad_pred,velocity_vector);
Tracer_setup.c:516:            (E->trace.keep_within_bounds)(E,&x_cor,&y_cor,&z_cor,&theta_cor,&phi_cor,&rad_cor);
Tracer_setup.c:520:            E->trace.basicq[j][0][kk]=theta_cor;
Tracer_setup.c:521:            E->trace.basicq[j][1][kk]=phi_cor;
Tracer_setup.c:522:            E->trace.basicq[j][2][kk]=rad_cor;
Tracer_setup.c:523:            E->trace.basicq[j][3][kk]=x_cor;
Tracer_setup.c:524:            E->trace.basicq[j][4][kk]=y_cor;
Tracer_setup.c:525:            E->trace.basicq[j][5][kk]=z_cor;
Tracer_setup.c:570:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:575:        E->trace.ilater[j]=E->trace.ilatersize[j]=0;
Tracer_setup.c:577:        E->trace.istat1=0;
Tracer_setup.c:579:            E->trace.istat_ichoice[j][kk]=0;
Tracer_setup.c:586:        num_tracers=E->trace.ntracers[j];
Tracer_setup.c:592:            theta=E->trace.basicq[j][0][it];
Tracer_setup.c:593:            phi=E->trace.basicq[j][1][it];
Tracer_setup.c:594:            rad=E->trace.basicq[j][2][it];
Tracer_setup.c:595:            x=E->trace.basicq[j][3][it];
Tracer_setup.c:596:            y=E->trace.basicq[j][4][it];
Tracer_setup.c:597:            z=E->trace.basicq[j][5][it];
Tracer_setup.c:599:            iprevious_element=E->trace.ielement[j][it];
Tracer_setup.c:601:            iel=(E->trace.iget_element)(E,j,iprevious_element,x,y,z,theta,phi,rad);
Tracer_setup.c:603:            fprintf(E->trace.fpt,"BB. kk %d %d %d %d %f %f %f %f %f %f\n",kk,j,iprevious_element,iel,x,y,z,theta,phi,rad);
Tracer_setup.c:604:            fflush(E->trace.fpt);
Tracer_setup.c:607:            E->trace.ielement[j][it]=iel;
Tracer_setup.c:619:                if (E->trace.itracer_warnings) exit(10);
Tracer_setup.c:638:    if (E->parallel.nprocxy == 12)
Tracer_setup.c:645:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:646:        if (E->trace.ilatersize[j]>0) {
Tracer_setup.c:647:            for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Tracer_setup.c:648:                free(E->trace.rlater[j][kk]);
Tracer_setup.c:658:    E->trace.find_tracers_time += CPU_time0() - begin_time;
Tracer_setup.c:675:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Tracer_setup.c:678:        for (flavor=0; flavor<E->trace.nflavors; flavor++)
Tracer_setup.c:679:            for (e=1; e<=E->lmesh.nel; e++)
Tracer_setup.c:680:                E->trace.ntracer_flavor[j][flavor][e] = 0;
Tracer_setup.c:682:        numtracers=E->trace.ntracers[j];
Tracer_setup.c:686:            e = E->trace.ielement[j][kk];
Tracer_setup.c:687:            flavor = E->trace.extraq[j][0][kk];
Tracer_setup.c:688:            E->trace.ntracer_flavor[j][flavor][e]++;
Tracer_setup.c:694:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Tracer_setup.c:695:        for (e=1; e<=E->lmesh.nel; e++) {
Tracer_setup.c:696:            fprintf(E->trace.fpt, "element=%d ntracer_flaver =", e);
Tracer_setup.c:697:            for (flavor=0; flavor<E->trace.nflavors; flavor++) {
Tracer_setup.c:698:                fprintf(E->trace.fpt, " %d",
Tracer_setup.c:699:                        E->trace.ntracer_flavor[j][flavor][e]);
Tracer_setup.c:701:            fprintf(E->trace.fpt, "\n");
Tracer_setup.c:704:    fflush(E->trace.fpt);
Tracer_setup.c:715:    if (E->trace.ic_method==0)
Tracer_setup.c:717:    else if (E->trace.ic_method==1)
Tracer_setup.c:719:    else if (E->trace.ic_method==2)
Tracer_setup.c:722:        fprintf(E->trace.fpt,"Not ready for other inputs yet\n");
Tracer_setup.c:723:        fflush(E->trace.fpt);
Tracer_setup.c:729:    E->trace.ilast_tracer_count = isum_tracers(E);
Tracer_setup.c:730:    fprintf(E->trace.fpt, "Sum of Tracers: %d\n", E->trace.ilast_tracer_count);
Tracer_setup.c:731:    if(E->parallel.me==0)
Tracer_setup.c:732:        fprintf(stderr, "Sum of Tracers: %d\n", E->trace.ilast_tracer_count);
Tracer_setup.c:742:    if (E->trace.nflavors > 0)
Tracer_setup.c:763:    if (E->parallel.me==0) fprintf(stderr,"Making Tracer Array\n");
Tracer_setup.c:765:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:767:        processor_fraction=E->lmesh.volume/E->mesh.volume;
Tracer_setup.c:768:        tracers_cap=E->mesh.nel*E->trace.itperel*processor_fraction;
Tracer_setup.c:770:          fprintf(stderr,"AA: proc frac: %f (%d) %d %d %f %f\n",processor_fraction,tracers_cap,E->lmesh.nel,E->parallel.nprocz, E->sx[j][3][E->lmesh.noz],E->sx[j][3][1]);
Tracer_setup.c:773:        fprintf(E->trace.fpt,"\nGenerating %d Tracers\n",tracers_cap);
Tracer_setup.c:783:    if (E->trace.nflavors) init_tracer_flavors(E);
Tracer_setup.c:808:    /* One must loop over E->X to find the min/max, since the 8 corner */
Tracer_setup.c:810:    xmin = ymin = zmin = E->sphere.ro;
Tracer_setup.c:811:    xmax = ymax = zmax = -E->sphere.ro;
Tracer_setup.c:812:    for (kk=1; kk<=E->lmesh.nno; kk++) {
Tracer_setup.c:813:        x = E->x[j][1][kk];
Tracer_setup.c:814:        y = E->x[j][2][kk];
Tracer_setup.c:815:        z = E->x[j][3][kk];
Tracer_setup.c:827:    while (E->trace.ntracers[j]<tracers_cap) {
Tracer_setup.c:833:            fprintf(E->trace.fpt,"Error(make_tracer_array)-too many tries?\n");
Tracer_setup.c:834:            fprintf(E->trace.fpt,"%d %d %d\n",max_tries,number_of_tries,RAND_MAX);
Tracer_setup.c:835:            fflush(E->trace.fpt);
Tracer_setup.c:857:        if (rad>=E->sx[j][3][E->lmesh.noz]) continue;
Tracer_setup.c:858:        if (rad<E->sx[j][3][1]) continue;
Tracer_setup.c:862:        if (E->parallel.nprocxy==1)
Tracer_setup.c:871:        (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Tracer_setup.c:873:        E->trace.ntracers[j]++;
Tracer_setup.c:874:        kk=E->trace.ntracers[j];
Tracer_setup.c:876:        E->trace.basicq[j][0][kk]=theta;
Tracer_setup.c:877:        E->trace.basicq[j][1][kk]=phi;
Tracer_setup.c:878:        E->trace.basicq[j][2][kk]=rad;
Tracer_setup.c:879:        E->trace.basicq[j][3][kk]=x;
Tracer_setup.c:880:        E->trace.basicq[j][4][kk]=y;
Tracer_setup.c:881:        E->trace.basicq[j][5][kk]=z;
Tracer_setup.c:919:    fptracer=fopen(E->trace.tracer_file,"r");
Tracer_setup.c:923:        fprintf(stderr,"Error while reading file '%s'\n", E->trace.tracer_file);
Tracer_setup.c:926:    fprintf(E->trace.fpt,"%d Tracers, %d columns in file \n",
Tracer_setup.c:930:    if (E->trace.number_of_extra_quantities+3 != ncolumns) {
Tracer_setup.c:931:        fprintf(E->trace.fpt,"ERROR(read tracer file)-wrong # of columns\n");
Tracer_setup.c:932:        fflush(E->trace.fpt);
Tracer_setup.c:942:    E->trace.number_of_tracers = number_of_tracers;
Tracer_setup.c:944:    iestimate=number_of_tracers/E->parallel.nproc + icushion;
Tracer_setup.c:946:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:952:            ncol = 3 + E->trace.number_of_extra_quantities;
Tracer_setup.c:956:                fprintf(E->trace.fpt,"ERROR(read tracer file) - wrong input file format: %s\n", E->trace.tracer_file);
Tracer_setup.c:957:                fflush(E->trace.fpt);
Tracer_setup.c:970:            (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Tracer_setup.c:975:            if (E->parallel.nprocz>1) icheck=icheck_processor_shell(E,j,rad);
Tracer_setup.c:978:            if (E->parallel.nprocxy==1)
Tracer_setup.c:988:            E->trace.ntracers[j]++;
Tracer_setup.c:990:            if (E->trace.ntracers[j]>=(E->trace.max_ntracers[j]-5)) expand_tracer_arrays(E,j);
Tracer_setup.c:992:            E->trace.basicq[j][0][E->trace.ntracers[j]]=theta;
Tracer_setup.c:993:            E->trace.basicq[j][1][E->trace.ntracers[j]]=phi;
Tracer_setup.c:994:            E->trace.basicq[j][2][E->trace.ntracers[j]]=rad;
Tracer_setup.c:995:            E->trace.basicq[j][3][E->trace.ntracers[j]]=x;
Tracer_setup.c:996:            E->trace.basicq[j][4][E->trace.ntracers[j]]=y;
Tracer_setup.c:997:            E->trace.basicq[j][5][E->trace.ntracers[j]]=z;
Tracer_setup.c:999:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Tracer_setup.c:1000:                E->trace.extraq[j][i][E->trace.ntracers[j]]=buffer[i+3];
Tracer_setup.c:1004:        fprintf(E->trace.fpt,"Number of tracers in this cap is: %d\n",
Tracer_setup.c:1005:                E->trace.ntracers[j]);
Tracer_setup.c:1008:        for (kk=1; kk<=E->trace.ntracers[j]; kk++) {
Tracer_setup.c:1009:            fprintf(E->trace.fpt, "tracer#=%d sph_coord=(%g,%g,%g)", kk,
Tracer_setup.c:1010:                    E->trace.basicq[j][0][kk],
Tracer_setup.c:1011:                    E->trace.basicq[j][1][kk],
Tracer_setup.c:1012:                    E->trace.basicq[j][2][kk]);
Tracer_setup.c:1013:            fprintf(E->trace.fpt, "   extraq=");
Tracer_setup.c:1014:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Tracer_setup.c:1015:                fprintf(E->trace.fpt, " %g", E->trace.extraq[j][i][kk]);
Tracer_setup.c:1016:            fprintf(E->trace.fpt, "\n");
Tracer_setup.c:1018:        fflush(E->trace.fpt);
Tracer_setup.c:1028:        fprintf(E->trace.fpt,"ERROR(read_tracer_file) - tracers != number in file\n");
Tracer_setup.c:1029:        fprintf(E->trace.fpt,"Tracers in system: %d\n", icheck);
Tracer_setup.c:1030:        fprintf(E->trace.fpt,"Tracers in file: %d\n", number_of_tracers);
Tracer_setup.c:1031:        fflush(E->trace.fpt);
Tracer_setup.c:1063:    if (E->trace.number_of_extra_quantities>99) {
Tracer_setup.c:1064:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-increase size of extra[]\n");
Tracer_setup.c:1065:        fflush(E->trace.fpt);
Tracer_setup.c:1073:    if(strcmp(E->output.format, "ascii-gz") == 0){
Tracer_setup.c:1075:	      E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Tracer_setup.c:1078:      sprintf(output_file,"%s.tracer.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Tracer_setup.c:1080:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-gziped file not found %s\n",output_file);
Tracer_setup.c:1081:        fflush(E->trace.fpt);
Tracer_setup.c:1086:    sprintf(output_file,"%s.tracer.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Tracer_setup.c:1088:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-file not found %s\n",output_file);
Tracer_setup.c:1089:        fflush(E->trace.fpt);
Tracer_setup.c:1097:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:1107:        if (E->trace.number_of_extra_quantities+3 != ncolumns) {
Tracer_setup.c:1108:            fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-wrong # of columns\n");
Tracer_setup.c:1109:            fflush(E->trace.fpt);
Tracer_setup.c:1116:        E->trace.ntracers[j]=numtracers;
Tracer_setup.c:1120:            ncol = 3 + E->trace.number_of_extra_quantities;
Tracer_setup.c:1124:                fprintf(E->trace.fpt,"ERROR(read_old_tracer_file) - wrong input file format: %s\n", output_file);
Tracer_setup.c:1125:                fflush(E->trace.fpt);
Tracer_setup.c:1137:            (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Tracer_setup.c:1139:            E->trace.basicq[j][0][kk]=theta;
Tracer_setup.c:1140:            E->trace.basicq[j][1][kk]=phi;
Tracer_setup.c:1141:            E->trace.basicq[j][2][kk]=rad;
Tracer_setup.c:1142:            E->trace.basicq[j][3][kk]=x;
Tracer_setup.c:1143:            E->trace.basicq[j][4][kk]=y;
Tracer_setup.c:1144:            E->trace.basicq[j][5][kk]=z;
Tracer_setup.c:1146:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Tracer_setup.c:1147:                E->trace.extraq[j][i][kk]=buffer[i+3];
Tracer_setup.c:1152:        for (kk=1; kk<=E->trace.ntracers[j]; kk++) {
Tracer_setup.c:1153:            fprintf(E->trace.fpt, "tracer#=%d sph_coord=(%g,%g,%g)", kk,
Tracer_setup.c:1154:                    E->trace.basicq[j][0][kk],
Tracer_setup.c:1155:                    E->trace.basicq[j][1][kk],
Tracer_setup.c:1156:                    E->trace.basicq[j][2][kk]);
Tracer_setup.c:1157:            fprintf(E->trace.fpt, "   extraq=");
Tracer_setup.c:1158:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Tracer_setup.c:1159:                fprintf(E->trace.fpt, " %g", E->trace.extraq[j][i][kk]);
Tracer_setup.c:1160:            fprintf(E->trace.fpt, "\n");
Tracer_setup.c:1162:        fflush(E->trace.fpt);
Tracer_setup.c:1165:        fprintf(E->trace.fpt,"Read %d tracers from file %s\n",numtracers,output_file);
Tracer_setup.c:1166:        fflush(E->trace.fpt);
Tracer_setup.c:1171:    if(strcmp(E->output.format, "ascii-gz") == 0)
Tracer_setup.c:1194:    iold_number = E->trace.ilast_tracer_count;
Tracer_setup.c:1197:        fprintf(E->trace.fpt,"ERROR(check_sum)-break in conservation %d %d\n",
Tracer_setup.c:1199:        fflush(E->trace.fpt);
Tracer_setup.c:1200:        if (E->trace.itracer_warnings)
Tracer_setup.c:1204:    E->trace.ilast_tracer_count = number;
Tracer_setup.c:1223:    for (j=1; j<=E->sphere.caps_per_proc; j++)
Tracer_setup.c:1224:        imycount = imycount + E->trace.ntracers[j];
Tracer_setup.c:1226:    MPI_Allreduce(&imycount,&iallcount,1,MPI_INT,MPI_SUM,E->parallel.world);
Tracer_setup.c:1284:    switch(E->trace.ic_method_for_flavors){
Tracer_setup.c:1289:      for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:1291:	number_of_tracers = E->trace.ntracers[j];
Tracer_setup.c:1293:	  rad = E->trace.basicq[j][2][kk];
Tracer_setup.c:1295:          flavor = E->trace.nflavors - 1;
Tracer_setup.c:1296:          for (i=0; i<E->trace.nflavors-1; i++) {
Tracer_setup.c:1297:              if (rad < E->trace.z_interface[i] || rad > (1.0 - E->viscosity.zlith)) {
Tracer_setup.c:1302:          E->trace.extraq[j][0][kk] = flavor;
Tracer_setup.c:1311:	      E->trace.ic_method_for_flavors);
Tracer_setup.c:1321:      fprintf(stderr,"ic_method_for_flavors %i undefined\n",E->trace.ic_method_for_flavors);
Tracer_setup.c:1333:/* which is later used by (E->trace.icheck_cap)()                            */
Tracer_setup.c:1352:    nox=E->lmesh.nox;
Tracer_setup.c:1353:    noy=E->lmesh.noy;
Tracer_setup.c:1354:    noz=E->lmesh.noz;
Tracer_setup.c:1361:    lev = E->mesh.levmax;
Tracer_setup.c:1364:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Tracer_setup.c:1370:                xx[n] = E->sx[j][d+1][node[i]];
Tracer_setup.c:1376:        num_ngb = E->parallel.TNUM_PASS[lev][j];
Tracer_setup.c:1378:            neighbor_proc = E->parallel.PROCESSOR[lev][j].pass[kk];
Tracer_setup.c:1381:                      tag, E->parallel.world, &request[idb]);
Tracer_setup.c:1385:                      tag, E->parallel.world, &request[idb]);
Tracer_setup.c:1399:         *      1) E->sphere.caps_per_proc==1
Tracer_setup.c:1400:         *      2) E->mesh.nsd==3
Tracer_setup.c:1407:                rad = E->sphere.ro;
Tracer_setup.c:1411:                E->trace.xcap[kk][i] = x;
Tracer_setup.c:1412:                E->trace.ycap[kk][i] = y;
Tracer_setup.c:1413:                E->trace.zcap[kk][i] = z;
Tracer_setup.c:1414:                E->trace.theta_cap[kk][i] = theta;
Tracer_setup.c:1415:                E->trace.phi_cap[kk][i] = phi;
Tracer_setup.c:1416:                E->trace.rad_cap[kk][i] = rad;
Tracer_setup.c:1417:                E->trace.cos_theta[kk][i] = cos(theta);
Tracer_setup.c:1418:                E->trace.sin_theta[kk][i] = sin(theta);
Tracer_setup.c:1419:                E->trace.cos_phi[kk][i] = cos(phi);
Tracer_setup.c:1420:                E->trace.sin_phi[kk][i] = sin(phi);
Tracer_setup.c:1427:                neighbor_proc = E->parallel.me;
Tracer_setup.c:1429:                neighbor_proc = E->parallel.PROCESSOR[lev][1].pass[kk];
Tracer_setup.c:1432:                fprintf(E->trace.fpt, "pass=%d rank=%d corner=%d "
Tracer_setup.c:1435:                        E->trace.theta_cap[kk][i],
Tracer_setup.c:1436:                        E->trace.phi_cap[kk][i],
Tracer_setup.c:1437:                        E->trace.rad_cap[kk][i]);
Tracer_setup.c:1440:        fflush(E->trace.fpt);
Tracer_setup.c:1461:    E->trace.max_ntracers[j]=number_of_tracers+number_of_tracers/4;
Tracer_setup.c:1462:    E->trace.ntracers[j]=0;
Tracer_setup.c:1466:    if ((E->trace.ielement[j]=(int *) malloc(E->trace.max_ntracers[j]*sizeof(int)))==NULL) {
Tracer_setup.c:1467:        fprintf(E->trace.fpt,"ERROR(make tracer array)-no memory 1a\n");
Tracer_setup.c:1468:        fflush(E->trace.fpt);
Tracer_setup.c:1471:    for (kk=1;kk<E->trace.max_ntracers[j];kk++)
Tracer_setup.c:1472:        E->trace.ielement[j][kk]=-99;
Tracer_setup.c:1475:    for (kk=0;kk<E->trace.number_of_basic_quantities;kk++) {
Tracer_setup.c:1476:        if ((E->trace.basicq[j][kk]=(double *)malloc(E->trace.max_ntracers[j]*sizeof(double)))==NULL) {
Tracer_setup.c:1477:            fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1b.%d\n",kk);
Tracer_setup.c:1478:            fflush(E->trace.fpt);
Tracer_setup.c:1483:    for (kk=0;kk<E->trace.number_of_extra_quantities;kk++) {
Tracer_setup.c:1484:        if ((E->trace.extraq[j][kk]=(double *)malloc(E->trace.max_ntracers[j]*sizeof(double)))==NULL) {
Tracer_setup.c:1485:            fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1c.%d\n",kk);
Tracer_setup.c:1486:            fflush(E->trace.fpt);
Tracer_setup.c:1491:    if (E->trace.nflavors > 0) {
Tracer_setup.c:1492:        E->trace.ntracer_flavor[j]=(int **)malloc(E->trace.nflavors*sizeof(int*));
Tracer_setup.c:1493:        for (kk=0;kk<E->trace.nflavors;kk++) {
Tracer_setup.c:1494:            if ((E->trace.ntracer_flavor[j][kk]=(int *)malloc((E->lmesh.nel+1)*sizeof(int)))==NULL) {
Tracer_setup.c:1495:                fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1c.%d\n",kk);
Tracer_setup.c:1496:                fflush(E->trace.fpt);
Tracer_setup.c:1503:    fprintf(E->trace.fpt,"Physical size of tracer arrays (max_ntracers): %d\n",
Tracer_setup.c:1504:            E->trace.max_ntracers[j]);
Tracer_setup.c:1505:    fflush(E->trace.fpt);
Tracer_setup.c:1525:    inewsize=E->trace.max_ntracers[j]+E->trace.max_ntracers[j]/5+icushion;
Tracer_setup.c:1527:    if ((E->trace.ielement[j]=(int *)realloc(E->trace.ielement[j],inewsize*sizeof(int)))==NULL) {
Tracer_setup.c:1528:        fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory (ielement)\n");
Tracer_setup.c:1529:        fflush(E->trace.fpt);
Tracer_setup.c:1533:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++) {
Tracer_setup.c:1534:        if ((E->trace.basicq[j][kk]=(double *)realloc(E->trace.basicq[j][kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:1535:            fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory (%d)\n",kk);
Tracer_setup.c:1536:            fflush(E->trace.fpt);
Tracer_setup.c:1541:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++) {
Tracer_setup.c:1542:        if ((E->trace.extraq[j][kk]=(double *)realloc(E->trace.extraq[j][kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:1543:            fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory 78 (%d)\n",kk);
Tracer_setup.c:1544:            fflush(E->trace.fpt);
Tracer_setup.c:1550:    fprintf(E->trace.fpt,"Expanding physical memory of ielement, basicq, and extraq to %d from %d\n",
Tracer_setup.c:1551:            inewsize,E->trace.max_ntracers[j]);
Tracer_setup.c:1553:    E->trace.max_ntracers[j]=inewsize;
Tracer_setup.c:1573:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:1578:        iempty_space=(E->trace.max_ntracers[j]-E->trace.ntracers[j]);
Tracer_setup.c:1580:        if (iempty_space>(E->trace.ntracers[j]+icushion)) {
Tracer_setup.c:1583:            inewsize=E->trace.ntracers[j]+E->trace.ntracers[j]/4+icushion;
Tracer_setup.c:1586:                fprintf(E->trace.fpt,"Error(reduce tracer arrays)-something up (hdf3)\n");
Tracer_setup.c:1587:                fflush(E->trace.fpt);
Tracer_setup.c:1592:            if ((E->trace.ielement[j]=(int *)realloc(E->trace.ielement[j],inewsize*sizeof(int)))==NULL) {
Tracer_setup.c:1593:                fprintf(E->trace.fpt,"ERROR(reduce tracer arrays )-no memory (ielement)\n");
Tracer_setup.c:1594:                fflush(E->trace.fpt);
Tracer_setup.c:1599:            for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++) {
Tracer_setup.c:1600:                if ((E->trace.basicq[j][kk]=(double *)realloc(E->trace.basicq[j][kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:1601:                    fprintf(E->trace.fpt,"AKM(reduce tracer arrays )-no memory (%d)\n",kk);
Tracer_setup.c:1602:                    fflush(E->trace.fpt);
Tracer_setup.c:1607:            for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++) {
Tracer_setup.c:1608:                if ((E->trace.extraq[j][kk]=(double *)realloc(E->trace.extraq[j][kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:1609:                    fprintf(E->trace.fpt,"AKM(reduce tracer arrays )-no memory 783 (%d)\n",kk);
Tracer_setup.c:1610:                    fflush(E->trace.fpt);
Tracer_setup.c:1616:            fprintf(E->trace.fpt,"Reducing physical memory of ielement, basicq, and extraq to %d from %d\n",
Tracer_setup.c:1617:                    E->trace.max_ntracers[j],inewsize);
Tracer_setup.c:1619:            E->trace.max_ntracers[j]=inewsize;
Tracer_setup.c:1644:    if (E->trace.ilatersize[j]==0) {
Tracer_setup.c:1646:        E->trace.ilatersize[j]=E->trace.max_ntracers[j]/5;
Tracer_setup.c:1648:        for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Tracer_setup.c:1649:            if ((E->trace.rlater[j][kk]=(double *)malloc(E->trace.ilatersize[j]*sizeof(double)))==NULL) {
Tracer_setup.c:1650:                fprintf(E->trace.fpt,"AKM(put_away_later)-no memory (%d)\n",kk);
Tracer_setup.c:1651:                fflush(E->trace.fpt);
Tracer_setup.c:1660:    E->trace.ilater[j]++;
Tracer_setup.c:1662:    if (E->trace.ilater[j] >= (E->trace.ilatersize[j]-5)) expand_later_array(E,j);
Tracer_setup.c:1666:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++)
Tracer_setup.c:1667:        E->trace.rlater[j][kk][E->trace.ilater[j]]=E->trace.basicq[j][kk][it];
Tracer_setup.c:1669:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++)
Tracer_setup.c:1670:        E->trace.rlater[j][E->trace.number_of_basic_quantities+kk][E->trace.ilater[j]]=E->trace.extraq[j][kk][it];
Tracer_setup.c:1690:    inewsize=E->trace.ilatersize[j]+E->trace.ilatersize[j]/5+icushion;
Tracer_setup.c:1692:    for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Tracer_setup.c:1693:        if ((E->trace.rlater[j][kk]=(double *)realloc(E->trace.rlater[j][kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:1694:            fprintf(E->trace.fpt,"AKM(expand later array )-no memory (%d)\n",kk);
Tracer_setup.c:1695:            fflush(E->trace.fpt);
Tracer_setup.c:1701:    fprintf(E->trace.fpt,"Expanding physical memory of rlater to %d from %d\n",
Tracer_setup.c:1702:            inewsize,E->trace.ilatersize[j]);
Tracer_setup.c:1704:    E->trace.ilatersize[j]=inewsize;
Tracer_setup.c:1719:    ilast_tracer=E->trace.ntracers[j];
Tracer_setup.c:1723:    E->trace.ielement[j][it]=E->trace.ielement[j][ilast_tracer];
Tracer_setup.c:1725:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++)
Tracer_setup.c:1726:        E->trace.basicq[j][kk][it]=E->trace.basicq[j][kk][ilast_tracer];
Tracer_setup.c:1728:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++)
Tracer_setup.c:1729:        E->trace.extraq[j][kk][it]=E->trace.extraq[j][kk][ilast_tracer];
Tracer_setup.c:1733:    E->trace.ntracers[j]--;
Tracer_setup.c:1755:    const int noz = E->lmesh.noz;
Tracer_setup.c:1756:    const int nprocz = E->parallel.nprocz;
Tracer_setup.c:1761:    top_r = E->sx[j][3][noz];
Tracer_setup.c:1762:    bottom_r = E->sx[j][3][1];
Tracer_setup.c:1775:    if ( (rad<=top_r) && (E->parallel.me_loc[3]==nprocz-1) ) return 1;
Tracer_setup.c:1797:    int me = E->parallel.me;
Tracer_setup.c:1812:    fprintf(E->trace.fpt, "Should not be here\n");
Tracer_setup.c:1813:    fprintf(E->trace.fpt, "Error(check_shell) nprocessor: %d, radius: %f\n",
Tracer_setup.c:1815:    fflush(E->trace.fpt);
Viscosity_structures.c:58:    int m=E->parallel.me;
Viscosity_structures.c:62:    input_boolean("VISC_UPDATE",&(E->viscosity.update_allowed),"on",m);
Viscosity_structures.c:64:    input_boolean("visc_layer_control",&(E->viscosity.layer_control),"off",m);
Viscosity_structures.c:65:    input_string("visc_layer_file", E->viscosity.layer_file,"visc.dat",m);
Viscosity_structures.c:68:    input_int("allow_anisotropic_viscosity",&(E->viscosity.allow_anisotropic_viscosity),"0",m);
Viscosity_structures.c:70:    if(E->viscosity.allow_anisotropic_viscosity){ /* error */
Viscosity_structures.c:75:    if(E->viscosity.allow_anisotropic_viscosity){ /* read additional
Viscosity_structures.c:79:      input_int("anisotropic_init",&(E->viscosity.anisotropic_init),"0",m); /* 0: isotropic
Viscosity_structures.c:89:      input_string("anisotropic_init_dir",(E->viscosity.anisotropic_init_dir),"",m); /* directory
Viscosity_structures.c:94:      input_int("anivisc_layer",&(E->viscosity.anivisc_layer),"1",m); /* >0: assign to layers on top of anivisc_layer
Viscosity_structures.c:97:      if((E->viscosity.anisotropic_init == 6) && (E->viscosity.anivisc_layer >= 0))
Viscosity_structures.c:101:		    &(E->viscosity.anivisc_start_from_iso),"on",m); /* start
Viscosity_structures.c:105:      if(!E->viscosity.anivisc_start_from_iso)
Viscosity_structures.c:106:	if(E->viscosity.anisotropic_init == 3){
Viscosity_structures.c:107:	  if(E->parallel.me == 0)fprintf(stderr,"WARNING: overriding anisotropic first step for ani init mode\n");
Viscosity_structures.c:108:	  E->viscosity.anivisc_start_from_iso = TRUE;
Viscosity_structures.c:111:      input_double("ani_vis2_factor",&(E->viscosity.ani_vis2_factor),"1.0",m);
Viscosity_structures.c:119:    for(i=0;i < E->viscosity.num_mat;i++)
Viscosity_structures.c:120:        E->viscosity.N0[i]=1.0;
Viscosity_structures.c:121:    input_float_vector("visc0",E->viscosity.num_mat,(E->viscosity.N0),m);
Viscosity_structures.c:123:    input_boolean("TDEPV",&(E->viscosity.TDEPV),"on",m);
Viscosity_structures.c:124:    input_int("rheol",&(E->viscosity.RHEOL),"3",m);
Viscosity_structures.c:125:    if (E->viscosity.TDEPV) {
Viscosity_structures.c:126:        for(i=0;i < E->viscosity.num_mat;i++) {
Viscosity_structures.c:127:            E->viscosity.T[i] = 0.0;
Viscosity_structures.c:128:            E->viscosity.Z[i] = 0.0;
Viscosity_structures.c:129:            E->viscosity.E[i] = 0.0;
Viscosity_structures.c:132:        input_float_vector("viscT",E->viscosity.num_mat,(E->viscosity.T),m);
Viscosity_structures.c:133:        input_float_vector("viscE",E->viscosity.num_mat,(E->viscosity.E),m);
Viscosity_structures.c:134:        input_float_vector("viscZ",E->viscosity.num_mat,(E->viscosity.Z),m);
Viscosity_structures.c:135:	input_float("visc_T_ref",&(E->viscosity.T_ref),"1.0",m);//haoyuanli
Viscosity_structures.c:137:        input_float("T_sol0",&(E->viscosity.T_sol0),"0.6",m);
Viscosity_structures.c:138:        input_float("ET_red",&(E->viscosity.ET_red),"0.1",m);
Viscosity_structures.c:142:    E->viscosity.sdepv_misfit = 1.0;
Viscosity_structures.c:143:    input_boolean("SDEPV",&(E->viscosity.SDEPV),"off",m);
Viscosity_structures.c:144:    if (E->viscosity.SDEPV) {
Viscosity_structures.c:145:      E->viscosity.sdepv_visited = 0;
Viscosity_structures.c:146:      input_float_vector("sdepv_expt",E->viscosity.num_mat,(E->viscosity.sdepv_expt),m);
Viscosity_structures.c:150:    input_boolean("PDEPV",&(E->viscosity.PDEPV),"off",m); /* plasticity addition by TWB */
Viscosity_structures.c:151:    if (E->viscosity.PDEPV) {
Viscosity_structures.c:152:      E->viscosity.pdepv_visited = 0;
Viscosity_structures.c:153:      for(i=0;i < E->viscosity.num_mat;i++) {
Viscosity_structures.c:154:          E->viscosity.pdepv_a[i] = 1.e20; /* \sigma_y = min(a + b * (1-r),y) */
Viscosity_structures.c:155:          E->viscosity.pdepv_b[i] = 0.0;
Viscosity_structures.c:156:          E->viscosity.pdepv_y[i] = 1.e20;
Viscosity_structures.c:159:      input_boolean("psrw",&(E->viscosity.psrw),"off",m); /* SRW? else regular plasiticity */
Viscosity_structures.c:160:      input_boolean("pdepv_eff",&(E->viscosity.pdepv_eff),"on",m); /* effective
Viscosity_structures.c:164:      input_float_vector("pdepv_a",E->viscosity.num_mat,(E->viscosity.pdepv_a),m);
Viscosity_structures.c:165:      input_float_vector("pdepv_b",E->viscosity.num_mat,(E->viscosity.pdepv_b),m);
Viscosity_structures.c:166:      input_float_vector("pdepv_y",E->viscosity.num_mat,(E->viscosity.pdepv_y),m);
Viscosity_structures.c:168:      input_float("pdepv_offset",&(E->viscosity.pdepv_offset),"0.0",m);
Viscosity_structures.c:170:    input_float("sdepv_misfit",&(E->viscosity.sdepv_misfit),"0.001",m);	/* there should be no harm in having 
Viscosity_structures.c:176:    //input_boolean("CDEPV",&(E->viscosity.CDEPV),"off",m);
Viscosity_structures.c:178:      E->viscosity.cdepv_ff[i] = 1.0; /* flavor factors for CDEPV */
Viscosity_structures.c:179:    if(E->viscosity.CDEPV){
Viscosity_structures.c:181:      if(E->control.tracer < 1){
Viscosity_structures.c:185:      if(E->trace.nflavors > 10)
Viscosity_structures.c:188:      input_float_vector("cdepv_ff",E->trace.nflavors,
Viscosity_structures.c:189:			 (E->viscosity.cdepv_ff),m);
Viscosity_structures.c:191:      for(i=0;i<E->trace.nflavors;i++)
Viscosity_structures.c:192:	E->viscosity.cdepv_ff[i] = log(E->viscosity.cdepv_ff[i]);
Viscosity_structures.c:196:    input_boolean("low_visc_channel",&(E->viscosity.channel),"off",m);
Viscosity_structures.c:197:    input_boolean("low_visc_wedge",&(E->viscosity.wedge),"off",m);
Viscosity_structures.c:199:    input_float("lv_min_radius",&(E->viscosity.lv_min_radius),"0.9764",m);
Viscosity_structures.c:200:    input_float("lv_max_radius",&(E->viscosity.lv_max_radius),"0.9921",m);
Viscosity_structures.c:201:    input_float("lv_channel_thickness",&(E->viscosity.lv_channel_thickness),"0.0047",m);
Viscosity_structures.c:202:    input_float("lv_reduction",&(E->viscosity.lv_reduction),"0.5",m);
Viscosity_structures.c:204:    input_boolean("use_ne_visc_smooth",&(E->viscosity.SMOOTH),"off",m);
Viscosity_structures.c:206:    input_boolean("VMAX",&(E->viscosity.MAX),"off",m);
Viscosity_structures.c:207:    if (E->viscosity.MAX)
Viscosity_structures.c:208:        input_float("visc_max",&(E->viscosity.max_value),"1e22,1,nomax",m);
Viscosity_structures.c:210:    input_boolean("VMIN",&(E->viscosity.MIN),"off",m);
Viscosity_structures.c:211:    if (E->viscosity.MIN)
Viscosity_structures.c:212:        input_float("visc_min",&(E->viscosity.min_value),"1e20",m);
Viscosity_structures.c:220:    int m = E->parallel.me;
Viscosity_structures.c:222:    input_string("Viscosity",E->viscosity.STRUCTURE,"system",m);
Viscosity_structures.c:223:    input_int ("visc_smooth_method",&(E->viscosity.smooth_cycles),"0",m);
Viscosity_structures.c:225:    if ( strcmp(E->viscosity.STRUCTURE,"system") == 0)
Viscosity_structures.c:226:        E->viscosity.FROM_SYSTEM = 1;
Viscosity_structures.c:228:        E->viscosity.FROM_SYSTEM = 0;
Viscosity_structures.c:230:    if (E->viscosity.FROM_SYSTEM)
Viscosity_structures.c:241:  if(E->viscosity.layer_control) {
Viscosity_structures.c:243:    i = E->mesh.noz - 1;
Viscosity_structures.c:245:    i = E->viscosity.num_mat;
Viscosity_structures.c:248:  E->viscosity.N0 = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:249:  E->viscosity.E = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:250:  E->viscosity.T = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:251:  E->viscosity.Z = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:252:  E->viscosity.pdepv_a = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:253:  E->viscosity.pdepv_b = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:254:  E->viscosity.pdepv_y = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:255:  E->viscosity.sdepv_expt = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:257:  if(E->viscosity.N0 == NULL ||
Viscosity_structures.c:258:     E->viscosity.E == NULL ||
Viscosity_structures.c:259:     E->viscosity.T == NULL ||
Viscosity_structures.c:260:     E->viscosity.Z == NULL ||
Viscosity_structures.c:261:     E->viscosity.pdepv_a == NULL ||
Viscosity_structures.c:262:     E->viscosity.pdepv_b == NULL ||
Viscosity_structures.c:263:     E->viscosity.pdepv_y == NULL ||
Viscosity_structures.c:264:     E->viscosity.sdepv_expt == NULL) {
Viscosity_structures.c:266:	    E->parallel.me);
Viscosity_structures.c:278:   evisc = E->EVI[E->mesh.levmax]
Viscosity_structures.c:279:   visc  = E->VI[E->mesh.levmax]
Viscosity_structures.c:303:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:305:    if(E->viscosity.allow_anisotropic_viscosity){
Viscosity_structures.c:306:      if(!E->viscosity.anisotropic_viscosity_init)
Viscosity_structures.c:314:    if(E->viscosity.TDEPV)
Viscosity_structures.c:319:    if(E->viscosity.CDEPV)	/* compositional prefactor */
Viscosity_structures.c:322:    if(E->viscosity.SDEPV)
Viscosity_structures.c:325:    if(E->viscosity.PDEPV)	/* "plasticity" */
Viscosity_structures.c:335:    if(E->viscosity.channel || E->viscosity.wedge)
Viscosity_structures.c:341:    if(E->viscosity.MAX) {
Viscosity_structures.c:342:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:343:            for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:345:                    if(evisc[m][(i-1)*vpts + j] > E->viscosity.max_value)
Viscosity_structures.c:346:                        evisc[m][(i-1)*vpts + j] = E->viscosity.max_value;
Viscosity_structures.c:349:    if(E->viscosity.MIN) {
Viscosity_structures.c:350:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:351:            for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:353:                    if(evisc[m][(i-1)*vpts + j] < E->viscosity.min_value)
Viscosity_structures.c:354:                        evisc[m][(i-1)*vpts + j] = E->viscosity.min_value;
Viscosity_structures.c:357:    if (E->control.verbose)  {
Viscosity_structures.c:358:      fprintf(E->fp_out,"output_evisc \n");
Viscosity_structures.c:359:      for(m=1;m<=E->sphere.caps_per_proc;m++) {
Viscosity_structures.c:360:        fprintf(E->fp_out,"output_evisc for cap %d\n",E->sphere.capid[m]);
Viscosity_structures.c:361:      for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:362:          fprintf(E->fp_out,"%d %d %f %f\n",i,E->mat[m][i],evisc[m][(i-1)*vpts+1],evisc[m][(i-1)*vpts+7]);
Viscosity_structures.c:364:      fflush(E->fp_out);
Viscosity_structures.c:367:    visc_from_gint_to_nodes(E,evisc,visc,E->mesh.levmax);
Viscosity_structures.c:369:    if(E->viscosity.SMOOTH){ /* go the other way, for
Viscosity_structures.c:371:      visc_from_nodes_to_gint(E,visc,evisc,E->mesh.levmax);
Viscosity_structures.c:375:    if(E->viscosity.allow_anisotropic_viscosity){
Viscosity_structures.c:376:      visc_from_gint_to_nodes(E,E->EVI2[E->mesh.levmax], E->VI2[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:377:      visc_from_gint_to_nodes(E,E->EVIn1[E->mesh.levmax], E->VIn1[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:378:      visc_from_gint_to_nodes(E,E->EVIn2[E->mesh.levmax], E->VIn2[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:379:      visc_from_gint_to_nodes(E,E->EVIn3[E->mesh.levmax], E->VIn3[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:380:      normalize_director_at_nodes(E,E->VIn1[E->mesh.levmax],E->VIn2[E->mesh.levmax],E->VIn3[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:382:      if(E->viscosity.SMOOTH){ 
Viscosity_structures.c:383:	if(E->parallel.me == 0)fprintf(stderr,"WARNING: smoothing anisotropic viscosity, perhaps not a good idea\n");
Viscosity_structures.c:384:	visc_from_nodes_to_gint(E,E->VI2[E->mesh.levmax],E->EVI2[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:385:	visc_from_nodes_to_gint(E,E->VIn1[E->mesh.levmax],E->EVIn1[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:386:	visc_from_nodes_to_gint(E,E->VIn2[E->mesh.levmax],E->EVIn2[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:387:	visc_from_nodes_to_gint(E,E->VIn3[E->mesh.levmax],E->EVIn3[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:388:	normalize_director_at_gint(E,E->EVIn1[E->mesh.levmax],E->EVIn2[E->mesh.levmax],E->EVIn3[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:404:    if (E->viscosity.FROM_SYSTEM)
Viscosity_structures.c:405:        get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Viscosity_structures.c:417:    if(E->control.mat_control){	/* use pre-factor even without temperature dependent viscosity */
Viscosity_structures.c:418:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:419:        for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:420:	  for(jj=1;jj<=vpoints[E->mesh.nsd];jj++)
Viscosity_structures.c:421:	    EEta[m][ (i-1)*vpoints[E->mesh.nsd]+jj ] = E->viscosity.N0[E->mat[m][i]-1]*E->VIP[m][i];
Viscosity_structures.c:423:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:424:        for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:425:	  for(jj=1;jj<=vpoints[E->mesh.nsd];jj++)
Viscosity_structures.c:426:	    EEta[m][ (i-1)*vpoints[E->mesh.nsd]+jj ] = E->viscosity.N0[E->mat[m][i]-1];
Viscosity_structures.c:439:    fp = fopen(E->viscosity.layer_file, "r");
Viscosity_structures.c:441:        fprintf(E->fp, "(Viscosity_structures #1) Cannot open %s\n", E->viscosity.layer_file);
Viscosity_structures.c:447:    for(i=0; i<E->mesh.elz; i++) {
Viscosity_structures.c:448:        E->viscosity.N0[i] =
Viscosity_structures.c:449:            E->viscosity.E[i] =
Viscosity_structures.c:450:            E->viscosity.T[i] =
Viscosity_structures.c:451:            E->viscosity.Z[i] =
Viscosity_structures.c:452:            E->viscosity.pdepv_a[i] =
Viscosity_structures.c:453:            E->viscosity.pdepv_b[i] =
Viscosity_structures.c:454:            E->viscosity.pdepv_y[i] =
Viscosity_structures.c:455:            E->viscosity.sdepv_expt[i] = 0;
Viscosity_structures.c:458:    read_visc_param_from_file(E, "visc0", E->viscosity.N0, fp);
Viscosity_structures.c:459:    if(E->viscosity.TDEPV) {
Viscosity_structures.c:460:        read_visc_param_from_file(E, "viscE", E->viscosity.E, fp);
Viscosity_structures.c:461:        read_visc_param_from_file(E, "viscT", E->viscosity.T, fp);
Viscosity_structures.c:462:        read_visc_param_from_file(E, "viscZ", E->viscosity.Z, fp);
Viscosity_structures.c:465:    if(E->viscosity.SDEPV) {
Viscosity_structures.c:466:        read_visc_param_from_file(E, "sdepv_expt", E->viscosity.sdepv_expt, fp);
Viscosity_structures.c:469:    if(E->viscosity.PDEPV) {
Viscosity_structures.c:470:        read_visc_param_from_file(E, "pdepv_a", E->viscosity.pdepv_a, fp);
Viscosity_structures.c:471:        read_visc_param_from_file(E, "pdepv_b", E->viscosity.pdepv_b, fp);
Viscosity_structures.c:472:        read_visc_param_from_file(E, "pdepv_y", E->viscosity.pdepv_y, fp);
Viscosity_structures.c:488:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:489:    const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:490:    const int nel = E->lmesh.nel;
Viscosity_structures.c:497:    switch (E->viscosity.RHEOL)   {
Viscosity_structures.c:500:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:502:                l = E->mat[m][i] - 1;
Viscosity_structures.c:504:                if(E->control.mat_control==0)
Viscosity_structures.c:505:                    tempa = E->viscosity.N0[l];
Viscosity_structures.c:507:                    tempa = E->viscosity.N0[l]*E->VIP[m][i];
Viscosity_structures.c:510:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:516:                        temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:520:                        exp( E->viscosity.E[l] * (E->viscosity.T[l] - temp));
Viscosity_structures.c:528:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:530:                l = E->mat[m][i] - 1;
Viscosity_structures.c:532:                if(E->control.mat_control==0)
Viscosity_structures.c:533:                    tempa = E->viscosity.N0[l];
Viscosity_structures.c:535:                    tempa = E->viscosity.N0[l]*E->VIP[m][i];
Viscosity_structures.c:538:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:544:                        temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:548:                        exp( -temp / E->viscosity.T[l]);
Viscosity_structures.c:560:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:562:                l = E->mat[m][i] - 1;
Viscosity_structures.c:563:		if(E->control.mat_control) /* switch moved up here TWB */
Viscosity_structures.c:564:		  tempa = E->viscosity.N0[l] * E->VIP[m][i];
Viscosity_structures.c:566:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:569:		  TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:579:		      temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:582:		      exp( E->viscosity.E[l]/(temp+E->viscosity.T[l])
Viscosity_structures.c:583:			   - E->viscosity.E[l]/(E->viscosity.T_ref +E->viscosity.T[l]) );//T_ref is one by default
Viscosity_structures.c:590:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:592:                l = E->mat[m][i] - 1;
Viscosity_structures.c:593:		if(E->control.mat_control) /* moved this up here TWB */
Viscosity_structures.c:594:		  tempa = E->viscosity.N0[l] * E->VIP[m][i];
Viscosity_structures.c:596:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:599:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:600:                    zz[kk] = (1.-E->sx[m][3][E->ien[m][i].node[kk]]);
Viscosity_structures.c:608:                        temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:609:                        zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:614:		      exp( (E->viscosity.E[l] +  E->viscosity.Z[l]*zzz )
Viscosity_structures.c:615:			   / (E->viscosity.T[l]+temp) );
Viscosity_structures.c:626:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:628:                l = E->mat[m][i] - 1;
Viscosity_structures.c:629:                tempa = E->viscosity.N0[l];
Viscosity_structures.c:632:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:639:                        temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:642:                    if(E->control.mat_control==0){
Viscosity_structures.c:644:                            exp( E->viscosity.E[l]/(temp+E->viscosity.T[l])
Viscosity_structures.c:645:                                 - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:648:	               exp( E->viscosity.E[l]/(temp+E->viscosity.T[l])
Viscosity_structures.c:649:		          - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:650:                       if(E->viscosity.MAX) {
Viscosity_structures.c:651:                           if(visc2 > E->viscosity.max_value)
Viscosity_structures.c:652:                               visc2 = E->viscosity.max_value;
Viscosity_structures.c:654:                       if(E->viscosity.MIN) {
Viscosity_structures.c:655:                           if(visc2 < E->viscosity.min_value)
Viscosity_structures.c:656:                               visc2 = E->viscosity.min_value;
Viscosity_structures.c:658:                       EEta[m][ (i-1)*vpts + jj ] = E->VIP[m][i]*visc2;
Viscosity_structures.c:671:        for(m=1;m <= E->sphere.caps_per_proc;m++)
Viscosity_structures.c:674:	    l = E->mat[m][i] - 1;
Viscosity_structures.c:676:	    if(E->control.mat_control)
Viscosity_structures.c:677:	      tempa = E->viscosity.N0[l] * E->VIP[m][i];
Viscosity_structures.c:679:	      tempa = E->viscosity.N0[l];
Viscosity_structures.c:682:	      TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:683:	      zz[kk] = (1.0 - E->sx[m][3][E->ien[m][i].node[kk]]);
Viscosity_structures.c:690:		temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:691:		zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:694:		exp( E->viscosity.E[l]*(E->viscosity.T[l] - temp) +
Viscosity_structures.c:695:		     zzz *  E->viscosity.Z[l]);
Viscosity_structures.c:697:               if(E->parallel.me == 0)
Viscosity_structures.c:699:                        zzz *E->data.radius_km ,l+1,
Viscosity_structures.c:700:                        tempa,temp,E->viscosity.T[l],E->viscosity.E[l], E->viscosity.Z[l],l+1,log10(EEta[m][ (i-1)*vpts + jj ]));
Viscosity_structures.c:724:           E->viscosity.E = Ea/(R*DT);
Viscosity_structures.c:726:           E->viscosity.Z = Va*rho*g/(R*DT);
Viscosity_structures.c:727:           E->viscosity.T = T0;
Viscosity_structures.c:734:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:736:	      l = E->mat[m][i] - 1;
Viscosity_structures.c:738:		if(E->control.mat_control)
Viscosity_structures.c:739:		  tempa = E->viscosity.N0[l] * E->VIP[m][i];
Viscosity_structures.c:741:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:744:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:745:                    zz[kk] = (1.-E->sx[m][3][E->ien[m][i].node[kk]]);
Viscosity_structures.c:752:                        temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:753:                        zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:758:                        exp( (E->viscosity.E[l] +  E->viscosity.Z[l]*zzz )
Viscosity_structures.c:759:                             / (E->viscosity.T[l] + temp)
Viscosity_structures.c:760:                             - (E->viscosity.E[l] +
Viscosity_structures.c:761:                                E->viscosity.Z[l]*(E->sphere.ro-E->sphere.ri) )
Viscosity_structures.c:762:                             / (E->viscosity.T[l] + one) );
Viscosity_structures.c:783:        dr = E->sphere.ro - E->sphere.ri;
Viscosity_structures.c:784:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:786:                l = E->mat[m][i] - 1;
Viscosity_structures.c:787:		if(E->control.mat_control) 
Viscosity_structures.c:788:		  tempa = E->viscosity.N0[l] * E->VIP[m][i];
Viscosity_structures.c:790:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:793:		  TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:794:		  zz[kk] = E->sx[m][3][E->ien[m][i].node[kk]]; /* radius */
Viscosity_structures.c:801:		      temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)]; /* mean temp */
Viscosity_structures.c:802:		      zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];/* mean r */
Viscosity_structures.c:806:		    zzz = (zzz - E->sphere.ri)/dr;
Viscosity_structures.c:807:		    visc1 = tempa* exp( E->viscosity.E[l]/(temp+E->viscosity.T[l]) 
Viscosity_structures.c:808:				  - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:809:		    if(temp < E->viscosity.T_sol0 + 2.*(1.-zzz))
Viscosity_structures.c:812:		      EEta[m][ (i-1)*vpts + jj ] = visc1 * E->viscosity.ET_red;
Viscosity_structures.c:822:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:824:                l = E->mat[m][i] - 1;
Viscosity_structures.c:825:		if(E->control.mat_control) /* switch moved up here TWB */
Viscosity_structures.c:826:		  tempa = E->viscosity.N0[l] * E->VIP[m][i];
Viscosity_structures.c:828:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:830:		  TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:835:		      temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:837:		      exp( E->viscosity.E[l]/(temp+E->viscosity.T[l])
Viscosity_structures.c:838:			   - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:853:        dr = E->sphere.ro - E->sphere.ri;
Viscosity_structures.c:854:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:856:                l = E->mat[m][i] - 1;
Viscosity_structures.c:857:		if(E->control.mat_control) 
Viscosity_structures.c:858:		  tempa = E->viscosity.N0[l] * E->VIP[m][i];
Viscosity_structures.c:860:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:863:		  TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:864:		  zz[kk] = E->sx[m][3][E->ien[m][i].node[kk]]; /* radius */
Viscosity_structures.c:870:		      temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)]; /* mean temp */
Viscosity_structures.c:871:		      zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];/* mean r */
Viscosity_structures.c:873:		    zzz = (zzz - E->sphere.ri)/dr;
Viscosity_structures.c:874:		    visc1 = tempa* exp( E->viscosity.E[l]/(temp+E->viscosity.T[l]) 
Viscosity_structures.c:875:				  - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:876:		    if(temp < E->viscosity.T_sol0 + 2.*(1.-zzz))
Viscosity_structures.c:879:		      EEta[m][ (i-1)*vpts + jj ] = visc1 * E->viscosity.ET_red;
Viscosity_structures.c:888:                E->viscosity.RHEOL);
Viscosity_structures.c:894:        fprintf(stderr, "Invalid value of 'rheol=%d'\n", E->viscosity.RHEOL);
Viscosity_structures.c:916:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:917:    const int nel = E->lmesh.nel;
Viscosity_structures.c:923:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Viscosity_structures.c:924:      if(E->viscosity.sdepv_visited){
Viscosity_structures.c:931:	E->viscosity.sdepv_visited = 1;
Viscosity_structures.c:940:            exponent1= one/E->viscosity.sdepv_expt[E->mat[m][e]-1];
Viscosity_structures.c:1002:  const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:1003:  const int nel = E->lmesh.nel;
Viscosity_structures.c:1004:  const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:1011:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Viscosity_structures.c:1013:    if(E->viscosity.pdepv_visited){
Viscosity_structures.c:1014:      if(E->viscosity.psrw)
Viscosity_structures.c:1021:      if(m == E->sphere.caps_per_proc)
Viscosity_structures.c:1022:	E->viscosity.pdepv_visited = 1;
Viscosity_structures.c:1023:      if((E->parallel.me == 0)&&(E->control.verbose)){
Viscosity_structures.c:1025:		e,E->viscosity.pdepv_a[e],E->viscosity.pdepv_b[e],E->viscosity.pdepv_y[e],
Viscosity_structures.c:1026:		(E->viscosity.psrw)?(" -- SRW"):(""));
Viscosity_structures.c:1029:    if(!E->viscosity.psrw){
Viscosity_structures.c:1035:	l = E->mat[m][e] -1 ;	/* material of this element */
Viscosity_structures.c:1038:	  zz[kk] = (1.0 - E->sx[m][3][E->ien[m][e].node[kk]]); /* for depth, zz = 1 - r */
Viscosity_structures.c:1044:	    zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:1047:	  tau = E->viscosity.pdepv_a[l] + zzz * E->viscosity.pdepv_b[l];
Viscosity_structures.c:1050:	  tau = min(tau,  E->viscosity.pdepv_y[l]);
Viscosity_structures.c:1053:	  eta_p = tau/(2.0 * eedot[e] + 1e-7) + E->viscosity.pdepv_offset;
Viscosity_structures.c:1054:	  if(E->viscosity.pdepv_eff){
Viscosity_structures.c:1062:	  //	  zzz,l,E->viscosity.pdepv_a[l], E->viscosity.pdepv_b[l],E->viscosity.pdepv_y[l],
Viscosity_structures.c:1071:	l = E->mat[m][e] -1 ;	
Viscosity_structures.c:1073:	  zz[kk] = (1.0 - E->sx[m][3][E->ien[m][e].node[kk]]); 
Viscosity_structures.c:1077:	    zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:1079:	  tau = E->viscosity.pdepv_a[l] + zzz * E->viscosity.pdepv_b[l];
Viscosity_structures.c:1080:	  tau = min(tau,  E->viscosity.pdepv_y[l]);
Viscosity_structures.c:1089:	    //	    E->viscosity.pdepv_a[l],E->viscosity.pdepv_b[l],E->viscosity.pdepv_y[l],zzz,tau,eedot[e],eta_old,eta_new,
Viscosity_structures.c:1116:  const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:1117:  const int nel = E->lmesh.nel;
Viscosity_structures.c:1118:  const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:1120:  for(m=1;m <= E->sphere.caps_per_proc;m++)  {
Viscosity_structures.c:1124:        for(p=0; p<E->composition.ncomp; p++) {
Viscosity_structures.c:1126:                CC[p][kk] = E->composition.comp_node[m][p][E->ien[m][i].node[kk]];
Viscosity_structures.c:1134:            for(p=0; p<E->composition.ncomp; p++) {
Viscosity_structures.c:1138:                    cc_loc[p] += CC[p][kk] * E->N.vpt[GNVINDEX(kk, jj)];
Viscosity_structures.c:1144:            vmean = cbackground * E->viscosity.cdepv_ff[0];
Viscosity_structures.c:1145:            for(p=0; p<E->composition.ncomp; p++) {
Viscosity_structures.c:1146:                vmean += cc_loc[p] * E->viscosity.cdepv_ff[p+1];
Viscosity_structures.c:1177:    const int nel = E->lmesh.nel;
Viscosity_structures.c:1178:    const int dims = E->mesh.nsd;
Viscosity_structures.c:1180:    const int lev = E->mesh.levmax;
Viscosity_structures.c:1189:        GNx = &(E->gNX[m][e]);
Viscosity_structures.c:1214:        if ((E->control.precise_strain_rate) || (theta < 0.09) || (theta > 3.05)) {
Viscosity_structures.c:1222:            if ((e-1)%E->lmesh.elz==0) {
Viscosity_structures.c:1223:                construct_c3x3matrix_el(E,e,&E->element_Cc,&E->element_Ccx,lev,m,1);
Viscosity_structures.c:1226:            get_ba_p(&(E->N), GNx, &E->element_Cc, &E->element_Ccx,
Viscosity_structures.c:1227:                     rtf, E->mesh.nsd, ba);
Viscosity_structures.c:1241:                                   + VV[3][i] * E->N.ppt[GNPINDEX(i, j)])
Viscosity_structures.c:1244:                                    + VV[1][i] * E->N.ppt[GNPINDEX(i, j)]
Viscosity_structures.c:1246:                                   + VV[3][i] * E->N.ppt[GNPINDEX(i, j)])
Viscosity_structures.c:1251:                                    - VV[2][i] * E->N.ppt[GNPINDEX(i, j)]
Viscosity_structures.c:1257:                                       - VV[1][i] * E->N.ppt[GNPINDEX(i, j)]);
Viscosity_structures.c:1262:                                       - VV[2][i] * E->N.ppt[GNPINDEX(i, j)]);
Viscosity_structures.c:1267:        if(E->control.inv_gruneisen != 0) {
Viscosity_structures.c:1309:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:1313:    if(E->control.tracer == 0) {
Viscosity_structures.c:1314:        if(E->parallel.me == 0) {
Viscosity_structures.c:1317:            fprintf(E->fp, "Error: low viscosity channel/wedge is turned on, "
Viscosity_structures.c:1319:            fflush(E->fp);
Viscosity_structures.c:1325:    F = (float *)malloc((E->lmesh.nel+1)*sizeof(float));
Viscosity_structures.c:1326:    for(i=1 ; i<=E->lmesh.nel ; i++)
Viscosity_structures.c:1330:    if(E->viscosity.channel)
Viscosity_structures.c:1335:    if(E->viscosity.wedge)
Viscosity_structures.c:1339:    for(i=1 ; i<=E->lmesh.nel ; i++) {
Viscosity_structures.c:1341:            for(m = 1 ; m <= E->sphere.caps_per_proc ; m++) {
Viscosity_structures.c:1364:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Viscosity_structures.c:1366:        for(e=1; e<=E->lmesh.elz; e++) {
Viscosity_structures.c:1367:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:1368:                              E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:1369:            if(rad_mean >= E->viscosity.lv_min_radius) break;
Viscosity_structures.c:1374:        for(e=E->lmesh.elz; e>=1; e--) {
Viscosity_structures.c:1375:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:1376:                              E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:1377:            if(rad_mean <= E->viscosity.lv_max_radius) break;
Viscosity_structures.c:1384:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Viscosity_structures.c:1385:        for(k=1; k<=E->lmesh.elx*E->lmesh.ely; k++) {
Viscosity_structures.c:1387:                e = (k-1)*E->lmesh.elz + i;
Viscosity_structures.c:1389:                rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:1390:                                  E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:1394:                    ee = (k-1)*E->lmesh.elz + ii;
Viscosity_structures.c:1396:                    rr = 0.5 * (E->sx[m][3][E->ien[m][ee].node[1]] +
Viscosity_structures.c:1397:                                E->sx[m][3][E->ien[m][ee].node[8]]);
Viscosity_structures.c:1400:                    if((E->trace.ntracer_flavor[m][flavor][ee] > 0) &&
Viscosity_structures.c:1401:                       (rad_mean <= rr + E->viscosity.lv_channel_thickness)) {
Viscosity_structures.c:1402:                           F[e] = E->viscosity.lv_reduction;
Viscosity_structures.c:1412:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Viscosity_structures.c:1413:        for(e=1; e<=E->lmesh.nel; e++)
Viscosity_structures.c:1428:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Viscosity_structures.c:1430:        for(e=1; e<=E->lmesh.elz; e++) {
Viscosity_structures.c:1431:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:1432:                              E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:1433:            if(rad_mean >= E->viscosity.lv_min_radius) break;
Viscosity_structures.c:1438:        for(e=E->lmesh.elz; e>=1; e--) {
Viscosity_structures.c:1439:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:1440:                              E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:1441:            if(rad_mean <= E->viscosity.lv_max_radius) break;
Viscosity_structures.c:1448:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Viscosity_structures.c:1449:        for(k=1; k<=E->lmesh.elx*E->lmesh.ely; k++) {
Viscosity_structures.c:1451:                e = (k-1)*E->lmesh.elz + i;
Viscosity_structures.c:1453:                rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:1454:                                  E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:1458:                    ee = (k-1)*E->lmesh.elz + ii;
Viscosity_structures.c:1461:                    if(E->trace.ntracer_flavor[m][flavor][ee] > 0) {
Viscosity_structures.c:1462:                        F[e] = E->viscosity.lv_reduction;
Viscosity_structures.c:1472:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Viscosity_structures.c:1473:        for(e=1; e<=E->lmesh.nel; e++)
